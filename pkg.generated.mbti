// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/mpython"

// Values
pub fn format_parse_error(ParseError) -> String

pub fn format_runtime_error(RuntimeError) -> String

pub fn parse(String) -> Result[Module, ParseError]

pub fn parse_expr(String) -> Result[Expr, ParseError]

// Errors

// Types and methods
pub enum BinaryOp {
  Add
  Sub
  Mul
  Div
  FloorDiv
  Mod
  Pow
}
pub impl ToJson for BinaryOp

pub enum BoolOp {
  And
  Or
}
pub impl ToJson for BoolOp

pub enum CompareOp {
  Eq
  NotEq
  Lt
  Lte
  Gt
  Gte
  In
  NotIn
  Is
  IsNot
}
pub impl ToJson for CompareOp

pub struct Config {
  max_recursion : Int
  traceback_limit : Int
  track_spans : Bool
}
pub fn Config::default() -> Self
pub impl ToJson for Config

pub enum Expr {
  Literal(Literal)
  Name(String)
  Tuple(Array[Expr])
  List(Array[Expr])
  Dict(Array[(Expr, Expr)])
  Set(Array[Expr])
  Lambda(params~ : Array[String], body~ : Expr)
  IfExpr(condition~ : Expr, then_expr~ : Expr, else_expr~ : Expr)
  FString(String)
  Slice(start~ : Expr?, end~ : Expr?)
  Attribute(value~ : Expr, attr~ : String)
  Subscript(value~ : Expr, index~ : Expr)
  Call(callee~ : Expr, args~ : Array[Expr])
  Unary(op~ : UnaryOp, expr~ : Expr)
  Binary(op~ : BinaryOp, left~ : Expr, right~ : Expr)
  BoolOp(op~ : BoolOp, values~ : Array[Expr])
  Compare(left~ : Expr, ops~ : Array[CompareOp], comparators~ : Array[Expr])
}
pub impl ToJson for Expr

pub struct FunctionValue {
  name : String
  params : Array[String]
  body : Array[Stmt]
}
pub impl ToJson for FunctionValue

pub struct Interpreter {
  config : Config
  globals : Array[(String, Value)]
  builtins : Array[(String, Value)]
  io : MockIO
}
pub fn Interpreter::eval(Self, Expr) -> Result[Value, RuntimeError]
pub fn Interpreter::eval_source(Self, String) -> Result[RunResult, RuntimeError]
pub fn Interpreter::exec(Self, Module) -> Result[RunResult, RuntimeError]
pub fn Interpreter::exec_source(Self, String) -> Result[RunResult, RuntimeError]
pub fn Interpreter::get_global(Self, String) -> Value?
pub fn Interpreter::new() -> Self
pub fn Interpreter::set_global(Self, String, Value) -> Unit
pub fn Interpreter::with_builtins(Array[(String, Value)], Config) -> Self
pub fn Interpreter::with_config(Config) -> Self
pub fn Interpreter::with_io(Config, MockIO) -> Self

pub enum Literal {
  None
  Bool(Bool)
  Int(Int64)
  Float(Double)
  Str(String)
}
pub impl ToJson for Literal

pub struct MockIO {
  stdin : Array[String]
  stdin_pos : Ref[Int]
  stdout : StringBuilder
  stderr : StringBuilder
}
pub fn MockIO::new(Array[String]) -> Self
pub fn MockIO::read_line(Self) -> String?
pub fn MockIO::take_stderr(Self) -> String
pub fn MockIO::take_stdout(Self) -> String
pub fn MockIO::write_stderr(Self, String) -> Unit
pub fn MockIO::write_stdout(Self, String) -> Unit

pub struct Module {
  body : Array[Stmt]
}
pub impl ToJson for Module

pub(all) struct ParseError {
  kind : ParseErrorKind
  message : String
  span : Span
}
pub impl ToJson for ParseError

pub(all) enum ParseErrorKind {
  Syntax
  Indentation
  UnexpectedToken
  UnexpectedEof
}
pub impl ToJson for ParseErrorKind

pub struct RunResult {
  value : Value
  stdout : String
  stderr : String
  globals : Array[(String, Value)]
}
pub impl ToJson for RunResult

pub(all) struct RuntimeError {
  kind : RuntimeErrorKind
  message : String
  span : Span?
}
pub impl ToJson for RuntimeError

pub(all) enum RuntimeErrorKind {
  Name
  Type
  Attribute
  Index
  Key
  ZeroDivision
  NotImplemented
  Runtime
}
pub impl ToJson for RuntimeErrorKind

pub(all) struct Span {
  start : Int
  end : Int
  line : Int
  column : Int
}
pub impl ToJson for Span

pub enum Stmt {
  ExprStmt(Expr)
  Assign(target~ : Target, value~ : Expr)
  Return(Expr?)
  If(condition~ : Expr, body~ : Array[Stmt], else_body~ : Array[Stmt])
  While(condition~ : Expr, body~ : Array[Stmt])
  Function(name~ : String, params~ : Array[String], body~ : Array[Stmt])
  Pass
  Global(Array[String])
  Assert(condition~ : Expr, message~ : Expr?)
  Raise(Expr?)
  Del(Array[String])
}
pub impl ToJson for Stmt

pub enum Target {
  Name(String)
  Attribute(value~ : Expr, attr~ : String)
  Subscript(value~ : Expr, index~ : Expr)
}
pub impl ToJson for Target

pub enum UnaryOp {
  Pos
  Neg
  Not
  Invert
}
pub impl ToJson for UnaryOp

pub enum Value {
  None
  Bool(Bool)
  Int(Int64)
  Float(Double)
  Str(String)
  List(Array[Value])
  Tuple(Array[Value])
  Dict(Array[(Value, Value)])
  Function(FunctionValue)
}
pub impl ToJson for Value

// Type aliases

// Traits

