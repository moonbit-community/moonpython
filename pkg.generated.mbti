// Generated using `moon info`, DON'T EDIT IT
package "moonbit-community/moonpython"

import {
  "moonbitlang/core/bigint",
}

// Values
pub fn bc_disassemble(BcCode) -> String

pub fn bc_exec(BcCode, Array[(String, Value)], Array[(String, Value)], Array[(String, Value)], MockIO) -> Result[Value, RuntimeError]

pub fn bc_patch_jump(BcCode, Int, Int) -> Unit

pub fn compile_module_to_bc(Module, String) -> Result[BcCode, RuntimeError]

pub fn compile_stmts_to_bc(Array[Stmt], String, String) -> Result[BcCode, RuntimeError]

pub fn coroutine_await(Value) -> Result[Value, RuntimeError]

pub fn coroutine_is_active() -> Bool

pub fn format_parse_error(ParseError) -> String

pub fn format_runtime_error(RuntimeError) -> String

pub fn format_runtime_error_with_traceback(RuntimeError, Int) -> String

pub fn parse(String) -> Result[Module, ParseError]

pub fn parse_expr(String) -> Result[Expr, ParseError]

// Errors
pub suberror MpythonError {
  MpythonError(RuntimeError)
}

// Types and methods
pub(all) struct BcBuilder {
  code : BcCode
}
pub fn BcBuilder::add_const(Self, Value) -> Int
pub fn BcBuilder::add_genexp(Self, GenExpSpec) -> Int
pub fn BcBuilder::add_pattern(Self, Pattern) -> Int
pub fn BcBuilder::emit(Self, BcOp, Span?) -> Int
pub fn BcBuilder::intern_name(Self, String) -> Int
pub fn BcBuilder::new(String, String) -> Self

pub(all) struct BcCode {
  name : String
  filename : String
  consts : Array[Value]
  names : Array[String]
  patterns : Array[Pattern]
  genexps : Array[GenExpSpec]
  ops : Array[BcOp]
  spans : Array[Span?]
}
pub fn BcCode::empty(String, String) -> Self

pub(all) enum BcOp {
  Nop
  PopTop
  DupTop
  RotTwo
  RotThree
  LoadConst(Int)
  LoadName(Int)
  StoreName(Int)
  DeleteName(Int)
  LoadAttr(Int)
  StoreAttr(Int)
  DeleteAttr(Int)
  LoadSubscr
  StoreSubscr
  DeleteSubscr
  BuildTuple(Int)
  BuildList(Int)
  BuildMap(Int)
  BuildSet(Int)
  BuildSlice
  ListAppend
  ListExtend
  SetAdd
  SetUpdate
  DictSetItem
  DictUpdate
  KwListExtendFromDict
  ListToTuple
  EvalFString
  UnpackSequence(Int)
  GetIter
  ForIter(Int)
  Unary(UnaryOp)
  Binary(BinaryOp)
  Compare(CompareOp)
  Jump(Int)
  JumpIfFalse(Int)
  JumpIfTrue(Int)
  JumpIfFalseOrPop(Int)
  JumpIfTrueOrPop(Int)
  UnwindJump(Int, Int)
  SetupExcept(Int)
  SetupFinally(Int)
  PopExcept
  EnterFinally(Int)
  EndExcept
  EndFinally
  CheckExceptionMatch
  LoadException
  LoadExceptionType
  LoadExceptionTypeName
  LoadExceptionTraceback
  HasPendingException
  ClearPendingException
  Raise
  RaiseFrom
  Reraise
  AssertFail
  AssertFailNone
  Await
  MatchPattern(Int)
  MatchBind
  MatchRestore
  GenExpNew(Int, Int, Int)
  AsyncGenExpNew(Int, Int, Int)
  CallFunction(Int)
  CallFunctionKw(Int)
  CallFunctionVar
  MakeFunction(Int, Int, Int)
  MakeClass(Int, Int, Int)
  StoreAnnotation(Int)
  AugAssignName(Int, BinaryOp)
  AugAssignAttr(Int, BinaryOp)
  AugAssignSubscr(BinaryOp)
  ImportName(Int, Int)
  FromImport(Int, Int, Int)
  CheckInFunctionScope(String)
  CheckInCoroutineScope(String)
  ReturnValue
}

pub enum BinaryOp {
  Add
  Sub
  Mul
  MatMul
  Div
  FloorDiv
  Mod
  Pow
  ShiftLeft
  ShiftRight
  BitAnd
  BitXor
  BitOr
}
pub impl ToJson for BinaryOp

pub enum BoolOp {
  And
  Or
}
pub impl ToJson for BoolOp

pub struct BoundMethodValue {
  function : FunctionValue
  self : Value
}
pub impl ToJson for BoundMethodValue

pub struct ClassValue {
  name : String
  bases : Array[Value]
  dict : Array[(String, Value)]
}
pub impl ToJson for ClassValue

pub struct CompClause {
  is_async : Bool
  targets : Array[String]
  iter : Expr
}
pub impl ToJson for CompClause

pub enum CompareOp {
  Eq
  NotEq
  Lt
  Lte
  Gt
  Gte
  In
  NotIn
  Is
  IsNot
}
pub impl ToJson for CompareOp

pub struct Config {
  max_recursion : Int
  traceback_limit : Int
  track_spans : Bool
  bytecode_strict : Bool
  allow_filesystem_imports : Bool
  import_paths : Array[String]
  argv : Array[String]
  main_path : String?
}
pub fn Config::default() -> Self
pub fn Config::for_cli(Array[String], String?, Array[String]) -> Self
pub fn Config::with_bytecode_strict(Self, Bool) -> Self
pub impl ToJson for Config

pub struct ExceptHandler {
  is_star : Bool
  exc : Expr?
  name : String?
  body : Array[Stmt]
}
pub impl ToJson for ExceptHandler

pub enum Expr {
  Literal(Literal)
  Name(String)
  Tuple(Array[Expr])
  List(Array[Expr])
  ListComp(elt~ : Expr, clauses~ : Array[CompClause], filters~ : Array[Expr])
  GenExp(elt~ : Expr, clauses~ : Array[CompClause], filters~ : Array[Expr])
  Dict(Array[(Expr, Expr)])
  DictComp(key~ : Expr, value~ : Expr, clauses~ : Array[CompClause], filters~ : Array[Expr])
  Set(Array[Expr])
  SetComp(elt~ : Expr, clauses~ : Array[CompClause], filters~ : Array[Expr])
  Lambda(params~ : Array[String], defaults~ : Array[Expr], body~ : Expr)
  IfExpr(condition~ : Expr, then_expr~ : Expr, else_expr~ : Expr)
  FString(String)
  NamedExpr(name~ : String, value~ : Expr)
  Yield(Expr?)
  YieldFrom(Expr)
  Await(Expr)
  Slice(start~ : Expr?, end~ : Expr?, step~ : Expr?)
  Attribute(value~ : Expr, attr~ : String)
  Subscript(value~ : Expr, index~ : Expr)
  Call(callee~ : Expr, args~ : Array[Expr])
  Keyword(name~ : String, value~ : Expr)
  Starred(value~ : Expr)
  DoubleStarred(value~ : Expr)
  Unary(op~ : UnaryOp, expr~ : Expr)
  Binary(op~ : BinaryOp, left~ : Expr, right~ : Expr)
  BoolOp(op~ : BoolOp, values~ : Array[Expr])
  Compare(left~ : Expr, ops~ : Array[CompareOp], comparators~ : Array[Expr])
}
pub impl ToJson for Expr

pub struct FunctionValue {
  name : String
  params : Array[String]
  defaults : Array[Value]
  body : Array[Stmt]
  is_generator : Bool
  is_async : Bool
  closure : Array[(String, Value)]
}
pub impl ToJson for FunctionValue

pub(all) struct GenExpSpec {
  elt : Expr
  clauses : Array[CompClause]
  filters : Array[Expr]
}

pub struct InstanceValue {
  class : ClassValue
  dict : Array[(String, Value)]
}
pub impl ToJson for InstanceValue

pub struct Interpreter {
  config : Config
  globals : Array[(String, Value)]
  builtins : Array[(String, Value)]
  io : MockIO
}
pub fn Interpreter::eval(Self, Expr) -> Result[Value, RuntimeError]
pub fn Interpreter::eval_source(Self, String) -> Result[RunResult, RuntimeError]
pub fn Interpreter::exec(Self, Module) -> Result[RunResult, RuntimeError]
pub fn Interpreter::exec_source(Self, String) -> Result[RunResult, RuntimeError]
pub fn Interpreter::execute_test_dir(Self, String) -> TestResult raise MpythonError
pub fn Interpreter::get_global(Self, String) -> Value?
pub fn Interpreter::new() -> Self
pub fn Interpreter::new_spec() -> Self
pub fn Interpreter::set_global(Self, String, Value) -> Unit
pub fn Interpreter::set_global_str(Self, String, String) -> Unit
pub fn Interpreter::with_builtins(Array[(String, Value)], Config) -> Self
pub fn Interpreter::with_config(Config) -> Self
pub fn Interpreter::with_io(Config, MockIO) -> Self

pub enum Literal {
  None
  Bool(Bool)
  Int(@bigint.BigInt)
  Float(Double)
  Complex(Double, Double)
  Str(String)
  Bytes(Array[Int])
}
pub impl ToJson for Literal

pub struct MockIO {
  stdin : Array[String]
  stdin_pos : Ref[Int]
  stdout : StringBuilder
  stderr : StringBuilder
}
pub fn MockIO::new(Array[String]) -> Self
pub fn MockIO::read_line(Self) -> String?
pub fn MockIO::take_stderr(Self) -> String
pub fn MockIO::take_stdout(Self) -> String
pub fn MockIO::write_stderr(Self, String) -> Unit
pub fn MockIO::write_stdout(Self, String) -> Unit

pub struct Module {
  body : Array[Stmt]
}
pub impl ToJson for Module

pub(all) struct ParseError {
  kind : ParseErrorKind
  message : String
  span : Span
}
pub impl ToJson for ParseError

pub(all) enum ParseErrorKind {
  Syntax
  Indentation
  UnexpectedToken
  UnexpectedEof
}
pub impl ToJson for ParseErrorKind

pub enum Pattern {
  Wildcard
  Literal(Literal)
  Name(String)
  TypeCapture(type_name~ : String, name~ : String)
  Tuple(Array[Pattern])
}
pub impl ToJson for Pattern

pub struct RunResult {
  value : Value
  stdout : String
  stderr : String
  globals : Array[(String, Value)]
}
pub impl ToJson for RunResult

pub(all) struct RuntimeError {
  kind : RuntimeErrorKind
  message : String
  span : Span?
  traceback : Array[TracebackFrame]
  exc_type : String
  exc_args : Array[String]
  exc_value : Value?
  exc_cause : Value?
  exc_context : Value?
  exc_suppress_context : Bool
}
pub impl ToJson for RuntimeError

pub(all) enum RuntimeErrorKind {
  Name
  Type
  Attribute
  Index
  Key
  ZeroDivision
  NotImplemented
  Runtime
}
pub impl ToJson for RuntimeErrorKind

pub(all) struct Span {
  start : Int
  end : Int
  line : Int
  column : Int
}
pub impl ToJson for Span

pub enum Stmt {
  ExprStmt(Expr)
  Assign(target~ : Target, value~ : Expr)
  AnnAssign(target~ : Target, annotation~ : Expr, value~ : Expr?)
  AugAssign(target~ : Target, op~ : BinaryOp, value~ : Expr)
  TypeAlias(name~ : String, type_params~ : Array[String], value~ : Expr)
  Return(Expr?)
  Yield(Expr?)
  YieldFrom(Expr)
  If(condition~ : Expr, body~ : Array[Stmt], else_body~ : Array[Stmt])
  Match(subject~ : Expr, cases~ : Array[(Pattern, Expr?, Array[Stmt])])
  While(condition~ : Expr, body~ : Array[Stmt], else_body~ : Array[Stmt])
  For(target~ : Target, iter~ : Expr, body~ : Array[Stmt], else_body~ : Array[Stmt])
  AsyncFor(target~ : Target, iter~ : Expr, body~ : Array[Stmt], else_body~ : Array[Stmt])
  Break
  Continue
  Function(name~ : String, decorators~ : Array[Expr], type_params~ : Array[String], params~ : Array[String], defaults~ : Array[Expr], body~ : Array[Stmt], is_generator~ : Bool, is_async~ : Bool)
  Pass
  Global(Array[String])
  Nonlocal(Array[String])
  Assert(condition~ : Expr, message~ : Expr?)
  Raise(exc~ : Expr?, cause~ : Expr?)
  Del(Array[Target])
  Import(module_name~ : String, alias_name~ : String?)
  FromImport(module_name~ : String, names~ : Array[(String, String?)])
  With(context~ : Expr, target~ : String?, body~ : Array[Stmt])
  AsyncWith(context~ : Expr, target~ : String?, body~ : Array[Stmt])
  Try(body~ : Array[Stmt], handlers~ : Array[ExceptHandler], else_body~ : Array[Stmt], finally_body~ : Array[Stmt])
  Class(name~ : String, decorators~ : Array[Expr], type_params~ : Array[String], bases~ : Array[Expr], keywords~ : Array[(String, Expr)], body~ : Array[Stmt])
  WithSpan(span~ : Span, stmt~ : Stmt)
}
pub impl ToJson for Stmt

pub enum Target {
  Name(String)
  Tuple(Array[Target])
  List(Array[Target])
  Starred(Target)
  Attribute(value~ : Expr, attr~ : String)
  Subscript(value~ : Expr, index~ : Expr)
}
pub impl ToJson for Target

pub struct TestResult {
  passed : Int
  failed : Int
  errors : Array[String]
}
pub impl ToJson for TestResult

pub(all) struct TracebackFrame {
  name : String
  filename : String
  line : Int
  column : Int
}
pub impl ToJson for TracebackFrame

pub enum UnaryOp {
  Pos
  Neg
  Not
  Invert
}
pub impl ToJson for UnaryOp

pub enum Value {
  None
  Bool(Bool)
  Int(@bigint.BigInt)
  Float(Double)
  Complex(Double, Double)
  Str(String)
  Bytes(Array[Int])
  ByteArray(Array[Int])
  MemoryView(Array[Int])
  List(Array[Value])
  Tuple(Array[Value])
  Dict(Array[(Value, Value)])
  Set(Array[Value])
  Function(FunctionValue)
  Class(ClassValue)
  Instance(InstanceValue)
  BoundMethod(BoundMethodValue)
}
pub impl ToJson for Value

// Type aliases

// Traits

