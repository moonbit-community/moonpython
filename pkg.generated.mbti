// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/mpython"

// Values
pub fn format_parse_error(ParseError) -> String

pub fn format_runtime_error(RuntimeError) -> String

pub fn parse(String) -> Result[Module, ParseError]

pub fn parse_expr(String) -> Result[Expr, ParseError]

// Errors
pub suberror MpythonError {
  MpythonError(RuntimeError)
}

// Types and methods
pub enum BinaryOp {
  Add
  Sub
  Mul
  MatMul
  Div
  FloorDiv
  Mod
  Pow
  ShiftLeft
  ShiftRight
  BitAnd
  BitXor
  BitOr
}
pub impl ToJson for BinaryOp

pub enum BoolOp {
  And
  Or
}
pub impl ToJson for BoolOp

pub struct BoundMethodValue {
  function : FunctionValue
  self : Value
}
pub impl ToJson for BoundMethodValue

pub struct ClassValue {
  name : String
  bases : Array[Value]
  dict : Array[(String, Value)]
}
pub impl ToJson for ClassValue

pub enum CompareOp {
  Eq
  NotEq
  Lt
  Lte
  Gt
  Gte
  In
  NotIn
  Is
  IsNot
}
pub impl ToJson for CompareOp

pub struct Config {
  max_recursion : Int
  traceback_limit : Int
  track_spans : Bool
}
pub fn Config::default() -> Self
pub impl ToJson for Config

pub enum Expr {
  Literal(Literal)
  Name(String)
  Tuple(Array[Expr])
  List(Array[Expr])
  ListComp(elt~ : Expr, clauses~ : Array[(Array[String], Expr)], filters~ : Array[Expr])
  GenExp(elt~ : Expr, clauses~ : Array[(Array[String], Expr)], filters~ : Array[Expr])
  Dict(Array[(Expr, Expr)])
  DictComp(key~ : Expr, value~ : Expr, clauses~ : Array[(Array[String], Expr)], filters~ : Array[Expr])
  Set(Array[Expr])
  SetComp(elt~ : Expr, clauses~ : Array[(Array[String], Expr)], filters~ : Array[Expr])
  Lambda(params~ : Array[String], defaults~ : Array[Expr], body~ : Expr)
  IfExpr(condition~ : Expr, then_expr~ : Expr, else_expr~ : Expr)
  FString(String)
  NamedExpr(name~ : String, value~ : Expr)
  Yield(Expr?)
  YieldFrom(Expr)
  Await(Expr)
  Slice(start~ : Expr?, end~ : Expr?, step~ : Expr?)
  Attribute(value~ : Expr, attr~ : String)
  Subscript(value~ : Expr, index~ : Expr)
  Call(callee~ : Expr, args~ : Array[Expr])
  Keyword(name~ : String, value~ : Expr)
  Starred(value~ : Expr)
  DoubleStarred(value~ : Expr)
  Unary(op~ : UnaryOp, expr~ : Expr)
  Binary(op~ : BinaryOp, left~ : Expr, right~ : Expr)
  BoolOp(op~ : BoolOp, values~ : Array[Expr])
  Compare(left~ : Expr, ops~ : Array[CompareOp], comparators~ : Array[Expr])
}
pub impl ToJson for Expr

pub struct FunctionValue {
  name : String
  params : Array[String]
  defaults : Array[Value]
  body : Array[Stmt]
  is_generator : Bool
  is_async : Bool
  closure : Array[(String, Value)]
}
pub impl ToJson for FunctionValue

pub struct InstanceValue {
  class : ClassValue
  dict : Array[(String, Value)]
}
pub impl ToJson for InstanceValue

pub struct Interpreter {
  config : Config
  globals : Array[(String, Value)]
  builtins : Array[(String, Value)]
  io : MockIO
}
pub fn Interpreter::eval(Self, Expr) -> Result[Value, RuntimeError]
pub fn Interpreter::eval_source(Self, String) -> Result[RunResult, RuntimeError]
pub fn Interpreter::exec(Self, Module) -> Result[RunResult, RuntimeError]
pub fn Interpreter::exec_source(Self, String) -> Result[RunResult, RuntimeError]
pub fn Interpreter::execute_test_dir(Self, String) -> TestResult raise MpythonError
pub fn Interpreter::get_global(Self, String) -> Value?
pub fn Interpreter::new() -> Self
pub fn Interpreter::new_spec() -> Self
pub fn Interpreter::set_global(Self, String, Value) -> Unit
pub fn Interpreter::with_builtins(Array[(String, Value)], Config) -> Self
pub fn Interpreter::with_config(Config) -> Self
pub fn Interpreter::with_io(Config, MockIO) -> Self

pub enum Literal {
  None
  Bool(Bool)
  Int(Int64)
  Float(Double)
  Str(String)
}
pub impl ToJson for Literal

pub struct MockIO {
  stdin : Array[String]
  stdin_pos : Ref[Int]
  stdout : StringBuilder
  stderr : StringBuilder
}
pub fn MockIO::new(Array[String]) -> Self
pub fn MockIO::read_line(Self) -> String?
pub fn MockIO::take_stderr(Self) -> String
pub fn MockIO::take_stdout(Self) -> String
pub fn MockIO::write_stderr(Self, String) -> Unit
pub fn MockIO::write_stdout(Self, String) -> Unit

pub struct Module {
  body : Array[Stmt]
}
pub impl ToJson for Module

pub(all) struct ParseError {
  kind : ParseErrorKind
  message : String
  span : Span
}
pub impl ToJson for ParseError

pub(all) enum ParseErrorKind {
  Syntax
  Indentation
  UnexpectedToken
  UnexpectedEof
}
pub impl ToJson for ParseErrorKind

pub enum Pattern {
  Wildcard
  Literal(Literal)
  Name(String)
  Tuple(Array[Pattern])
}
pub impl ToJson for Pattern

pub struct RunResult {
  value : Value
  stdout : String
  stderr : String
  globals : Array[(String, Value)]
}
pub impl ToJson for RunResult

pub(all) struct RuntimeError {
  kind : RuntimeErrorKind
  message : String
  span : Span?
  exc_type : String
  exc_args : Array[String]
  exc_value : Value?
  exc_cause : Value?
  exc_context : Value?
  exc_suppress_context : Bool
}
pub impl ToJson for RuntimeError

pub(all) enum RuntimeErrorKind {
  Name
  Type
  Attribute
  Index
  Key
  ZeroDivision
  NotImplemented
  Runtime
}
pub impl ToJson for RuntimeErrorKind

pub(all) struct Span {
  start : Int
  end : Int
  line : Int
  column : Int
}
pub impl ToJson for Span

pub enum Stmt {
  ExprStmt(Expr)
  Assign(target~ : Target, value~ : Expr)
  AugAssign(target~ : Target, op~ : BinaryOp, value~ : Expr)
  Return(Expr?)
  Yield(Expr?)
  YieldFrom(Expr)
  If(condition~ : Expr, body~ : Array[Stmt], else_body~ : Array[Stmt])
  Match(subject~ : Expr, cases~ : Array[(Pattern, Expr?, Array[Stmt])])
  While(condition~ : Expr, body~ : Array[Stmt], else_body~ : Array[Stmt])
  For(target~ : Target, iter~ : Expr, body~ : Array[Stmt], else_body~ : Array[Stmt])
  Break
  Continue
  Function(name~ : String, decorators~ : Array[Expr], params~ : Array[String], defaults~ : Array[Expr], body~ : Array[Stmt], is_generator~ : Bool, is_async~ : Bool)
  Pass
  Global(Array[String])
  Nonlocal(Array[String])
  Assert(condition~ : Expr, message~ : Expr?)
  Raise(exc~ : Expr?, cause~ : Expr?)
  Del(Array[Target])
  Import(module~ : String, alias~ : String?)
  FromImport(module~ : String, names~ : Array[(String, String?)])
  With(context~ : Expr, target~ : String?, body~ : Array[Stmt])
  Try(body~ : Array[Stmt], handlers~ : Array[(Expr?, String?, Array[Stmt])], else_body~ : Array[Stmt], finally_body~ : Array[Stmt])
  Class(name~ : String, decorators~ : Array[Expr], bases~ : Array[Expr], keywords~ : Array[(String, Expr)], body~ : Array[Stmt])
}
pub impl ToJson for Stmt

pub enum Target {
  Name(String)
  Tuple(Array[Target])
  List(Array[Target])
  Attribute(value~ : Expr, attr~ : String)
  Subscript(value~ : Expr, index~ : Expr)
}
pub impl ToJson for Target

pub struct TestResult {
  passed : Int
  failed : Int
  errors : Array[String]
}
pub impl ToJson for TestResult

pub enum UnaryOp {
  Pos
  Neg
  Not
  Invert
}
pub impl ToJson for UnaryOp

pub enum Value {
  None
  Bool(Bool)
  Int(Int64)
  Float(Double)
  Str(String)
  List(Array[Value])
  Tuple(Array[Value])
  Dict(Array[(Value, Value)])
  Set(Array[Value])
  Function(FunctionValue)
  Class(ClassValue)
  Instance(InstanceValue)
  BoundMethod(BoundMethodValue)
}
pub impl ToJson for Value

// Type aliases

// Traits

