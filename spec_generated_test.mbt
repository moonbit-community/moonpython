// ============================================================================
// AUTO-GENERATED FILE - DO NOT MODIFY MANUALLY
// Generated by: scripts/generate_spec_tests.py
// Regenerate with: python3.12 scripts/generate_spec_tests.py
// ============================================================================

///|
/// MPython spec-driven tests generated from CPython evaluation

fn assert_run(result : Result[RunResult, RuntimeError], expected : String) -> Unit raise {
  let json = @json.parse(expected) catch { _ => fail("invalid json") }
  match json {
    Array(items) => {
      if items.length() < 2 {
        fail("invalid expectation")
      }
      let tag = items[0]
      match tag {
        String(tag) =>
          if tag == "ok" {
            if items.length() != 4 {
              fail("invalid expectation")
            }
            let payload = items[1]
            let stdout = items[2]
            let stderr = items[3]
            match result {
              Ok(run) => {
                @json.json_inspect(run.value, content=payload)
                match stdout {
                  String(text) => inspect(run.stdout, content=text)
                  _ => fail("invalid expectation")
                }
                match stderr {
                  String(text) => inspect(run.stderr, content=text)
                  _ => fail("invalid expectation")
                }
              }
              Err(err) => fail(format_runtime_error(err))
            }
          } else if tag == "err" {
            if items.length() != 2 {
              fail("invalid expectation")
            }
            let payload = items[1]
            match result {
              Ok(_) => fail("expected error")
              Err(err) =>
                match payload {
                  String(message) =>
                    inspect(format_runtime_error(err), content=message)
                  _ => fail("invalid error payload")
                }
            }
          } else {
            fail("invalid expectation")
          }
        _ => fail("invalid expectation")
      }
    }
    _ => fail("invalid expectation")
  }
}

///|
test "generated/expr/0001" {
  let source =
    #|'This string will not include \
    #|backslashes or newline characters.'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"Str\", \"This string will not include backslashes or newline characters.\"], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0002" {
  let source =
    #|3.14
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"Float\", 3.14], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0003" {
  let source =
    #|1/2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"Float\", 0.5], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0004" {
  let source =
    #|"abc,def"
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"Str\", \"abc,def\"], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0005" {
  let source =
    #|"1","abc def","abc"
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"Tuple\", [[\"Str\", \"1\"], [\"Str\", \"abc def\"], [\"Str\", \"abc\"]]], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0006" {
  let source =
    #|"abc\,def"
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"Str\", \"abc\\\\,def\"], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0007" {
  let source =
    #|1 if 1else 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"Int\", \"1\"], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0008" {
  let source =
    #|1 if 0else 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"Int\", \"0\"], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0009" {
  let source =
    #|1, 0 or 1
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"Tuple\", [[\"Int\", \"1\"], [\"Int\", \"1\"]]], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0010" {
  let source =
    #|[x := i for i in range(3) if (x := i) or not x]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"List\", [[\"Int\", \"0\"], [\"Int\", \"1\"], [\"Int\", \"2\"]]], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0011" {
  let source =
    #|[x for i in range(3) if (x := i) or not x]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"List\", [[\"Int\", \"0\"], [\"Int\", \"1\"], [\"Int\", \"2\"]]], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0012" {
  let source =
    #|{x for x in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"Set\", [[\"Int\", \"0\"], [\"Int\", \"1\"], [\"Int\", \"2\"], [\"Int\", \"3\"], [\"Int\", \"4\"]]], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0013" {
  let source =
    #|{x: x*x for x in range(10)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"Dict\", [[[\"Int\", \"0\"], [\"Int\", \"0\"]], [[\"Int\", \"1\"], [\"Int\", \"1\"]], [[\"Int\", \"2\"], [\"Int\", \"4\"]], [[\"Int\", \"3\"], [\"Int\", \"9\"]], [[\"Int\", \"4\"], [\"Int\", \"16\"]], [[\"Int\", \"5\"], [\"Int\", \"25\"]], [[\"Int\", \"6\"], [\"Int\", \"36\"]], [[\"Int\", \"7\"], [\"Int\", \"49\"]], [[\"Int\", \"8\"], [\"Int\", \"64\"]], [[\"Int\", \"9\"], [\"Int\", \"81\"]]]], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0014" {
  let source =
    #|"""almost end in double "quote"."""
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"ok\", [\"Str\", \"almost end in double \\\"quote\\\".\"], \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0015" {
  let source =
    #|re.compile("[A-Za-z_]"       # letter or underscore
    #|           "[A-Za-z0-9_]*"   # letter, digit or underscore
    #|          )
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 're' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0016" {
  let source =
    #|f"abc{a # This is a comment }"
    #|+ 3}"
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0017" {
  let source =
    #|Test listing interpreters for a channel with no associations.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0018" {
  let source =
    #|Test listing interpreters for a channel with many associations.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0019" {
  let source =
    #|Test listing channel interpreters with a destroyed interpreter.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0020" {
  let source =
    #|Test listing channel interpreters with a released channel.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0021" {
  let source =
    #|Test listing channel interpreters with a closed channel.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0022" {
  let source =
    #|Test listing channel interpreters with a channel's send end closed.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0023" {
  let source =
    #|non-blocking with timeout
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0024" {
  let source =
    #|, b'X' if result.closed else b'', blocking=False)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0025" {
  let source =
    #|%s != %s (%s for %s; set to %s, using %s)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0026" {
  let source =
    #|Compare calculation against known value, if available
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0027" {
  let source =
    #|locale support broken for OS X < 10.4
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0028" {
  let source =
    #|<not able to determine>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0029" {
  let source =
    #|using eval('3.14') failed for %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0030" {
  let source =
    #|using float('3.14') failed for %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0031" {
  let source =
    #|Unit tests for abc.py.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0032" {
  let source =
    #|class C without an implementation for abstract methods 'method_one', 'method_two'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0033" {
  let source =
    #|class A without an implementation for abstract methods 'bar', 'foo'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0034" {
  let source =
    #|Unit tests for numbers.py.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0035" {
  let source =
    #|write\(\) argument must be str, not 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0036" {
  let source =
    #|write\(\) argument must be bytes-like, not 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0037" {
  let source =
    #|Asynchronously yield 1, then 2.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0038" {
  let source =
    #|yield from.*inside async
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0039" {
  let source =
    #|return.*value.*async gen
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0040" {
  let source =
    #|anext\(\): asynchronous generator is already running
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0041" {
  let source =
    #|athrow\(\): asynchronous generator is already running
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0042" {
  let source =
    #|this is a generator-based coroutine
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0043" {
  let source =
    #|x, b += 3
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0044" {
  let source =
    #|Blocks inheritance, and fallback to __add__
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0045" {
  let source =
    #|Test that hexlify and b2a_hex are binary versions of bytes.hex.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0046" {
  let source =
    #|binascii.a2b_qp(**{1:1}) didn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0047" {
  let source =
    #|Tests for binary operators on subtypes of built-in types.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0048" {
  let source =
    #|Test whether an object is an instance of int.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0049" {
  let source =
    #|Test whether an object is an instance of a built-in numeric type.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0050" {
  let source =
    #|Test whether an object is an instance of the Rat class.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0051" {
  let source =
    #|Unit tests for Rat class and its support utilities.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0052" {
  let source =
    #|Base class for classes with operation logging.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0053" {
  let source =
    #|Subclass of SupEq that can test equality, but not non-equality
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0054" {
  let source =
    #|Independent class that can test equality, but not non-equality
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0055" {
  let source =
    #|Accessor function for read-only 'num' attribute of Rat.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0056" {
  let source =
    #|Accessor function for read-only 'den' attribute of Rat.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0057" {
  let source =
    #|Add two Rats, or a Rat and a number.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0058" {
  let source =
    #|Subtract two Rats, or a Rat and a number.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0059" {
  let source =
    #|Subtract two Rats, or a Rat and a number (reversed args).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0060" {
  let source =
    #|Multiply two Rats, or a Rat and a number.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0061" {
  let source =
    #|Divide two Rats, or a Rat and a number.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0062" {
  let source =
    #|Divide two Rats, or a Rat and a number (reversed args).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0063" {
  let source =
    #|Divide two Rats, returning quotient and remainder.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0064" {
  let source =
    #|Divide two Rats, returning quotient and remainder (reversed args).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0065" {
  let source =
    #|Compare two Rats for equality.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0066" {
  let source =
    #|Rat(1, 0) didn't raise ZeroDivisionError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0067" {
  let source =
    #|Rat(%r) didn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0068" {
  let source =
    #|Rat(1, %r) didn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0069" {
  let source =
    #|Dummy sequence class defining __len__ but not __getitem__.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0070" {
  let source =
    #|Dummy sequence class defining __getitem__ but not __len__.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0071" {
  let source =
    #|invalid keyword argument for print\(\)$
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0072" {
  let source =
    #|invalid keyword argument for round\(\)$
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0073" {
  let source =
    #|^'module' object is not callable\. Did you mean: 'mod\.mod\(\.\.\.\)'\?$
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0074" {
  let source =
    #|A.method_two_args() got multiple values for argument 'x'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0075" {
  let source =
    #|def f(
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0076" {
  let source =
    #|) : return a
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0077" {
  let source =
    #|spam, spam, spam and ham
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'spam' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0078" {
  let source =
    #|'B' object attribute 'y' is read-only
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0079" {
  let source =
    #|attribute error for I.__init__ got masked
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0080" {
  let source =
    #|attribute error for A().a got masked: %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0081" {
  let source =
    #|{!r} and {!r} are not sufficiently close
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0082" {
  let source =
    #|cmath.pi is {}; should be {}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0083" {
  let source =
    #|cmath.e is {}; should be {}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0084" {
  let source =
    #|ValueError not raised in test {}: {}(complex({!r}, {!r}))
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0085" {
  let source =
    #|OverflowError not raised in test {}: {}(complex({!r}, {!r}))
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0086" {
  let source =
    #|x is x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0087" {
  let source =
    #|x in x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0088" {
  let source =
    #|lambda:42
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0089" {
  let source =
    #|String %r is not interned
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'String' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0090" {
  let source =
    #|String %r is interned
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'String' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0091" {
  let source =
    #|def f():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0092" {
  let source =
    #|Error in sys.excepthook:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0093" {
  let source =
    #|File "<console>", line 1, in <module>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0094" {
  let source =
    #|File "<console>", line 2, in f
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0095" {
  let source =
    #|'ascii' codec can't encode character '\xfc' in position 1: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0096" {
  let source =
    #|'ascii' codec can't encode characters in position 1-3: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0097" {
  let source =
    #|'ascii' codec can't encode character '\xfc' in position 0: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0098" {
  let source =
    #|'ascii' codec can't encode character '\u0100' in position 0: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0099" {
  let source =
    #|'ascii' codec can't encode character '\uffff' in position 0: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0100" {
  let source =
    #|'ascii' codec can't encode character '\U00010000' in position 0: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0101" {
  let source =
    #|'ascii' codec can't decode byte 0xfc in position 1: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0102" {
  let source =
    #|'ascii' codec can't decode bytes in position 1-2: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0103" {
  let source =
    #|can't translate character '\xfc' in position 1: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0104" {
  let source =
    #|can't translate character '\u0100' in position 1: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0105" {
  let source =
    #|can't translate character '\uffff' in position 1: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0106" {
  let source =
    #|can't translate character '\U00010000' in position 1: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0107" {
  let source =
    #|can't translate characters in position 1-2: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0108" {
  let source =
    #|abc<def>ghi
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0109" {
  let source =
    #|if 1:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0110" {
  let source =
    #|def x():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0111" {
  let source =
    #|lambda z: \
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0112" {
  let source =
    #|from a import (
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0113" {
  let source =
    #|from a import (b
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0114" {
  let source =
    #|from a import (b,
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0115" {
  let source =
    #|from a import (b,c
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0116" {
  let source =
    #|from a import (b,c,
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0117" {
  let source =
    #|def a(
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0118" {
  let source =
    #|def a(b
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0119" {
  let source =
    #|def a(b,
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0120" {
  let source =
    #|def a(b,c
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0121" {
  let source =
    #|def a(b,c,
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0122" {
  let source =
    #|while a:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0123" {
  let source =
    #|for a in b:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0124" {
  let source =
    #|try:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0125" {
  let source =
    #|with a:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0126" {
  let source =
    #|with a as b:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0127" {
  let source =
    #|class a:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0128" {
  let source =
    #|class a(
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0129" {
  let source =
    #|class a(b
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0130" {
  let source =
    #|class a(b,
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0131" {
  let source =
    #|class a():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0132" {
  let source =
    #|[x for
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0133" {
  let source =
    #|[x for x in
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0134" {
  let source =
    #|[x for x in (
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0135" {
  let source =
    #|(x for
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0136" {
  let source =
    #|(x for x in
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0137" {
  let source =
    #|(x for x in (
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0138" {
  let source =
    #|lambda z:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0139" {
  let source =
    #|if (a == 1 and b = 2): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0140" {
  let source =
    #|del (1,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0141" {
  let source =
    #|del [1]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0142" {
  let source =
    #|[i for i in range(10)] = (1, 2, 3)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0143" {
  let source =
    #|raise = 4
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0144" {
  let source =
    #|def a-b
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0145" {
  let source =
    #|a await raise b?+1
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0146" {
  let source =
    #|Unit tests for collections.py.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0147" {
  let source =
    #|Tests for changes for issue #16613.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0148" {
  let source =
    #|Docstrings are omitted with -O2 and above
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0149" {
  let source =
    #|docstring for Point.x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0150" {
  let source =
    #|docstring for Vector.x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0151" {
  let source =
    #|_tuplegetter(0, 'Alias for field number 0')
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name '_tuplegetter' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0152" {
  let source =
    #|_tuplegetter(1, 'Alias for field number 1')
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name '_tuplegetter' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0153" {
  let source =
    #|Right side not called for %s.%s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0154" {
  let source =
    #|Test equality and order comparisons.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0155" {
  let source =
    #|Test equality and order comparisons for some simple cases.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0156" {
  let source =
    #|object.__ne__() should not invoke reflected __eq__()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0157" {
  let source =
    #|No default delegation between operations except __ne__()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0158" {
  let source =
    #|Compare same-class instances with comparison methods.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0159" {
  let source =
    #|Compare different-class instances with comparison methods.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0160" {
  let source =
    #|Compare instances of str and a subclass.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0161" {
  let source =
    #|Compare list, tuple, and range.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0162" {
  let source =
    #|Compare bytes and bytearray.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0163" {
  let source =
    #|Compare set and frozenset.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0164" {
  let source =
    #|Return true iff floats x and y "are close".
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0165" {
  let source =
    #|Return true iff complexes x and y "are close".
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0166" {
  let source =
    #|Compute complex z=x*y, and check that z/x==y and z/y==x.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0167" {
  let source =
    #|argument must be a string or a number, not dict
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0168" {
  let source =
    #|argument must be a string or a number, not NoneType
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0169" {
  let source =
    #|argument 'real' must be a real number, not dict
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0170" {
  let source =
    #|argument 'real' must be a real number, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0171" {
  let source =
    #|argument 'imag' must be a real number, not dict
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0172" {
  let source =
    #|argument 'imag' must be a real number, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0173" {
  let source =
    #|Test usage of __complex__() when inheriting from 'complex'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0174" {
  let source =
    #|Test usage of __complex__() with a __new__() method
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0175" {
  let source =
    #|should fail 0.0 to negative or complex power
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0176" {
  let source =
    #|argument 'real' must be a real number, not complex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0177" {
  let source =
    #|argument 'real' must be a real number, not .*ComplexSubclass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0178" {
  let source =
    #|argument 'real' must be a real number, not .*WithComplex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0179" {
  let source =
    #|argument 'imag' must be a real number, not complex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0180" {
  let source =
    #|argument 'imag' must be a real number, not .*ComplexSubclass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0181" {
  let source =
    #|argument 'imag' must be a real number, not .*WithComplex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0182" {
  let source =
    #|_testinternalcapi.hamt() not available
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0183" {
  let source =
    #|Unit tests for the copy module.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0184" {
  let source =
    #|asyncio does not work under Emscripten/WASI yet.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0185" {
  let source =
    #|This would crash the interpreter in 3.11a2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0186" {
  let source =
    #|[[i async for i in a] for a in elts]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0187" {
  let source =
    #|cannot 'yield from' a coroutine object in a non-coroutine generator
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0188" {
  let source =
    #|__await__.*must return an iterator, not
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0189" {
  let source =
    #|__await__\(\) must return an iterator, not coroutine
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0190" {
  let source =
    #|'async with' received an object from __aenter__ that does not implement __await__: int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0191" {
  let source =
    #|'async with' received an object from __aexit__ that does not implement __await__: int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0192" {
  let source =
    #|async for' requires an object.*__aiter__.*tuple
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0193" {
  let source =
    #|async for' received an invalid object.*__anext__.*tuple
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0194" {
  let source =
    #|__await__.*must return an iterator, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0195" {
  let source =
    #|def i{i}(): return {i}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0196" {
  let source =
    #|, in a1
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0197" {
  let source =
    #|, in a2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0198" {
  let source =
    #|Make sure __main__ module exists (and clean up after).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0199" {
  let source =
    #|Create the module and add to sys.modules, then remove it after.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0200" {
  let source =
    #|with newline=''
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0201" {
  let source =
    #|More to document existing (unexpected?) behavior than anything else.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0202" {
  let source =
    #|1,2,3,"""I see,"" said the blind man","as he picked up his hammer and saw"
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0203" {
  let source =
    #|abc\,def
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0204" {
  let source =
    #|2147483648,43.0e12,17,abc,def
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0205" {
  let source =
    #|147483648,43.0e2,17,abc,def
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0206" {
  let source =
    #|47483648,43.0,170,abc,def
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0207" {
  let source =
    #|"quotechar" must be a unicode character or None, not a string of length 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0208" {
  let source =
    #|"quotechar" must be a unicode character or None, not a string of length 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0209" {
  let source =
    #|"quotechar" must be a unicode character or None, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0210" {
  let source =
    #|"delimiter" must be a unicode character, not a string of length 3
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0211" {
  let source =
    #|"delimiter" must be a unicode character, not a string of length 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0212" {
  let source =
    #|"delimiter" must be a unicode character, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0213" {
  let source =
    #|"delimiter" must be a unicode character, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0214" {
  let source =
    #|"delimiter" must be a unicode character, not NoneType
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0215" {
  let source =
    #|"escapechar" must be a unicode character or None, not a string of length 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0216" {
  let source =
    #|"escapechar" must be a unicode character or None, not a string of length 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0217" {
  let source =
    #|"escapechar" must be a unicode character or None, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0218" {
  let source =
    #|"escapechar" must be a unicode character or None, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0219" {
  let source =
    #|"lineterminator" must be a string, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0220" {
  let source =
    #|"lineterminator" must be a string, not NoneType
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0221" {
  let source =
    #|Key ordering: some key permutations not collected (expected 120)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0222" {
  let source =
    #|'__version__' is deprecated and slated for removal in Python 3.20
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0223" {
  let source =
    #|abc,def
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0224" {
  let source =
    #|args[1] is not None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'args' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0225" {
  let source =
    #|Unit tests for collections.defaultdict.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0226" {
  let source =
    #|defaultdict(<class 'int'>, {12: 42})
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0227" {
  let source =
    #|d2[15] didn't raise KeyError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0228" {
  let source =
    #|Sets default __doc__ and simplifies repr() output.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0229" {
  let source =
    #|Cannot create a consistent method resolution order (MRO) for bases 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0230" {
  let source =
    #|Utility method to verify if two objects are copies of each others.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0231" {
  let source =
    #|Deep reentrancy must not over-decref old_mro.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0232" {
  let source =
    #|descriptor 'classmeth' for type 'xxsubtype.spamlist' needs a type, not a 'xxsubtype.spamlist' as arg 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0233" {
  let source =
    #|x has to be an instance of a class inheriting from Base.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0234" {
  let source =
    #|unsupported operand type(s) for **=
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0235" {
  let source =
    #|unsupported operand type(s) for **
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0236" {
  let source =
    #|expected 1 or 2 arguments, got 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0237" {
  let source =
    #|expected 1 or 2 arguments, got 3
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0238" {
  let source =
    #|<bound method .*Foo\.method of <class '.*Foo'>>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0239" {
  let source =
    #|mykey2=from Base2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0240" {
  let source =
    #|This class copies object using pickle.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0241" {
  let source =
    #|A class with __getstate__ and __setstate__ implemented.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0242" {
  let source =
    #|A subclass of a class with slots.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0243" {
  let source =
    #|A subclass with an extra slot.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0244" {
  let source =
    #|The state of this class is copyable via its instance dict.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0245" {
  let source =
    #|calling object w/o call method should raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0246" {
  let source =
    #|object() should not allow setting a foo attribute
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0247" {
  let source =
    #|[None] slots not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0248" {
  let source =
    #|['foo bar'] slots not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0249" {
  let source =
    #|['foo\0bar'] slots not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0250" {
  let source =
    #|['1'] slots not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0251" {
  let source =
    #|[''] slots not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0252" {
  let source =
    #|[chr(128)] slots not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0253" {
  let source =
    #|inheritance from non-type should be illegal
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0254" {
  let source =
    #|devious mro() return not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0255" {
  let source =
    #|non-class mro() return not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0256" {
  let source =
    #|non-sequence mro() return not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0257" {
  let source =
    #|no TypeError from dict(incomplete mapping)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0258" {
  let source =
    #|invalid del() didn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0259" {
  let source =
    #|'' + 5 doesn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0260" {
  let source =
    #|''.split('') doesn't raise ValueError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0261" {
  let source =
    #|''.join([0]) doesn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0262" {
  let source =
    #|''.rindex('5') doesn't raise ValueError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0263" {
  let source =
    #|'%(n)s' % None doesn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0264" {
  let source =
    #|'%(n' % {} '' doesn't raise ValueError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0265" {
  let source =
    #|'%*s' % ('abc') doesn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0266" {
  let source =
    #|'%*.*s' % ('abc', 5) doesn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0267" {
  let source =
    #|'%s' % (1, 2) doesn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0268" {
  let source =
    #|'%' % None doesn't raise ValueError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0269" {
  let source =
    #|did not test __init__() for None return
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0270" {
  let source =
    #|assigning %r as __class__ for %r silently failed
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0271" {
  let source =
    #|{!r} is not a copy of {!r}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0272" {
  let source =
    #|expected AttributeError from trying to set readonly %r attr on a property
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0273" {
  let source =
    #|no TypeError from dict(%r)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0274" {
  let source =
    #|no ValueError from dict(%r)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0275" {
  let source =
    #|expected TypeError from bogus keyword argument to %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0276" {
  let source =
    #|shouldn't allow del %r.__class__
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0277" {
  let source =
    #|shouldn't allow del %r.__dict__
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0278" {
  let source =
    #|__getattr__ called with {0}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0279" {
  let source =
    #|__getattribute__ called with {0}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0280" {
  let source =
    #|split table must be combined when del d[k]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0281" {
  let source =
    #|dict.update(other) must preserve order in other.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0282" {
  let source =
    #|{x: y for y, x in ((1, 2), (3, 4))} = 5
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0283" {
  let source =
    #|{x: y for y, x in ((1, 2), (3, 4))} += 5
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0284" {
  let source =
    #|This is an XML-RPC server's documentation, but the server can be used by POSTing to /RPC2. Try self.add, too.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0285" {
  let source =
    #|lambda: len([])
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0286" {
  let source =
    #|foo()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'foo' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0287" {
  let source =
    #|lambda: 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0288" {
  let source =
    #|__doc__ is already present, __slots__ will have no effect
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0289" {
  let source =
    #|non-callable __reversed__ didn't raise!
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0290" {
  let source =
    #|no %s attr in errno.errorcode
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0291" {
  let source =
    #|'break', 'continue' and 'return' cannot appear in an except\* block
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0292" {
  let source =
    #|split must return a tuple, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0293" {
  let source =
    #|split must return a 2-tuple, got tuple of size 1
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0294" {
  let source =
    #|argument 1 must be str, not 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0295" {
  let source =
    #|Item [0-9]+ of second argument \(exceptions\) is not an exception
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0296" {
  let source =
    #|expect instance, not type
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0297" {
  let source =
    #|.*MySeq\.__repr__\(\) must return a str, not NoneType
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0298" {
  let source =
    #|context and cause for ValueError(1)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0299" {
  let source =
    #|context for ValueError(2)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0300" {
  let source =
    #|Tests for object finalization semantics, as outlined in PEP 442.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0301" {
  let source =
    #|Test finalization of objects with a tp_del.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0302" {
  let source =
    #|Check the object is sane (non-broken).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0303" {
  let source =
    #|Resurrect self by storing self in a class-wide list.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0304" {
  let source =
    #|from __future__ import barry_as_FLUFL;2 {0} 3
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0305" {
  let source =
    #|from .__future__ import barry_as_FLUFL;2 {0} 3
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0306" {
  let source =
    #|with Barry as BDFL, use '<>' instead of '!='
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0307" {
  let source =
    #|f'xx{value:{bad_format_spec}}yy'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'value' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0308" {
  let source =
    #|%d format: a real number is required, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0309" {
  let source =
    #|%d format: a real number is required, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0310" {
  let source =
    #|%x format: an integer is required, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0311" {
  let source =
    #|%x format: an integer is required, not float
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0312" {
  let source =
    #|%i format: a real number is required, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0313" {
  let source =
    #|%i format: a real number is required, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0314" {
  let source =
    #|must be real number, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0315" {
  let source =
    #|%c arg not in range(0x110000)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0316" {
  let source =
    #|%c requires an int or a unicode character, not float
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0317" {
  let source =
    #|%c requires an int or a unicode character, not a string of length 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0318" {
  let source =
    #|%c requires an int or a unicode character, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0319" {
  let source =
    #|float argument required, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0320" {
  let source =
    #|float argument required, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0321" {
  let source =
    #|%c arg not in range(256)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0322" {
  let source =
    #|%c requires an integer in range(256) or a single byte, not a bytes object of length 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0323" {
  let source =
    #|%c requires an integer in range(256) or a single byte, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0324" {
  let source =
    #|%c requires an integer in range(256) or a single byte, not float
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0325" {
  let source =
    #|%b requires a bytes-like object, or an object that implements __bytes__, not 'str'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0326" {
  let source =
    #|Cannot specify ',' with ','.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0327" {
  let source =
    #|Cannot specify '_' with '_'.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0328" {
  let source =
    #|Cannot specify both ',' and '_'.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0329" {
  let source =
    #|Invalid format specifier '%' for object of type 'str'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0330" {
  let source =
    #|Negative zero coercion (z) not allowed
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0331" {
  let source =
    #|did not get expected exception: %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0332" {
  let source =
    #|overflow (this is fine)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'overflow' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0333" {
  let source =
    #|Tests for frame.clear().
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0334" {
  let source =
    #|Tests for repr(frame).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0335" {
  let source =
    #|Test that FrameLocalsProxy behaves like a Mapping (with exceptions)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0336" {
  let source =
    #|Clear all frames in a traceback.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0337" {
  let source =
    #|Unlike a mapping: del proxy[key] fails
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0338" {
  let source =
    #|A weakref'able class.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0339" {
  let source =
    #|Try to find globals and locals as this frame is being cleared.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0340" {
  let source =
    #|Run SneakyDel.__del__ as this frame is popped.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0341" {
  let source =
    #|Basic test of the frozen module (source is in Python/frozen.c).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0342" {
  let source =
    #|set attribute on function implementations, should show up in next dir
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0343" {
  let source =
    #|global_function.<locals>.<lambda>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0344" {
  let source =
    #|__defaults__ does not update; deleting it does not remove requirement
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0345" {
  let source =
    #|shouldn't be able to del %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0346" {
  let source =
    #|thread sanitizer crashes in __tsan::FuncEntry
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0347" {
  let source =
    #|. Use either `@register(some_class)` or plain `@register` on an annotated function.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0348" {
  let source =
    #|Disallow this case because decorated function a would not be cached.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0349" {
  let source =
    #|Reusing a cached_property on different classes under the same name is OK.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0350" {
  let source =
    #|Caching still works for a subclass defining __set__.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0351" {
  let source =
    #|missing positional arguments in 'partial' call; expected at least 1, got 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0352" {
  let source =
    #|Invalid annotation for 'arg'.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0353" {
  let source =
    #|typing.Iterable[str] is not a class.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0354" {
  let source =
    #|int | typing.Iterable[str] not all arguments are classes.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0355" {
  let source =
    #|never called, slots not supported
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0356" {
  let source =
    #|Ambiguous dispatch: <class 'collections.abc.Container'> or <class 'collections.abc.Iterable'>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0357" {
  let source =
    #|Ambiguous dispatch: <class 'collections.abc.Iterable'> or <class 'collections.abc.Container'>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0358" {
  let source =
    #|Ambiguous dispatch: <class 'collections.abc.Container'> or <class 'collections.abc.Sized'>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0359" {
  let source =
    #|Ambiguous dispatch: <class 'collections.abc.Sized'> or <class 'collections.abc.Container'>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0360" {
  let source =
    #|I annotated with a non-type
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0361" {
  let source =
    #|The '__dict__' attribute on 'MyMeta' instance does not support item assignment for caching 'prop' property.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0362" {
  let source =
    #|Cannot assign the same cached_property to two different names ('a' and 'b').
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0363" {
  let source =
    #|built with -NDEBUG
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0364" {
  let source =
    #|A generator that releases the GIL when closed or dealloc'ed.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0365" {
  let source =
    #|Exercise make_nested() in a loop.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0366" {
  let source =
    #|didn't find obj in garbage (finalizer)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0367" {
  let source =
    #|def test():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0368" {
  let source =
    #|__cause__, __context__, or __suppress_context__ were not properly set
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0369" {
  let source =
    #|'.*' object is not iterable
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0370" {
  let source =
    #|else remove_from_successors() pruning flawed
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0371" {
  let source =
    #|Tests for C-implemented GenericAlias.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0372" {
  let source =
    #|Test an in-build-tree layout on Windows.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0373" {
  let source =
    #|Test an in-build-tree layout via symlink on Windows.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0374" {
  let source =
    #|Test an out-of-build-tree layout on Windows with PYTHONHOME override.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0375" {
  let source =
    #|Test a layout on Windows with no DLLs directory.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0376" {
  let source =
    #|Test a venv created from non-installed python has correct zip path.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0377" {
  let source =
    #|Test an install with custom platlibdir on *nix
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0378" {
  let source =
    #|Test the explicitly set stdlib_dir in the config is respected.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0379" {
  let source =
    #|Make sure prefix/exec_prefix still point to the venv if PYTHONHOME was used.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0380" {
  let source =
    #|not-subdirs
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'subdirs' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0381" {
  let source =
    #|0x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0382" {
  let source =
    #|0 if 1Else 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0383" {
  let source =
    #|0b12
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0384" {
  let source =
    #|.. .
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0385" {
  let source =
    #|def f(*): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0386" {
  let source =
    #|def f(*,): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0387" {
  let source =
    #|def f(*, **kwds): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0388" {
  let source =
    #|f(1, x=2, *(3,4), x=5)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0389" {
  let source =
    #|def g(): [(yield x) for x in ()]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0390" {
  let source =
    #|assert(x, "msg")
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0391" {
  let source =
    #|assert(False, "msg")
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0392" {
  let source =
    #|assert(False,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0393" {
  let source =
    #|Test script for the grp module.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0394" {
  let source =
    #|Unittests for heapq.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0395" {
  let source =
    #|Mixin with a HMAC module implementation.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0396" {
  let source =
    #|Built-in HACL* implementation of HMAC.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0397" {
  let source =
    #|Mixin delegating to <module>.new() and <module>.digest().
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0398" {
  let source =
    #|Mixin delegating to _hashlib.hmac_new() and _hashlib.hmac_digest().
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0399" {
  let source =
    #|Mixin delegating to _hmac.new() and _hmac.compute_digest().
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0400" {
  let source =
    #|Mixin for checking HMAC objects (pure Python, OpenSSL or built-in).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0401" {
  let source =
    #|Mixin class for common tests.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0402" {
  let source =
    #|Tests for the 'digestmod' parameter for hmac_new() and hmac_digest().
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0403" {
  let source =
    #|Tests for the update() method (streaming HMAC).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0404" {
  let source =
    #|Miscellaneous tests for the pure Python HMAC module.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0405" {
  let source =
    #|Return a specialization of hmac_new() with a bound digestmod.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0406" {
  let source =
    #|Return a specialization of hmac_digest() with a bound digestmod.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0407" {
  let source =
    #|Create a HMAC object via a module-level class constructor.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0408" {
  let source =
    #|Check the HMAC digest of 'h' and its size.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0409" {
  let source =
    #|Extra tests that can be added in subclasses.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0410" {
  let source =
    #|A context manager catching errors when a digestmod is missing.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0411" {
  let source =
    #|A context manager catching errors when a digestmod is unknown.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0412" {
  let source =
    #|Generate cases for unknown digestmod tests.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0413" {
  let source =
    #|The underlying (non-instantiable) C class.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0414" {
  let source =
    #|The exact exception class raised upon invalid 'digestmod' values.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0415" {
  let source =
    #|Get the maximal input length for the GIL to be held.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0416" {
  let source =
    #|Tests for the html module functions.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0417" {
  let source =
    #|Tests for HTMLParser.py.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0418" {
  let source =
    #|<!-- not a comment --><not a='start tag'><![CDATA[not a cdata]]><!not a bogus comment></not a bogus comment>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0419" {
  let source =
    #|<!-- I'm a valid comment --><!--me too!--><!------><!-----><!----><!---><!--><!----I have many hyphens----><!-- I have a > in the middle --><!-- and I have -- in the middle! --><!--incorrectly-closed-comment--!><!----!><!----!--><!---- >--><!---!>--><!--!>--><!-- <!-- nested --> --><!--<!--><!--<!--!>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0420" {
  let source =
    #|<!--[if IE & !(lte IE 8)]>aren't<![endif]--><!--[if IE 8]>condcoms<![endif]--><!--[if lte IE 7]>pretty?<![endif]-->
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0421" {
  let source =
    #|<div style=""    ><b>The <a href="some_url">rain</a> <br /> in <span>Spain</span></b></div>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0422" {
  let source =
    #|<![if !(IE)]>broken condcom<![endif]><![if ! IE]><link href="favicon.tiff"/><![endif]><![if !IE 6]><img src="firefox.png" /><![endif]><![if !ie 6]><b>foo</b><![endif]><![if (!IE)|(lt IE 9)]><img src="mammoth.bmp" /><![endif]>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0423" {
  let source =
    #|<html><body bgcolor=d0ca90 text='181008'><table cellspacing=0 cellpadding=1 width=100% ><tr><td align=left><font size=-1>- <a href=/rabota/><span class=en> software-and-i</span></a>- <a href='/1/'><span class=en> library</span></a></table>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0424" {
  let source =
    #|<div class=bar,baz=asd><div class="bar",baz="asd"><div class=bar, baz=asd,><div class="bar", baz="asd",><div class="bar",><div class=,bar baz=,asd><div class=,"bar" baz=,"asd"><div ,class=bar ,baz=asd><div class,="bar" baz,="asd">
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0425" {
  let source =
    #|This should never be called with convert_charrefs=True
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0426" {
  let source =
    #|<!-- not a comment --> &not-an-entity-ref;
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0427" {
  let source =
    #|<not a='start tag'>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0428" {
  let source =
    #|a::before { content: "<!-- not a comment -->"; }
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0429" {
  let source =
    #|a::before { content: "&not-an-entity-ref;"; }
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0430" {
  let source =
    #|a::before { content: "<not a='start tag'>"; }
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0431" {
  let source =
    #|<!-- not a comment --><i>Spam</i>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0432" {
  let source =
    #|<!-- not a comment -->
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0433" {
  let source =
    #|&not-an-entity-ref;
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0434" {
  let source =
    #|I have a > in the middle
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0435" {
  let source =
    #|I have a ]] in the middle
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ']'\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0436" {
  let source =
    #|<a id="foo"class="bar">
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0437" {
  let source =
    #|I have a > in the middle 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0438" {
  let source =
    #|and I have -- in the middle! 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0439" {
  let source =
    #|[if IE & !(lte IE 8)]>aren't<![endif]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0440" {
  let source =
    #|[if IE 8]>condcoms<![endif]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0441" {
  let source =
    #|[if lte IE 7]>pretty?<![endif]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0442" {
  let source =
    #|not a comment either --
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0443" {
  let source =
    #|[with square brackets]!
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0444" {
  let source =
    #|[more brackets]-[and a hyphen]!
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0445" {
  let source =
    #|[CDATA [whitespaces are not ignored]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0446" {
  let source =
    #|[if !(IE)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0447" {
  let source =
    #|[if ! IE]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0448" {
  let source =
    #|[if !IE 6]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0449" {
  let source =
    #|[if !ie 6]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0450" {
  let source =
    #|[if (!IE)|(lt IE 9)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0451" {
  let source =
    #|software-and-i
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0452" {
  let source =
    #|CDATA[not a cdata
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0453" {
  let source =
    #|,class
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0454" {
  let source =
    #|class,
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0455" {
  let source =
    #|Tests for the Morsel object.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0456" {
  let source =
    #|Not integer types are not valid bases; issue16772.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0457" {
  let source =
    #|Ignore the +/- sign and space padding.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0458" {
  let source =
    #|The limit does not apply to power of 2 bases.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0459" {
  let source =
    #|tuple of length 2 is required from int_divmod\(\)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0460" {
  let source =
    #|_pylong.int_to_decimal_string did not
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0461" {
  let source =
    #|_pylong.int_from_string did not
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0462" {
  let source =
    #|invalid literal for int() with base %d: %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0463" {
  let source =
    #|Unittest for ipaddress module.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0464" {
  let source =
    #|Leading zeros are not permitted in '\d+'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0465" {
  let source =
    #|-1 (< 0) is not permitted as an IPv4 address
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0466" {
  let source =
    #|%d (>= 2**32) is not permitted as an IPv4 address
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0467" {
  let source =
    #|-1 (< 0) is not permitted as an IPv6 address
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0468" {
  let source =
    #|%d (>= 2**128) is not permitted as an IPv6 address
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0469" {
  let source =
    #|%r does not appear to be an IPv4 or IPv6 %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0470" {
  let source =
    #|%r (len %d != 4) is not permitted as an IPv4 address
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0471" {
  let source =
    #|%r (len %d != 16) is not permitted as an IPv6 address
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0472" {
  let source =
    #|At most 3 characters permitted in %r in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0473" {
  let source =
    #|Unexpected '/' in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0474" {
  let source =
    #|At least 3 parts expected in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0475" {
  let source =
    #|At most 8 colons permitted in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0476" {
  let source =
    #|At most 45 characters expected in '%s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0477" {
  let source =
    #|Exactly 8 parts expected without '::' in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0478" {
  let source =
    #|Expected at most 7 other parts with '::' in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0479" {
  let source =
    #|At most one '::' permitted in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0480" {
  let source =
    #|Leading ':' only permitted as part of '::' in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0481" {
  let source =
    #|Trailing ':' only permitted as part of '::' in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0482" {
  let source =
    #|Expected 4 octets in '1.net'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0483" {
  let source =
    #|Expected 4 octets in '127.0.1'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0484" {
  let source =
    #|Expected 4 octets in '1.2.3'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0485" {
  let source =
    #|Expected 4 octets in '1.2.3.4.5'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0486" {
  let source =
    #|Only decimal digits permitted in 'net' in '1.1.1.net'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0487" {
  let source =
    #|At most 4 characters permitted in %r in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0488" {
  let source =
    #|Only decimal digits permitted in %r in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0489" {
  let source =
    #|Octet %d (> 255) not permitted in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0490" {
  let source =
    #|Only hex digits permitted in %r in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0491" {
  let source =
    #|%r is not a valid netmask
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0492" {
  let source =
    #|1.0.0.127.in-addr.arpa
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0493" {
  let source =
    #|52.0.2.10.in-addr.arpa
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0494" {
  let source =
    #|Expected 4 octets in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0495" {
  let source =
    #|Empty octet not permitted in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0496" {
  let source =
    #|%s in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0497" {
  let source =
    #|Only one '/' permitted in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0498" {
  let source =
    #|Regression test for bpo-30570.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0499" {
  let source =
    #|Test that an iterator is the same after pickling, also when part-consumed
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0500" {
  let source =
    #|Pure python version from cwr()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0501" {
  let source =
    #|Did not raise Type in:  
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0502" {
  let source =
    #|Unit tests for the keyword only argument specified in PEP 3102.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0503" {
  let source =
    #|() takes from 1 to 2 positional arguments but 3 were given
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0504" {
  let source =
    #|) for 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0505" {
  let source =
    #|Correctly-rounded true division for integers.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0506" {
  let source =
    #|float(shuge) should not equal int(shuge)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0507" {
  let source =
    #|Cannot specify ',' with 's'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0508" {
  let source =
    #|Error in conversion of integer {} to float.  Got {}, expected {}.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0509" {
  let source =
    #|expected underflow to 0 from %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0510" {
  let source =
    #|can't deal with %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0511" {
  let source =
    #|failed to convert {} with byteorder={} and signed={}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0512" {
  let source =
    #|Code equivalent from docs is not equivalent for conversion of {0} with byteorder byteorder={1} and signed={2}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0513" {
  let source =
    #|failed to convert {} with byteorder={!r} and signed={}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0514" {
  let source =
    #|Code equivalent from docs is not equivalent for conversion of {0} with byteorder={1!r} and signed={2}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0515" {
  let source =
    #|failed to convert {} with default arguments
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0516" {
  let source =
    #|Number of '1' bits in binary expansion of a nonnnegative integer.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0517" {
  let source =
    #|Test suite for the sys.monitoring.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0518" {
  let source =
    #|Test that the second tool can set events with instruction events set by the first tool.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0519" {
  let source =
    #|def spam(a = b := 42): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0520" {
  let source =
    #|def spam(a: b := 42 = 5): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0521" {
  let source =
    #|(x := lambda: y := 1)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0522" {
  let source =
    #|(lambda: x := 1)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0523" {
  let source =
    #|[i + 1 for i in i := [1,2]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0524" {
  let source =
    #|[i := 0, j := 1 for i, j in [(1, 2), (3, 4)]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0525" {
  let source =
    #|[x := i for i in range(3) if x or not x]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0526" {
  let source =
    #|[j for i in range(3) if x or not x for j in range(3) if (x := i)][:-3]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0527" {
  let source =
    #|{0}(c := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0528" {
  let source =
    #|{0}(d := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0529" {
  let source =
    #|{0}(e := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0530" {
  let source =
    #|{0}(f := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0531" {
  let source =
    #|{0}(g := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0532" {
  let source =
    #|{0}(h := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0533" {
  let source =
    #|{0}(i := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0534" {
  let source =
    #|{0}(j := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0535" {
  let source =
    #|{0}(a := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0536" {
  let source =
    #|{0}(b := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0537" {
  let source =
    #|[i := 0 for i in range(5)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0538" {
  let source =
    #|[[(j := 0) for i in range(5)] for j in range(5)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0539" {
  let source =
    #|[(j := 0) for i in range(5) for j in range(5)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0540" {
  let source =
    #|[i := 0 for i, j in [(0, 1)]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0541" {
  let source =
    #|[i+1 for i in range(5) if (i := 0)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0542" {
  let source =
    #|[False or (i:=0) for i in range(5)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0543" {
  let source =
    #|[(i, j) for i in range(5) for j in range(5) if True or (i:=10)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0544" {
  let source =
    #|[i for i in range(5) if (j := 0) for j in range(5)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0545" {
  let source =
    #|[i for i in range(5) if (j := 0) for j, k in [(0, 1)]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0546" {
  let source =
    #|[i for i in (i := range(5))]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0547" {
  let source =
    #|[i for i in (2, 3, i := range(5))]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0548" {
  let source =
    #|[i for i in [2, 3, i := range(5)]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0549" {
  let source =
    #|[i for i in (j := range(5))]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0550" {
  let source =
    #|[i for i in (lambda:(j := range(5)))()]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0551" {
  let source =
    #|[i for i in range(5) for j in (i := range(5))]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0552" {
  let source =
    #|[i for i in [j for j in (k := range(5))]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0553" {
  let source =
    #|[i for i in [j for j in range(5) if (j := True)]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0554" {
  let source =
    #|[i for i in [(j := True) for j in range(5)]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0555" {
  let source =
    #|{i := 0 for i in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0556" {
  let source =
    #|{{(j := 0) for i in range(5)} for j in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0557" {
  let source =
    #|{(j := 0) for i in range(5) for j in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0558" {
  let source =
    #|{i := 0 for i, j in {(0, 1)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0559" {
  let source =
    #|{i+1 for i in range(5) if (i := 0)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0560" {
  let source =
    #|{False or (i:=0) for i in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0561" {
  let source =
    #|{(i, j) for i in range(5) for j in range(5) if True or (i:=10)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0562" {
  let source =
    #|{(a := 1) for a, (*b, c[d+e::f(g)], h.i) in j}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0563" {
  let source =
    #|{(b := 1) for a, (*b, c[d+e::f(g)], h.i) in j}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0564" {
  let source =
    #|{i for i in range(5) if (j := 0) for j in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0565" {
  let source =
    #|{i for i in range(5) if (j := 0) for j, k in {(0, 1)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0566" {
  let source =
    #|{i for i in (i := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0567" {
  let source =
    #|{i for i in (2, 3, i := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0568" {
  let source =
    #|{i for i in {2, 3, i := range(5)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0569" {
  let source =
    #|{i for i in (j := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0570" {
  let source =
    #|{i for i in (lambda:(j := range(5)))()}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0571" {
  let source =
    #|{i for i in range(5) for j in (i := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0572" {
  let source =
    #|{i for i in {j for j in (k := range(5))}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0573" {
  let source =
    #|{i for i in {j for j in range(5) if (j := True)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0574" {
  let source =
    #|{i for i in {(j := True) for j in range(5)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0575" {
  let source =
    #|{(i := 0): 1 for i in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0576" {
  let source =
    #|{1: (i := 0) for i in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0577" {
  let source =
    #|{(i := 0): (i := 0) for i in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0578" {
  let source =
    #|{{(j := 0): 1 for i in range(5)} for j in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0579" {
  let source =
    #|{(j := 0): 1 for i in range(5) for j in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0580" {
  let source =
    #|{(i := 0): 1 for i, j in {(0, 1)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0581" {
  let source =
    #|{1: (i := 0) for i, j in {(0, 1)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0582" {
  let source =
    #|{i+1: 1 for i in range(5) if (i := 0)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0583" {
  let source =
    #|{(False or (i:=0)): 1 for i in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0584" {
  let source =
    #|{i: j for i in range(5) for j in range(5) if True or (i:=10)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0585" {
  let source =
    #|{(a := 1): 1 for a, (*b, c[d+e::f(g)], h.i) in j}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0586" {
  let source =
    #|{(b := 1): 1 for a, (*b, c[d+e::f(g)], h.i) in j}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0587" {
  let source =
    #|{i: 1 for i in range(5) if (j := 0) for j in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0588" {
  let source =
    #|{i: 1 for i in range(5) if (j := 0) for j, k in {(0, 1)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0589" {
  let source =
    #|{i: 1 for i in (i := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0590" {
  let source =
    #|{i: 1 for i in (2, 3, i := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0591" {
  let source =
    #|{i: 1 for i in [2, 3, i := range(5)]}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0592" {
  let source =
    #|{i: 1 for i in (j := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0593" {
  let source =
    #|{i: 1 for i in (lambda:(j := range(5)))()}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0594" {
  let source =
    #|{i: 1 for i in range(5) for j in (i := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0595" {
  let source =
    #|{i: 1 for i in {j: 2 for j in (k := range(5))}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0596" {
  let source =
    #|{i: 1 for i in {j: 2 for j in range(5) if (j := True)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0597" {
  let source =
    #|{i: 1 for i in {(j := True) for j in range(5)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0598" {
  let source =
    #|result, x = (lambda x=1: (
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0599" {
  let source =
    #|Test pathname2url() and url2pathname()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0600" {
  let source =
    #|Dummy Integral class to test conversion of the Rational to float.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0601" {
  let source =
    #|got different hashes for {!r} and {!r}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0602" {
  let source =
    #|lambda: x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0603" {
  let source =
    #|Ensure that LOAD_SUPER_ATTR is specialized as expected.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0604" {
  let source =
    #|lambda: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0605" {
  let source =
    #|lambda a: a
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0606" {
  let source =
    #|lambda a=1: a
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0607" {
  let source =
    #|lambda: 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0608" {
  let source =
    #|lambda: 1
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0609" {
  let source =
    #|lambda a: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0610" {
  let source =
    #|lambda b: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0611" {
  let source =
    #|lambda a=None: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0612" {
  let source =
    #|lambda a=0: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0613" {
  let source =
    #|lambda a=1: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0614" {
  let source =
    #|Test suite for OS X interpreter environment variables.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0615" {
  let source =
    #|expected %s not %s %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0616" {
  let source =
    #|'%s' % ()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"TypeError: not enough arguments for format string\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0617" {
  let source =
    #|'%s' % (x, y)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0618" {
  let source =
    #|'%s%' % (x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0619" {
  let source =
    #|'%s%%%' % (x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0620" {
  let source =
    #|'%s%z' % (x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0621" {
  let source =
    #|'%s%z' % (x, 5)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0622" {
  let source =
    #|'%d' % (x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0623" {
  let source =
    #|'%x' % (x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0624" {
  let source =
    #|'%f' % (x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0625" {
  let source =
    #|'%s, %s' % (x, *y)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0626" {
  let source =
    #|is not a valid BINARY_OP argument.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0627" {
  let source =
    #|Adding a docstring made this test fail in Py2.5.0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0628" {
  let source =
    #|a in [1,2,3]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0629" {
  let source =
    #|a not in ["a","b","c"]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0630" {
  let source =
    #|a in [None, 1, None]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0631" {
  let source =
    #|a not in [(1, 2), 3, 4]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0632" {
  let source =
    #|a in {1,2,3}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0633" {
  let source =
    #|a not in {"a","b","c"}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0634" {
  let source =
    #|a in {None, 1, None}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0635" {
  let source =
    #|a not in {(1, 2), 3, 4}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0636" {
  let source =
    #|a in {1, 2, 3, 3, 2, 1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0637" {
  let source =
    #|a real number is required, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0638" {
  let source =
    #|an integer is required, not float
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0639" {
  let source =
    #|an integer is required, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0640" {
  let source =
    #|Unit tests for the positional only argument syntax specified in PEP 570.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0641" {
  let source =
    #|def f(a, b = 5, /, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0642" {
  let source =
    #|def f(a = 5, b, /, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0643" {
  let source =
    #|def f(a = 5, b=1, /, c, *, d=2): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0644" {
  let source =
    #|def f(a = 5, b, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0645" {
  let source =
    #|def f(a, /, b = 5, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0646" {
  let source =
    #|def f(*args, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0647" {
  let source =
    #|def f(*args, a, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0648" {
  let source =
    #|def f(**kwargs, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0649" {
  let source =
    #|def f(/, a = 1): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0650" {
  let source =
    #|def f(/, a): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0651" {
  let source =
    #|def f(/): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0652" {
  let source =
    #|def f(*, a, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0653" {
  let source =
    #|def f(*, /, a): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0654" {
  let source =
    #|def f(a, b/2, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0655" {
  let source =
    #|def f(a, /, c, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0656" {
  let source =
    #|def f(a, /, c, /, d): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0657" {
  let source =
    #|def f(a, /, c, /, d, *, e): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0658" {
  let source =
    #|def f(a, *, c, /, d, e): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0659" {
  let source =
    #|async def f(a, b = 5, /, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0660" {
  let source =
    #|async def f(a = 5, b, /, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0661" {
  let source =
    #|async def f(a = 5, b=1, /, c, d=2): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0662" {
  let source =
    #|async def f(a = 5, b, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0663" {
  let source =
    #|async def f(a, /, b = 5, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0664" {
  let source =
    #|async def f(*args, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0665" {
  let source =
    #|async def f(*args, a, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0666" {
  let source =
    #|async def f(**kwargs, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0667" {
  let source =
    #|async def f(/, a = 1): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0668" {
  let source =
    #|async def f(/, a): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0669" {
  let source =
    #|async def f(/): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0670" {
  let source =
    #|async def f(*, a, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0671" {
  let source =
    #|async def f(*, /, a): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0672" {
  let source =
    #|async def f(a, b/2, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0673" {
  let source =
    #|async def f(a, /, c, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0674" {
  let source =
    #|async def f(a, /, c, /, d): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0675" {
  let source =
    #|async def f(a, /, c, /, d, *, e): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0676" {
  let source =
    #|async def f(a, *, c, /, d, e): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0677" {
  let source =
    #|lambda a, b = 5, /, c: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0678" {
  let source =
    #|lambda a = 5, b, /, c: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0679" {
  let source =
    #|lambda a = 5, b=1, /, c, *, d=2: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0680" {
  let source =
    #|lambda a = 5, b, /: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0681" {
  let source =
    #|re.compile("[A-Za-z_]"       # letter or underscore
    #|           "[A-Za-z0-9_]*"   # letter, digit or underscore
    #|          )
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 're' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0682" {
  let source =
    #|f"abc{a # This is a comment }"
    #|+ 3}"
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0683" {
  let source =
    #|Test listing interpreters for a channel with no associations.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0684" {
  let source =
    #|Test listing interpreters for a channel with many associations.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0685" {
  let source =
    #|Test listing channel interpreters with a destroyed interpreter.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0686" {
  let source =
    #|Test listing channel interpreters with a released channel.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0687" {
  let source =
    #|Test listing channel interpreters with a closed channel.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0688" {
  let source =
    #|Test listing channel interpreters with a channel's send end closed.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0689" {
  let source =
    #|non-blocking with timeout
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0690" {
  let source =
    #|, b'X' if result.closed else b'', blocking=False)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0691" {
  let source =
    #|%s != %s (%s for %s; set to %s, using %s)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0692" {
  let source =
    #|Compare calculation against known value, if available
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0693" {
  let source =
    #|locale support broken for OS X < 10.4
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0694" {
  let source =
    #|<not able to determine>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0695" {
  let source =
    #|using eval('3.14') failed for %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0696" {
  let source =
    #|using float('3.14') failed for %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0697" {
  let source =
    #|Unit tests for abc.py.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0698" {
  let source =
    #|class C without an implementation for abstract methods 'method_one', 'method_two'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0699" {
  let source =
    #|class A without an implementation for abstract methods 'bar', 'foo'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0700" {
  let source =
    #|Unit tests for numbers.py.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0701" {
  let source =
    #|write\(\) argument must be str, not 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0702" {
  let source =
    #|write\(\) argument must be bytes-like, not 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0703" {
  let source =
    #|Asynchronously yield 1, then 2.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0704" {
  let source =
    #|yield from.*inside async
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0705" {
  let source =
    #|return.*value.*async gen
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0706" {
  let source =
    #|anext\(\): asynchronous generator is already running
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0707" {
  let source =
    #|athrow\(\): asynchronous generator is already running
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0708" {
  let source =
    #|this is a generator-based coroutine
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0709" {
  let source =
    #|x, b += 3
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0710" {
  let source =
    #|Blocks inheritance, and fallback to __add__
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0711" {
  let source =
    #|Test that hexlify and b2a_hex are binary versions of bytes.hex.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0712" {
  let source =
    #|binascii.a2b_qp(**{1:1}) didn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0713" {
  let source =
    #|Tests for binary operators on subtypes of built-in types.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0714" {
  let source =
    #|Test whether an object is an instance of int.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0715" {
  let source =
    #|Test whether an object is an instance of a built-in numeric type.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0716" {
  let source =
    #|Test whether an object is an instance of the Rat class.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0717" {
  let source =
    #|Unit tests for Rat class and its support utilities.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0718" {
  let source =
    #|Base class for classes with operation logging.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0719" {
  let source =
    #|Subclass of SupEq that can test equality, but not non-equality
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0720" {
  let source =
    #|Independent class that can test equality, but not non-equality
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0721" {
  let source =
    #|Accessor function for read-only 'num' attribute of Rat.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0722" {
  let source =
    #|Accessor function for read-only 'den' attribute of Rat.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0723" {
  let source =
    #|Add two Rats, or a Rat and a number.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0724" {
  let source =
    #|Subtract two Rats, or a Rat and a number.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0725" {
  let source =
    #|Subtract two Rats, or a Rat and a number (reversed args).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0726" {
  let source =
    #|Multiply two Rats, or a Rat and a number.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0727" {
  let source =
    #|Divide two Rats, or a Rat and a number.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0728" {
  let source =
    #|Divide two Rats, or a Rat and a number (reversed args).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0729" {
  let source =
    #|Divide two Rats, returning quotient and remainder.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0730" {
  let source =
    #|Divide two Rats, returning quotient and remainder (reversed args).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0731" {
  let source =
    #|Compare two Rats for equality.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0732" {
  let source =
    #|Rat(1, 0) didn't raise ZeroDivisionError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0733" {
  let source =
    #|Rat(%r) didn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0734" {
  let source =
    #|Rat(1, %r) didn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0735" {
  let source =
    #|Dummy sequence class defining __len__ but not __getitem__.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0736" {
  let source =
    #|Dummy sequence class defining __getitem__ but not __len__.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0737" {
  let source =
    #|invalid keyword argument for print\(\)$
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0738" {
  let source =
    #|invalid keyword argument for round\(\)$
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0739" {
  let source =
    #|^'module' object is not callable\. Did you mean: 'mod\.mod\(\.\.\.\)'\?$
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0740" {
  let source =
    #|A.method_two_args() got multiple values for argument 'x'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0741" {
  let source =
    #|def f(
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0742" {
  let source =
    #|) : return a
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0743" {
  let source =
    #|spam, spam, spam and ham
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'spam' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0744" {
  let source =
    #|'B' object attribute 'y' is read-only
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0745" {
  let source =
    #|attribute error for I.__init__ got masked
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0746" {
  let source =
    #|attribute error for A().a got masked: %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0747" {
  let source =
    #|{!r} and {!r} are not sufficiently close
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0748" {
  let source =
    #|cmath.pi is {}; should be {}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0749" {
  let source =
    #|cmath.e is {}; should be {}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0750" {
  let source =
    #|ValueError not raised in test {}: {}(complex({!r}, {!r}))
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0751" {
  let source =
    #|OverflowError not raised in test {}: {}(complex({!r}, {!r}))
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0752" {
  let source =
    #|x is x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0753" {
  let source =
    #|x in x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0754" {
  let source =
    #|lambda:42
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0755" {
  let source =
    #|String %r is not interned
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'String' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0756" {
  let source =
    #|String %r is interned
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'String' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0757" {
  let source =
    #|def f():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0758" {
  let source =
    #|Error in sys.excepthook:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0759" {
  let source =
    #|File "<console>", line 1, in <module>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0760" {
  let source =
    #|File "<console>", line 2, in f
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0761" {
  let source =
    #|'ascii' codec can't encode character '\xfc' in position 1: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0762" {
  let source =
    #|'ascii' codec can't encode characters in position 1-3: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0763" {
  let source =
    #|'ascii' codec can't encode character '\xfc' in position 0: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0764" {
  let source =
    #|'ascii' codec can't encode character '\u0100' in position 0: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0765" {
  let source =
    #|'ascii' codec can't encode character '\uffff' in position 0: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0766" {
  let source =
    #|'ascii' codec can't encode character '\U00010000' in position 0: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0767" {
  let source =
    #|'ascii' codec can't decode byte 0xfc in position 1: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0768" {
  let source =
    #|'ascii' codec can't decode bytes in position 1-2: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0769" {
  let source =
    #|can't translate character '\xfc' in position 1: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0770" {
  let source =
    #|can't translate character '\u0100' in position 1: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0771" {
  let source =
    #|can't translate character '\uffff' in position 1: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0772" {
  let source =
    #|can't translate character '\U00010000' in position 1: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0773" {
  let source =
    #|can't translate characters in position 1-2: ouch
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0774" {
  let source =
    #|abc<def>ghi
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0775" {
  let source =
    #|if 1:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0776" {
  let source =
    #|def x():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0777" {
  let source =
    #|lambda z: \
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0778" {
  let source =
    #|from a import (
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0779" {
  let source =
    #|from a import (b
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0780" {
  let source =
    #|from a import (b,
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0781" {
  let source =
    #|from a import (b,c
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0782" {
  let source =
    #|from a import (b,c,
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0783" {
  let source =
    #|def a(
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0784" {
  let source =
    #|def a(b
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0785" {
  let source =
    #|def a(b,
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0786" {
  let source =
    #|def a(b,c
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0787" {
  let source =
    #|def a(b,c,
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0788" {
  let source =
    #|while a:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0789" {
  let source =
    #|for a in b:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0790" {
  let source =
    #|try:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0791" {
  let source =
    #|with a:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0792" {
  let source =
    #|with a as b:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0793" {
  let source =
    #|class a:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0794" {
  let source =
    #|class a(
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0795" {
  let source =
    #|class a(b
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0796" {
  let source =
    #|class a(b,
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0797" {
  let source =
    #|class a():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0798" {
  let source =
    #|[x for
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0799" {
  let source =
    #|[x for x in
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0800" {
  let source =
    #|[x for x in (
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0801" {
  let source =
    #|(x for
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0802" {
  let source =
    #|(x for x in
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0803" {
  let source =
    #|(x for x in (
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0804" {
  let source =
    #|lambda z:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0805" {
  let source =
    #|if (a == 1 and b = 2): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0806" {
  let source =
    #|del (1,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0807" {
  let source =
    #|del [1]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0808" {
  let source =
    #|[i for i in range(10)] = (1, 2, 3)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0809" {
  let source =
    #|raise = 4
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0810" {
  let source =
    #|def a-b
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0811" {
  let source =
    #|a await raise b?+1
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0812" {
  let source =
    #|Unit tests for collections.py.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0813" {
  let source =
    #|Tests for changes for issue #16613.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0814" {
  let source =
    #|Docstrings are omitted with -O2 and above
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0815" {
  let source =
    #|docstring for Point.x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0816" {
  let source =
    #|docstring for Vector.x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0817" {
  let source =
    #|_tuplegetter(0, 'Alias for field number 0')
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name '_tuplegetter' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0818" {
  let source =
    #|_tuplegetter(1, 'Alias for field number 1')
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name '_tuplegetter' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0819" {
  let source =
    #|Right side not called for %s.%s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0820" {
  let source =
    #|Test equality and order comparisons.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0821" {
  let source =
    #|Test equality and order comparisons for some simple cases.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0822" {
  let source =
    #|object.__ne__() should not invoke reflected __eq__()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0823" {
  let source =
    #|No default delegation between operations except __ne__()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0824" {
  let source =
    #|Compare same-class instances with comparison methods.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0825" {
  let source =
    #|Compare different-class instances with comparison methods.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0826" {
  let source =
    #|Compare instances of str and a subclass.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0827" {
  let source =
    #|Compare list, tuple, and range.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0828" {
  let source =
    #|Compare bytes and bytearray.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0829" {
  let source =
    #|Compare set and frozenset.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0830" {
  let source =
    #|Return true iff floats x and y "are close".
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0831" {
  let source =
    #|Return true iff complexes x and y "are close".
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0832" {
  let source =
    #|Compute complex z=x*y, and check that z/x==y and z/y==x.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0833" {
  let source =
    #|argument must be a string or a number, not dict
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0834" {
  let source =
    #|argument must be a string or a number, not NoneType
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0835" {
  let source =
    #|argument 'real' must be a real number, not dict
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0836" {
  let source =
    #|argument 'real' must be a real number, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0837" {
  let source =
    #|argument 'imag' must be a real number, not dict
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0838" {
  let source =
    #|argument 'imag' must be a real number, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0839" {
  let source =
    #|Test usage of __complex__() when inheriting from 'complex'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0840" {
  let source =
    #|Test usage of __complex__() with a __new__() method
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0841" {
  let source =
    #|should fail 0.0 to negative or complex power
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0842" {
  let source =
    #|argument 'real' must be a real number, not complex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0843" {
  let source =
    #|argument 'real' must be a real number, not .*ComplexSubclass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0844" {
  let source =
    #|argument 'real' must be a real number, not .*WithComplex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0845" {
  let source =
    #|argument 'imag' must be a real number, not complex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0846" {
  let source =
    #|argument 'imag' must be a real number, not .*ComplexSubclass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0847" {
  let source =
    #|argument 'imag' must be a real number, not .*WithComplex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0848" {
  let source =
    #|_testinternalcapi.hamt() not available
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0849" {
  let source =
    #|Unit tests for the copy module.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0850" {
  let source =
    #|asyncio does not work under Emscripten/WASI yet.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0851" {
  let source =
    #|This would crash the interpreter in 3.11a2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0852" {
  let source =
    #|[[i async for i in a] for a in elts]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0853" {
  let source =
    #|cannot 'yield from' a coroutine object in a non-coroutine generator
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0854" {
  let source =
    #|__await__.*must return an iterator, not
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0855" {
  let source =
    #|__await__\(\) must return an iterator, not coroutine
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0856" {
  let source =
    #|'async with' received an object from __aenter__ that does not implement __await__: int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0857" {
  let source =
    #|'async with' received an object from __aexit__ that does not implement __await__: int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0858" {
  let source =
    #|async for' requires an object.*__aiter__.*tuple
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0859" {
  let source =
    #|async for' received an invalid object.*__anext__.*tuple
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0860" {
  let source =
    #|__await__.*must return an iterator, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0861" {
  let source =
    #|def i{i}(): return {i}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0862" {
  let source =
    #|, in a1
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0863" {
  let source =
    #|, in a2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0864" {
  let source =
    #|Make sure __main__ module exists (and clean up after).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0865" {
  let source =
    #|Create the module and add to sys.modules, then remove it after.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0866" {
  let source =
    #|with newline=''
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0867" {
  let source =
    #|More to document existing (unexpected?) behavior than anything else.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0868" {
  let source =
    #|1,2,3,"""I see,"" said the blind man","as he picked up his hammer and saw"
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0869" {
  let source =
    #|abc\,def
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0870" {
  let source =
    #|2147483648,43.0e12,17,abc,def
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0871" {
  let source =
    #|147483648,43.0e2,17,abc,def
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0872" {
  let source =
    #|47483648,43.0,170,abc,def
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0873" {
  let source =
    #|"quotechar" must be a unicode character or None, not a string of length 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0874" {
  let source =
    #|"quotechar" must be a unicode character or None, not a string of length 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0875" {
  let source =
    #|"quotechar" must be a unicode character or None, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0876" {
  let source =
    #|"delimiter" must be a unicode character, not a string of length 3
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0877" {
  let source =
    #|"delimiter" must be a unicode character, not a string of length 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0878" {
  let source =
    #|"delimiter" must be a unicode character, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0879" {
  let source =
    #|"delimiter" must be a unicode character, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0880" {
  let source =
    #|"delimiter" must be a unicode character, not NoneType
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0881" {
  let source =
    #|"escapechar" must be a unicode character or None, not a string of length 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0882" {
  let source =
    #|"escapechar" must be a unicode character or None, not a string of length 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0883" {
  let source =
    #|"escapechar" must be a unicode character or None, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0884" {
  let source =
    #|"escapechar" must be a unicode character or None, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0885" {
  let source =
    #|"lineterminator" must be a string, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0886" {
  let source =
    #|"lineterminator" must be a string, not NoneType
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0887" {
  let source =
    #|Key ordering: some key permutations not collected (expected 120)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0888" {
  let source =
    #|'__version__' is deprecated and slated for removal in Python 3.20
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0889" {
  let source =
    #|abc,def
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0890" {
  let source =
    #|args[1] is not None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'args' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0891" {
  let source =
    #|Unit tests for collections.defaultdict.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0892" {
  let source =
    #|defaultdict(<class 'int'>, {12: 42})
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0893" {
  let source =
    #|d2[15] didn't raise KeyError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0894" {
  let source =
    #|Sets default __doc__ and simplifies repr() output.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0895" {
  let source =
    #|Cannot create a consistent method resolution order (MRO) for bases 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0896" {
  let source =
    #|Utility method to verify if two objects are copies of each others.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0897" {
  let source =
    #|Deep reentrancy must not over-decref old_mro.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0898" {
  let source =
    #|descriptor 'classmeth' for type 'xxsubtype.spamlist' needs a type, not a 'xxsubtype.spamlist' as arg 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0899" {
  let source =
    #|x has to be an instance of a class inheriting from Base.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0900" {
  let source =
    #|unsupported operand type(s) for **=
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0901" {
  let source =
    #|unsupported operand type(s) for **
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0902" {
  let source =
    #|expected 1 or 2 arguments, got 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0903" {
  let source =
    #|expected 1 or 2 arguments, got 3
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0904" {
  let source =
    #|<bound method .*Foo\.method of <class '.*Foo'>>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0905" {
  let source =
    #|mykey2=from Base2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0906" {
  let source =
    #|This class copies object using pickle.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0907" {
  let source =
    #|A class with __getstate__ and __setstate__ implemented.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0908" {
  let source =
    #|A subclass of a class with slots.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0909" {
  let source =
    #|A subclass with an extra slot.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0910" {
  let source =
    #|The state of this class is copyable via its instance dict.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0911" {
  let source =
    #|calling object w/o call method should raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0912" {
  let source =
    #|object() should not allow setting a foo attribute
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0913" {
  let source =
    #|[None] slots not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0914" {
  let source =
    #|['foo bar'] slots not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0915" {
  let source =
    #|['foo\0bar'] slots not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0916" {
  let source =
    #|['1'] slots not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0917" {
  let source =
    #|[''] slots not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0918" {
  let source =
    #|[chr(128)] slots not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0919" {
  let source =
    #|inheritance from non-type should be illegal
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0920" {
  let source =
    #|devious mro() return not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0921" {
  let source =
    #|non-class mro() return not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0922" {
  let source =
    #|non-sequence mro() return not caught
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0923" {
  let source =
    #|no TypeError from dict(incomplete mapping)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0924" {
  let source =
    #|invalid del() didn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0925" {
  let source =
    #|'' + 5 doesn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0926" {
  let source =
    #|''.split('') doesn't raise ValueError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0927" {
  let source =
    #|''.join([0]) doesn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0928" {
  let source =
    #|''.rindex('5') doesn't raise ValueError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0929" {
  let source =
    #|'%(n)s' % None doesn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0930" {
  let source =
    #|'%(n' % {} '' doesn't raise ValueError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0931" {
  let source =
    #|'%*s' % ('abc') doesn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0932" {
  let source =
    #|'%*.*s' % ('abc', 5) doesn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0933" {
  let source =
    #|'%s' % (1, 2) doesn't raise TypeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0934" {
  let source =
    #|'%' % None doesn't raise ValueError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0935" {
  let source =
    #|did not test __init__() for None return
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0936" {
  let source =
    #|assigning %r as __class__ for %r silently failed
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0937" {
  let source =
    #|{!r} is not a copy of {!r}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0938" {
  let source =
    #|expected AttributeError from trying to set readonly %r attr on a property
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0939" {
  let source =
    #|no TypeError from dict(%r)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0940" {
  let source =
    #|no ValueError from dict(%r)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0941" {
  let source =
    #|expected TypeError from bogus keyword argument to %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0942" {
  let source =
    #|shouldn't allow del %r.__class__
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0943" {
  let source =
    #|shouldn't allow del %r.__dict__
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0944" {
  let source =
    #|__getattr__ called with {0}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0945" {
  let source =
    #|__getattribute__ called with {0}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0946" {
  let source =
    #|split table must be combined when del d[k]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0947" {
  let source =
    #|dict.update(other) must preserve order in other.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0948" {
  let source =
    #|{x: y for y, x in ((1, 2), (3, 4))} = 5
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0949" {
  let source =
    #|{x: y for y, x in ((1, 2), (3, 4))} += 5
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0950" {
  let source =
    #|This is an XML-RPC server's documentation, but the server can be used by POSTing to /RPC2. Try self.add, too.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0951" {
  let source =
    #|lambda: len([])
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0952" {
  let source =
    #|foo()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'foo' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0953" {
  let source =
    #|lambda: 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0954" {
  let source =
    #|__doc__ is already present, __slots__ will have no effect
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0955" {
  let source =
    #|non-callable __reversed__ didn't raise!
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0956" {
  let source =
    #|no %s attr in errno.errorcode
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0957" {
  let source =
    #|'break', 'continue' and 'return' cannot appear in an except\* block
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0958" {
  let source =
    #|split must return a tuple, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0959" {
  let source =
    #|split must return a 2-tuple, got tuple of size 1
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0960" {
  let source =
    #|argument 1 must be str, not 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0961" {
  let source =
    #|Item [0-9]+ of second argument \(exceptions\) is not an exception
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0962" {
  let source =
    #|expect instance, not type
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0963" {
  let source =
    #|.*MySeq\.__repr__\(\) must return a str, not NoneType
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0964" {
  let source =
    #|context and cause for ValueError(1)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0965" {
  let source =
    #|context for ValueError(2)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0966" {
  let source =
    #|Tests for object finalization semantics, as outlined in PEP 442.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0967" {
  let source =
    #|Test finalization of objects with a tp_del.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0968" {
  let source =
    #|Check the object is sane (non-broken).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0969" {
  let source =
    #|Resurrect self by storing self in a class-wide list.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0970" {
  let source =
    #|from __future__ import barry_as_FLUFL;2 {0} 3
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0971" {
  let source =
    #|from .__future__ import barry_as_FLUFL;2 {0} 3
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0972" {
  let source =
    #|with Barry as BDFL, use '<>' instead of '!='
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0973" {
  let source =
    #|f'xx{value:{bad_format_spec}}yy'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'value' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0974" {
  let source =
    #|%d format: a real number is required, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0975" {
  let source =
    #|%d format: a real number is required, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0976" {
  let source =
    #|%x format: an integer is required, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0977" {
  let source =
    #|%x format: an integer is required, not float
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0978" {
  let source =
    #|%i format: a real number is required, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0979" {
  let source =
    #|%i format: a real number is required, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0980" {
  let source =
    #|must be real number, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0981" {
  let source =
    #|%c arg not in range(0x110000)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0982" {
  let source =
    #|%c requires an int or a unicode character, not float
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0983" {
  let source =
    #|%c requires an int or a unicode character, not a string of length 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0984" {
  let source =
    #|%c requires an int or a unicode character, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0985" {
  let source =
    #|float argument required, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0986" {
  let source =
    #|float argument required, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0987" {
  let source =
    #|%c arg not in range(256)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0988" {
  let source =
    #|%c requires an integer in range(256) or a single byte, not a bytes object of length 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0989" {
  let source =
    #|%c requires an integer in range(256) or a single byte, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0990" {
  let source =
    #|%c requires an integer in range(256) or a single byte, not float
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0991" {
  let source =
    #|%b requires a bytes-like object, or an object that implements __bytes__, not 'str'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0992" {
  let source =
    #|Cannot specify ',' with ','.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0993" {
  let source =
    #|Cannot specify '_' with '_'.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0994" {
  let source =
    #|Cannot specify both ',' and '_'.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0995" {
  let source =
    #|Invalid format specifier '%' for object of type 'str'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0996" {
  let source =
    #|Negative zero coercion (z) not allowed
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0997" {
  let source =
    #|did not get expected exception: %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0998" {
  let source =
    #|overflow (this is fine)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'overflow' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/0999" {
  let source =
    #|Tests for frame.clear().
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1000" {
  let source =
    #|Tests for repr(frame).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1001" {
  let source =
    #|Test that FrameLocalsProxy behaves like a Mapping (with exceptions)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1002" {
  let source =
    #|Clear all frames in a traceback.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1003" {
  let source =
    #|Unlike a mapping: del proxy[key] fails
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1004" {
  let source =
    #|A weakref'able class.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1005" {
  let source =
    #|Try to find globals and locals as this frame is being cleared.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1006" {
  let source =
    #|Run SneakyDel.__del__ as this frame is popped.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1007" {
  let source =
    #|Basic test of the frozen module (source is in Python/frozen.c).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1008" {
  let source =
    #|set attribute on function implementations, should show up in next dir
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1009" {
  let source =
    #|global_function.<locals>.<lambda>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1010" {
  let source =
    #|__defaults__ does not update; deleting it does not remove requirement
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1011" {
  let source =
    #|shouldn't be able to del %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1012" {
  let source =
    #|thread sanitizer crashes in __tsan::FuncEntry
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1013" {
  let source =
    #|. Use either `@register(some_class)` or plain `@register` on an annotated function.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1014" {
  let source =
    #|Disallow this case because decorated function a would not be cached.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1015" {
  let source =
    #|Reusing a cached_property on different classes under the same name is OK.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1016" {
  let source =
    #|Caching still works for a subclass defining __set__.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1017" {
  let source =
    #|missing positional arguments in 'partial' call; expected at least 1, got 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1018" {
  let source =
    #|Invalid annotation for 'arg'.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1019" {
  let source =
    #|typing.Iterable[str] is not a class.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1020" {
  let source =
    #|int | typing.Iterable[str] not all arguments are classes.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1021" {
  let source =
    #|never called, slots not supported
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1022" {
  let source =
    #|Ambiguous dispatch: <class 'collections.abc.Container'> or <class 'collections.abc.Iterable'>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1023" {
  let source =
    #|Ambiguous dispatch: <class 'collections.abc.Iterable'> or <class 'collections.abc.Container'>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1024" {
  let source =
    #|Ambiguous dispatch: <class 'collections.abc.Container'> or <class 'collections.abc.Sized'>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1025" {
  let source =
    #|Ambiguous dispatch: <class 'collections.abc.Sized'> or <class 'collections.abc.Container'>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1026" {
  let source =
    #|I annotated with a non-type
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1027" {
  let source =
    #|The '__dict__' attribute on 'MyMeta' instance does not support item assignment for caching 'prop' property.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1028" {
  let source =
    #|Cannot assign the same cached_property to two different names ('a' and 'b').
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1029" {
  let source =
    #|built with -NDEBUG
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1030" {
  let source =
    #|A generator that releases the GIL when closed or dealloc'ed.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1031" {
  let source =
    #|Exercise make_nested() in a loop.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1032" {
  let source =
    #|didn't find obj in garbage (finalizer)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1033" {
  let source =
    #|def test():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1034" {
  let source =
    #|__cause__, __context__, or __suppress_context__ were not properly set
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1035" {
  let source =
    #|'.*' object is not iterable
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1036" {
  let source =
    #|else remove_from_successors() pruning flawed
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1037" {
  let source =
    #|Tests for C-implemented GenericAlias.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1038" {
  let source =
    #|Test an in-build-tree layout on Windows.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1039" {
  let source =
    #|Test an in-build-tree layout via symlink on Windows.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1040" {
  let source =
    #|Test an out-of-build-tree layout on Windows with PYTHONHOME override.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1041" {
  let source =
    #|Test a layout on Windows with no DLLs directory.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1042" {
  let source =
    #|Test a venv created from non-installed python has correct zip path.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1043" {
  let source =
    #|Test an install with custom platlibdir on *nix
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1044" {
  let source =
    #|Test the explicitly set stdlib_dir in the config is respected.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1045" {
  let source =
    #|Make sure prefix/exec_prefix still point to the venv if PYTHONHOME was used.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1046" {
  let source =
    #|not-subdirs
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'subdirs' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1047" {
  let source =
    #|0x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1048" {
  let source =
    #|0 if 1Else 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1049" {
  let source =
    #|0b12
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1050" {
  let source =
    #|.. .
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1051" {
  let source =
    #|def f(*): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1052" {
  let source =
    #|def f(*,): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1053" {
  let source =
    #|def f(*, **kwds): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1054" {
  let source =
    #|f(1, x=2, *(3,4), x=5)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1055" {
  let source =
    #|def g(): [(yield x) for x in ()]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1056" {
  let source =
    #|assert(x, "msg")
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1057" {
  let source =
    #|assert(False, "msg")
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1058" {
  let source =
    #|assert(False,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1059" {
  let source =
    #|Test script for the grp module.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1060" {
  let source =
    #|Unittests for heapq.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1061" {
  let source =
    #|Mixin with a HMAC module implementation.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1062" {
  let source =
    #|Built-in HACL* implementation of HMAC.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1063" {
  let source =
    #|Mixin delegating to <module>.new() and <module>.digest().
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1064" {
  let source =
    #|Mixin delegating to _hashlib.hmac_new() and _hashlib.hmac_digest().
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1065" {
  let source =
    #|Mixin delegating to _hmac.new() and _hmac.compute_digest().
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1066" {
  let source =
    #|Mixin for checking HMAC objects (pure Python, OpenSSL or built-in).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1067" {
  let source =
    #|Mixin class for common tests.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1068" {
  let source =
    #|Tests for the 'digestmod' parameter for hmac_new() and hmac_digest().
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1069" {
  let source =
    #|Tests for the update() method (streaming HMAC).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1070" {
  let source =
    #|Miscellaneous tests for the pure Python HMAC module.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1071" {
  let source =
    #|Return a specialization of hmac_new() with a bound digestmod.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1072" {
  let source =
    #|Return a specialization of hmac_digest() with a bound digestmod.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1073" {
  let source =
    #|Create a HMAC object via a module-level class constructor.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1074" {
  let source =
    #|Check the HMAC digest of 'h' and its size.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1075" {
  let source =
    #|Extra tests that can be added in subclasses.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1076" {
  let source =
    #|A context manager catching errors when a digestmod is missing.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1077" {
  let source =
    #|A context manager catching errors when a digestmod is unknown.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1078" {
  let source =
    #|Generate cases for unknown digestmod tests.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1079" {
  let source =
    #|The underlying (non-instantiable) C class.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1080" {
  let source =
    #|The exact exception class raised upon invalid 'digestmod' values.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1081" {
  let source =
    #|Get the maximal input length for the GIL to be held.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1082" {
  let source =
    #|Tests for the html module functions.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1083" {
  let source =
    #|Tests for HTMLParser.py.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1084" {
  let source =
    #|<!-- not a comment --><not a='start tag'><![CDATA[not a cdata]]><!not a bogus comment></not a bogus comment>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1085" {
  let source =
    #|<!-- I'm a valid comment --><!--me too!--><!------><!-----><!----><!---><!--><!----I have many hyphens----><!-- I have a > in the middle --><!-- and I have -- in the middle! --><!--incorrectly-closed-comment--!><!----!><!----!--><!---- >--><!---!>--><!--!>--><!-- <!-- nested --> --><!--<!--><!--<!--!>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1086" {
  let source =
    #|<!--[if IE & !(lte IE 8)]>aren't<![endif]--><!--[if IE 8]>condcoms<![endif]--><!--[if lte IE 7]>pretty?<![endif]-->
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1087" {
  let source =
    #|<div style=""    ><b>The <a href="some_url">rain</a> <br /> in <span>Spain</span></b></div>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1088" {
  let source =
    #|<![if !(IE)]>broken condcom<![endif]><![if ! IE]><link href="favicon.tiff"/><![endif]><![if !IE 6]><img src="firefox.png" /><![endif]><![if !ie 6]><b>foo</b><![endif]><![if (!IE)|(lt IE 9)]><img src="mammoth.bmp" /><![endif]>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1089" {
  let source =
    #|<html><body bgcolor=d0ca90 text='181008'><table cellspacing=0 cellpadding=1 width=100% ><tr><td align=left><font size=-1>- <a href=/rabota/><span class=en> software-and-i</span></a>- <a href='/1/'><span class=en> library</span></a></table>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1090" {
  let source =
    #|<div class=bar,baz=asd><div class="bar",baz="asd"><div class=bar, baz=asd,><div class="bar", baz="asd",><div class="bar",><div class=,bar baz=,asd><div class=,"bar" baz=,"asd"><div ,class=bar ,baz=asd><div class,="bar" baz,="asd">
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1091" {
  let source =
    #|This should never be called with convert_charrefs=True
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1092" {
  let source =
    #|<!-- not a comment --> &not-an-entity-ref;
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1093" {
  let source =
    #|<not a='start tag'>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1094" {
  let source =
    #|a::before { content: "<!-- not a comment -->"; }
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1095" {
  let source =
    #|a::before { content: "&not-an-entity-ref;"; }
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1096" {
  let source =
    #|a::before { content: "<not a='start tag'>"; }
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1097" {
  let source =
    #|<!-- not a comment --><i>Spam</i>
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1098" {
  let source =
    #|<!-- not a comment -->
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1099" {
  let source =
    #|&not-an-entity-ref;
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1100" {
  let source =
    #|I have a > in the middle
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1101" {
  let source =
    #|I have a ]] in the middle
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ']'\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1102" {
  let source =
    #|<a id="foo"class="bar">
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1103" {
  let source =
    #|I have a > in the middle 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1104" {
  let source =
    #|and I have -- in the middle! 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1105" {
  let source =
    #|[if IE & !(lte IE 8)]>aren't<![endif]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1106" {
  let source =
    #|[if IE 8]>condcoms<![endif]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1107" {
  let source =
    #|[if lte IE 7]>pretty?<![endif]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1108" {
  let source =
    #|not a comment either --
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1109" {
  let source =
    #|[with square brackets]!
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1110" {
  let source =
    #|[more brackets]-[and a hyphen]!
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1111" {
  let source =
    #|[CDATA [whitespaces are not ignored]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1112" {
  let source =
    #|[if !(IE)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1113" {
  let source =
    #|[if ! IE]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1114" {
  let source =
    #|[if !IE 6]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1115" {
  let source =
    #|[if !ie 6]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1116" {
  let source =
    #|[if (!IE)|(lt IE 9)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1117" {
  let source =
    #|software-and-i
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1118" {
  let source =
    #|CDATA[not a cdata
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1119" {
  let source =
    #|,class
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1120" {
  let source =
    #|class,
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1121" {
  let source =
    #|Tests for the Morsel object.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1122" {
  let source =
    #|Not integer types are not valid bases; issue16772.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1123" {
  let source =
    #|Ignore the +/- sign and space padding.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1124" {
  let source =
    #|The limit does not apply to power of 2 bases.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1125" {
  let source =
    #|tuple of length 2 is required from int_divmod\(\)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1126" {
  let source =
    #|_pylong.int_to_decimal_string did not
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1127" {
  let source =
    #|_pylong.int_from_string did not
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1128" {
  let source =
    #|invalid literal for int() with base %d: %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1129" {
  let source =
    #|Unittest for ipaddress module.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1130" {
  let source =
    #|Leading zeros are not permitted in '\d+'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1131" {
  let source =
    #|-1 (< 0) is not permitted as an IPv4 address
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1132" {
  let source =
    #|%d (>= 2**32) is not permitted as an IPv4 address
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1133" {
  let source =
    #|-1 (< 0) is not permitted as an IPv6 address
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1134" {
  let source =
    #|%d (>= 2**128) is not permitted as an IPv6 address
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1135" {
  let source =
    #|%r does not appear to be an IPv4 or IPv6 %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1136" {
  let source =
    #|%r (len %d != 4) is not permitted as an IPv4 address
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1137" {
  let source =
    #|%r (len %d != 16) is not permitted as an IPv6 address
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1138" {
  let source =
    #|At most 3 characters permitted in %r in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1139" {
  let source =
    #|Unexpected '/' in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1140" {
  let source =
    #|At least 3 parts expected in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1141" {
  let source =
    #|At most 8 colons permitted in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1142" {
  let source =
    #|At most 45 characters expected in '%s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1143" {
  let source =
    #|Exactly 8 parts expected without '::' in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1144" {
  let source =
    #|Expected at most 7 other parts with '::' in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1145" {
  let source =
    #|At most one '::' permitted in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1146" {
  let source =
    #|Leading ':' only permitted as part of '::' in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1147" {
  let source =
    #|Trailing ':' only permitted as part of '::' in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1148" {
  let source =
    #|Expected 4 octets in '1.net'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1149" {
  let source =
    #|Expected 4 octets in '127.0.1'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1150" {
  let source =
    #|Expected 4 octets in '1.2.3'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1151" {
  let source =
    #|Expected 4 octets in '1.2.3.4.5'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1152" {
  let source =
    #|Only decimal digits permitted in 'net' in '1.1.1.net'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1153" {
  let source =
    #|At most 4 characters permitted in %r in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1154" {
  let source =
    #|Only decimal digits permitted in %r in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1155" {
  let source =
    #|Octet %d (> 255) not permitted in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1156" {
  let source =
    #|Only hex digits permitted in %r in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1157" {
  let source =
    #|%r is not a valid netmask
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1158" {
  let source =
    #|1.0.0.127.in-addr.arpa
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1159" {
  let source =
    #|52.0.2.10.in-addr.arpa
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1160" {
  let source =
    #|Expected 4 octets in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1161" {
  let source =
    #|Empty octet not permitted in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1162" {
  let source =
    #|%s in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1163" {
  let source =
    #|Only one '/' permitted in %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1164" {
  let source =
    #|Regression test for bpo-30570.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1165" {
  let source =
    #|Test that an iterator is the same after pickling, also when part-consumed
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1166" {
  let source =
    #|Pure python version from cwr()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1167" {
  let source =
    #|Did not raise Type in:  
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1168" {
  let source =
    #|Unit tests for the keyword only argument specified in PEP 3102.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1169" {
  let source =
    #|() takes from 1 to 2 positional arguments but 3 were given
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1170" {
  let source =
    #|) for 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1171" {
  let source =
    #|Correctly-rounded true division for integers.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1172" {
  let source =
    #|float(shuge) should not equal int(shuge)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1173" {
  let source =
    #|Cannot specify ',' with 's'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1174" {
  let source =
    #|Error in conversion of integer {} to float.  Got {}, expected {}.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1175" {
  let source =
    #|expected underflow to 0 from %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1176" {
  let source =
    #|can't deal with %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1177" {
  let source =
    #|failed to convert {} with byteorder={} and signed={}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1178" {
  let source =
    #|Code equivalent from docs is not equivalent for conversion of {0} with byteorder byteorder={1} and signed={2}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1179" {
  let source =
    #|failed to convert {} with byteorder={!r} and signed={}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1180" {
  let source =
    #|Code equivalent from docs is not equivalent for conversion of {0} with byteorder={1!r} and signed={2}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1181" {
  let source =
    #|failed to convert {} with default arguments
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1182" {
  let source =
    #|Number of '1' bits in binary expansion of a nonnnegative integer.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1183" {
  let source =
    #|Test suite for the sys.monitoring.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1184" {
  let source =
    #|Test that the second tool can set events with instruction events set by the first tool.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1185" {
  let source =
    #|def spam(a = b := 42): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1186" {
  let source =
    #|def spam(a: b := 42 = 5): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1187" {
  let source =
    #|(x := lambda: y := 1)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1188" {
  let source =
    #|(lambda: x := 1)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1189" {
  let source =
    #|[i + 1 for i in i := [1,2]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1190" {
  let source =
    #|[i := 0, j := 1 for i, j in [(1, 2), (3, 4)]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1191" {
  let source =
    #|[x := i for i in range(3) if x or not x]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1192" {
  let source =
    #|[j for i in range(3) if x or not x for j in range(3) if (x := i)][:-3]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1193" {
  let source =
    #|{0}(c := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1194" {
  let source =
    #|{0}(d := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1195" {
  let source =
    #|{0}(e := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1196" {
  let source =
    #|{0}(f := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1197" {
  let source =
    #|{0}(g := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1198" {
  let source =
    #|{0}(h := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1199" {
  let source =
    #|{0}(i := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1200" {
  let source =
    #|{0}(j := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1201" {
  let source =
    #|{0}(a := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1202" {
  let source =
    #|{0}(b := 1) for a, (*b, c[d+e::f(g)], h.i) in j{1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1203" {
  let source =
    #|[i := 0 for i in range(5)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1204" {
  let source =
    #|[[(j := 0) for i in range(5)] for j in range(5)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1205" {
  let source =
    #|[(j := 0) for i in range(5) for j in range(5)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1206" {
  let source =
    #|[i := 0 for i, j in [(0, 1)]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1207" {
  let source =
    #|[i+1 for i in range(5) if (i := 0)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1208" {
  let source =
    #|[False or (i:=0) for i in range(5)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1209" {
  let source =
    #|[(i, j) for i in range(5) for j in range(5) if True or (i:=10)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1210" {
  let source =
    #|[i for i in range(5) if (j := 0) for j in range(5)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1211" {
  let source =
    #|[i for i in range(5) if (j := 0) for j, k in [(0, 1)]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1212" {
  let source =
    #|[i for i in (i := range(5))]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1213" {
  let source =
    #|[i for i in (2, 3, i := range(5))]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1214" {
  let source =
    #|[i for i in [2, 3, i := range(5)]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1215" {
  let source =
    #|[i for i in (j := range(5))]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1216" {
  let source =
    #|[i for i in (lambda:(j := range(5)))()]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1217" {
  let source =
    #|[i for i in range(5) for j in (i := range(5))]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1218" {
  let source =
    #|[i for i in [j for j in (k := range(5))]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1219" {
  let source =
    #|[i for i in [j for j in range(5) if (j := True)]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1220" {
  let source =
    #|[i for i in [(j := True) for j in range(5)]]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1221" {
  let source =
    #|{i := 0 for i in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1222" {
  let source =
    #|{{(j := 0) for i in range(5)} for j in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1223" {
  let source =
    #|{(j := 0) for i in range(5) for j in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1224" {
  let source =
    #|{i := 0 for i, j in {(0, 1)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1225" {
  let source =
    #|{i+1 for i in range(5) if (i := 0)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1226" {
  let source =
    #|{False or (i:=0) for i in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1227" {
  let source =
    #|{(i, j) for i in range(5) for j in range(5) if True or (i:=10)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1228" {
  let source =
    #|{(a := 1) for a, (*b, c[d+e::f(g)], h.i) in j}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1229" {
  let source =
    #|{(b := 1) for a, (*b, c[d+e::f(g)], h.i) in j}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1230" {
  let source =
    #|{i for i in range(5) if (j := 0) for j in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1231" {
  let source =
    #|{i for i in range(5) if (j := 0) for j, k in {(0, 1)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1232" {
  let source =
    #|{i for i in (i := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1233" {
  let source =
    #|{i for i in (2, 3, i := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1234" {
  let source =
    #|{i for i in {2, 3, i := range(5)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1235" {
  let source =
    #|{i for i in (j := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1236" {
  let source =
    #|{i for i in (lambda:(j := range(5)))()}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1237" {
  let source =
    #|{i for i in range(5) for j in (i := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1238" {
  let source =
    #|{i for i in {j for j in (k := range(5))}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1239" {
  let source =
    #|{i for i in {j for j in range(5) if (j := True)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1240" {
  let source =
    #|{i for i in {(j := True) for j in range(5)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1241" {
  let source =
    #|{(i := 0): 1 for i in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1242" {
  let source =
    #|{1: (i := 0) for i in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1243" {
  let source =
    #|{(i := 0): (i := 0) for i in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1244" {
  let source =
    #|{{(j := 0): 1 for i in range(5)} for j in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1245" {
  let source =
    #|{(j := 0): 1 for i in range(5) for j in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1246" {
  let source =
    #|{(i := 0): 1 for i, j in {(0, 1)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1247" {
  let source =
    #|{1: (i := 0) for i, j in {(0, 1)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1248" {
  let source =
    #|{i+1: 1 for i in range(5) if (i := 0)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1249" {
  let source =
    #|{(False or (i:=0)): 1 for i in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1250" {
  let source =
    #|{i: j for i in range(5) for j in range(5) if True or (i:=10)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1251" {
  let source =
    #|{(a := 1): 1 for a, (*b, c[d+e::f(g)], h.i) in j}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1252" {
  let source =
    #|{(b := 1): 1 for a, (*b, c[d+e::f(g)], h.i) in j}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1253" {
  let source =
    #|{i: 1 for i in range(5) if (j := 0) for j in range(5)}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1254" {
  let source =
    #|{i: 1 for i in range(5) if (j := 0) for j, k in {(0, 1)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1255" {
  let source =
    #|{i: 1 for i in (i := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1256" {
  let source =
    #|{i: 1 for i in (2, 3, i := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1257" {
  let source =
    #|{i: 1 for i in [2, 3, i := range(5)]}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1258" {
  let source =
    #|{i: 1 for i in (j := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1259" {
  let source =
    #|{i: 1 for i in (lambda:(j := range(5)))()}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1260" {
  let source =
    #|{i: 1 for i in range(5) for j in (i := range(5))}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1261" {
  let source =
    #|{i: 1 for i in {j: 2 for j in (k := range(5))}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1262" {
  let source =
    #|{i: 1 for i in {j: 2 for j in range(5) if (j := True)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1263" {
  let source =
    #|{i: 1 for i in {(j := True) for j in range(5)}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1264" {
  let source =
    #|result, x = (lambda x=1: (
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1265" {
  let source =
    #|Test pathname2url() and url2pathname()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1266" {
  let source =
    #|Dummy Integral class to test conversion of the Rational to float.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1267" {
  let source =
    #|got different hashes for {!r} and {!r}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1268" {
  let source =
    #|lambda: x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1269" {
  let source =
    #|Ensure that LOAD_SUPER_ATTR is specialized as expected.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1270" {
  let source =
    #|lambda: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1271" {
  let source =
    #|lambda a: a
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1272" {
  let source =
    #|lambda a=1: a
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1273" {
  let source =
    #|lambda: 0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1274" {
  let source =
    #|lambda: 1
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1275" {
  let source =
    #|lambda a: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1276" {
  let source =
    #|lambda b: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1277" {
  let source =
    #|lambda a=None: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1278" {
  let source =
    #|lambda a=0: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1279" {
  let source =
    #|lambda a=1: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1280" {
  let source =
    #|Test suite for OS X interpreter environment variables.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1281" {
  let source =
    #|expected %s not %s %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1282" {
  let source =
    #|'%s' % ()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"TypeError: not enough arguments for format string\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1283" {
  let source =
    #|'%s' % (x, y)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1284" {
  let source =
    #|'%s%' % (x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1285" {
  let source =
    #|'%s%%%' % (x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1286" {
  let source =
    #|'%s%z' % (x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1287" {
  let source =
    #|'%s%z' % (x, 5)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1288" {
  let source =
    #|'%d' % (x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1289" {
  let source =
    #|'%x' % (x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1290" {
  let source =
    #|'%f' % (x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1291" {
  let source =
    #|'%s, %s' % (x, *y)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1292" {
  let source =
    #|is not a valid BINARY_OP argument.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1293" {
  let source =
    #|Adding a docstring made this test fail in Py2.5.0
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1294" {
  let source =
    #|a in [1,2,3]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1295" {
  let source =
    #|a not in ["a","b","c"]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1296" {
  let source =
    #|a in [None, 1, None]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1297" {
  let source =
    #|a not in [(1, 2), 3, 4]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1298" {
  let source =
    #|a in {1,2,3}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1299" {
  let source =
    #|a not in {"a","b","c"}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1300" {
  let source =
    #|a in {None, 1, None}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1301" {
  let source =
    #|a not in {(1, 2), 3, 4}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1302" {
  let source =
    #|a in {1, 2, 3, 3, 2, 1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1303" {
  let source =
    #|a real number is required, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1304" {
  let source =
    #|an integer is required, not float
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1305" {
  let source =
    #|an integer is required, not str
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1306" {
  let source =
    #|Unit tests for the positional only argument syntax specified in PEP 570.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1307" {
  let source =
    #|def f(a, b = 5, /, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1308" {
  let source =
    #|def f(a = 5, b, /, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1309" {
  let source =
    #|def f(a = 5, b=1, /, c, *, d=2): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1310" {
  let source =
    #|def f(a = 5, b, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1311" {
  let source =
    #|def f(a, /, b = 5, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1312" {
  let source =
    #|def f(*args, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1313" {
  let source =
    #|def f(*args, a, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1314" {
  let source =
    #|def f(**kwargs, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1315" {
  let source =
    #|def f(/, a = 1): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1316" {
  let source =
    #|def f(/, a): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1317" {
  let source =
    #|def f(/): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1318" {
  let source =
    #|def f(*, a, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1319" {
  let source =
    #|def f(*, /, a): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1320" {
  let source =
    #|def f(a, b/2, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1321" {
  let source =
    #|def f(a, /, c, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1322" {
  let source =
    #|def f(a, /, c, /, d): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1323" {
  let source =
    #|def f(a, /, c, /, d, *, e): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1324" {
  let source =
    #|def f(a, *, c, /, d, e): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1325" {
  let source =
    #|async def f(a, b = 5, /, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1326" {
  let source =
    #|async def f(a = 5, b, /, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1327" {
  let source =
    #|async def f(a = 5, b=1, /, c, d=2): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1328" {
  let source =
    #|async def f(a = 5, b, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1329" {
  let source =
    #|async def f(a, /, b = 5, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1330" {
  let source =
    #|async def f(*args, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1331" {
  let source =
    #|async def f(*args, a, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1332" {
  let source =
    #|async def f(**kwargs, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1333" {
  let source =
    #|async def f(/, a = 1): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1334" {
  let source =
    #|async def f(/, a): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1335" {
  let source =
    #|async def f(/): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1336" {
  let source =
    #|async def f(*, a, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1337" {
  let source =
    #|async def f(*, /, a): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1338" {
  let source =
    #|async def f(a, b/2, c): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1339" {
  let source =
    #|async def f(a, /, c, /): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1340" {
  let source =
    #|async def f(a, /, c, /, d): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1341" {
  let source =
    #|async def f(a, /, c, /, d, *, e): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1342" {
  let source =
    #|async def f(a, *, c, /, d, e): pass
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1343" {
  let source =
    #|lambda a, b = 5, /, c: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1344" {
  let source =
    #|lambda a = 5, b, /, c: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1345" {
  let source =
    #|lambda a = 5, b=1, /, c, *, d=2: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1346" {
  let source =
    #|lambda a = 5, b, /: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1347" {
  let source =
    #|lambda a, /, b = 5, c: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1348" {
  let source =
    #|lambda *args, /: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1349" {
  let source =
    #|lambda *args, a, /: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1350" {
  let source =
    #|lambda **kwargs, /: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1351" {
  let source =
    #|lambda /, a = 1: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1352" {
  let source =
    #|lambda /, a: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1353" {
  let source =
    #|lambda /: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1354" {
  let source =
    #|lambda *, a, /: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1355" {
  let source =
    #|lambda *, /, a: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1356" {
  let source =
    #|lambda a, /, a: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1357" {
  let source =
    #|lambda a, /, *, a: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1358" {
  let source =
    #|lambda a, /, b, /: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1359" {
  let source =
    #|lambda a, /, b, /, c: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1360" {
  let source =
    #|lambda a, /, b, /, c, *, d: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1361" {
  let source =
    #|lambda a, *, b, /, c: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1362" {
  let source =
    #|f\(\) missing 2 required positional arguments: 'b' and 'c'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1363" {
  let source =
    #|f\(\) missing 3 required positional arguments: 'a', 'b', and 'c'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1364" {
  let source =
    #|f\(\) missing 2 required positional arguments: 'a' and 'b'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1365" {
  let source =
    #|f\(\) takes from 2 to 3 positional arguments but 4 were given
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1366" {
  let source =
    #|missing 2 required keyword-only arguments: 'd' and 'e'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1367" {
  let source =
    #|missing 3 required positional arguments: 'a', 'b', and 'c'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1368" {
  let source =
    #|f\(\) takes 3 positional arguments but 6 positional arguments \(and 2 keyword-only arguments\) were given
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1369" {
  let source =
    #|f\(\) takes from 1 to 2 positional arguments but 3 were given
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1370" {
  let source =
    #|for i in s: print i
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1371" {
  let source =
    #|Missing parentheses in call to 'print'. Did you mean print(...)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1372" {
  let source =
    #|Getter docstring is not picked-up (%s)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1373" {
  let source =
    #|Property class doc appears in instance __doc__ (%s)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1374" {
  let source =
    #|Does not have getpwall()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1375" {
  let source =
    #|passwd file is huge; extended test skipped
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1376" {
  let source =
    #|succeed iff key in obj or key in ignore. 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1377" {
  let source =
    #|succeed iff a == b or a in ignore or b in ignore 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1378" {
  let source =
    #|built-in
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1379" {
  let source =
    #|class=%s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1380" {
  let source =
    #|Run test code and return the value of the "set_class" stats counter.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1381" {
  let source =
    #|q.join() did not block until all tasks were done
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1382" {
  let source =
    #|Didn't appear to time-out with a full queue
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1383" {
  let source =
    #|Didn't appear to time-out with an empty queue
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1384" {
  let source =
    #|blocking function %r appeared not to block
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1385" {
  let source =
    #|Tests for the raise statement.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1386" {
  let source =
    #|Cannot use capturing groups in re\.Scanner
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1387" {
  let source =
    #|bad character in group name 'a.'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1388" {
  let source =
    #|bad character in group name '-1'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1389" {
  let source =
    #|bad character in group name '+1'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1390" {
  let source =
    #|bad inline flags: cannot turn off flags 'a', 'u' and 'L'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1391" {
  let source =
    #|bad inline flags: flag turned on and off
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1392" {
  let source =
    #|bad inline flags: flags 'a', 'u' and 'L' are incompatible
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1393" {
  let source =
    #|missing -, : or )
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1394" {
  let source =
    #|bad character in group name '<foo>'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1395" {
  let source =
    #|re.compile('both \'single\' and "double" quotes')
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 're' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1396" {
  let source =
    #|sub\(\) got multiple values for argument 'count'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1397" {
  let source =
    #|sub\(\) got multiple values for argument 'flags'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1398" {
  let source =
    #|sub\(\) takes from 3 to 5 positional arguments but 6 were given
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1399" {
  let source =
    #|subn\(\) got multiple values for argument 'count'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1400" {
  let source =
    #|subn\(\) got multiple values for argument 'flags'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1401" {
  let source =
    #|subn\(\) takes from 3 to 5 positional arguments but 6 were given
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1402" {
  let source =
    #|split\(\) got multiple values for argument 'maxsplit'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1403" {
  let source =
    #|split\(\) got multiple values for argument 'flags'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1404" {
  let source =
    #|split\(\) takes from 2 to 4 positional arguments but 5 were given
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1405" {
  let source =
    #|(?is).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1406" {
  let source =
    #|If match is not None, span should be specified (and vice versa).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1407" {
  let source =
    #|'<' .* of 'int' and 'NoneType'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1408" {
  let source =
    #|'<' .* of 'NoneType' and 'int'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1409" {
  let source =
    #|'>' .* of 'int' and 'NoneType'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1410" {
  let source =
    #|'<' .* of 'str' and 'NoneType'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1411" {
  let source =
    #|'>=' .* of 'str' and 'int'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1412" {
  let source =
    #|'<=' .* of 'int' and 'NoneType'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1413" {
  let source =
    #|'>=' .* of 'int' and 'NoneType'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1414" {
  let source =
    #|'<' .* of 'int' and 'list'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1415" {
  let source =
    #|'>' .* of 'tuple' and 'list'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1416" {
  let source =
    #|'>=' .* of 'NoneType' and 'NoneType'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1417" {
  let source =
    #|'<' .* of 'Spam' and 'int'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1418" {
  let source =
    #|'<' .* of 'int' and 'Spam'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1419" {
  let source =
    #|'<=' .* of 'Spam' and 'Spam'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1420" {
  let source =
    #|Trivial class used in testing rlcompleter.Completer. 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1421" {
  let source =
    #|Ensure getattr() is invoked no more than once per attribute
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1422" {
  let source =
    #|x + 1
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1423" {
  let source =
    #|%s cannot be called with no argument
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1424" {
  let source =
    #|%s cannot be called with None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1425" {
  let source =
    #|Unexpected return values from select():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1426" {
  let source =
    #|int-like object that counts the number of times __hash__ is called
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1427" {
  let source =
    #|SF 628246:  Set constructor should not trap iterator TypeErrors
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1428" {
  let source =
    #|Regression test for bpo-46615
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1429" {
  let source =
    #|Generates all subsets of a set or sequence U.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1430" {
  let source =
    #|Return a set of faces in G.  Where a face is a set of vertices on that face
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1431" {
  let source =
    #|s|t did not screen-out general iterables
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1432" {
  let source =
    #|s&t did not screen-out general iterables
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1433" {
  let source =
    #|s-t did not screen-out general iterables
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1434" {
  let source =
    #|s^t did not screen-out general iterables
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1435" {
  let source =
    #|KeyError should be {0}, not {1}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1436" {
  let source =
    #|Reference implementation for the slice.indices method.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1437" {
  let source =
    #|incompatible with Py_TRACE_REFS.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1438" {
  let source =
    #|Return -1.0 for negatives, including -0.0, otherwise +1.0.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1439" {
  let source =
    #|Used for doctest/unittest integration.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1440" {
  let source =
    #|approx_equal comparisons don't match for %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1441" {
  let source =
    #|Test failure for x={!r}, y={!r}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1442" {
  let source =
    #|Return substrings we expect to see in error messages.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1443" {
  let source =
    #|Assert that coercing A to B, or vice versa, raises TypeError.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1444" {
  let source =
    #|Check that type T coerces correctly with subclasses of itself.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1445" {
  let source =
    #|Check that x equals y, and has the same type as well.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1446" {
  let source =
    #|Return int data for various tests.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1447" {
  let source =
    #|Check x is an infinity of the same type and sign as inf.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1448" {
  let source =
    #|Overload method from UnivariateCommonMixin.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1449" {
  let source =
    #|Numerical integration cross-check for overlap() 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1450" {
  let source =
    #|sequences differ in length: %d items != %d items
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1451" {
  let source =
    #|equality failure for x=%r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1452" {
  let source =
    #|inequality failure for x=%r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1453" {
  let source =
    #|private name "%s" in __all__
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1454" {
  let source =
    #|'\Ufffffffe'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1455" {
  let source =
    #|'\Uffffffff'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1456" {
  let source =
    #|My name is Fred :-{}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1457" {
  let source =
    #|abc, def
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1458" {
  let source =
    #|%X format: an integer is required, not float
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1459" {
  let source =
    #|%o format: an integer is required, not float
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1460" {
  let source =
    #|%x format: an integer is required, not PseudoFloat
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1461" {
  let source =
    #|%x format: an integer is required, not complex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1462" {
  let source =
    #|%X format: an integer is required, not complex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1463" {
  let source =
    #|%o format: an integer is required, not complex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1464" {
  let source =
    #|%u format: a real number is required, not complex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1465" {
  let source =
    #|%i format: a real number is required, not complex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1466" {
  let source =
    #|%d format: a real number is required, not complex
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1467" {
  let source =
    #|%c requires an int or a unicode character, not .*\.PseudoFloat
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1468" {
  let source =
    #|unicode(obj) is compatible to str()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1469" {
  let source =
    #|Item 3 is 1.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1470" {
  let source =
    #|str\(\) argument 'encoding' must be str, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1471" {
  let source =
    #|str\(\) argument 'encoding' must be str, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1472" {
  let source =
    #|str\(\) argument 'errors' must be str, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1473" {
  let source =
    #|str\(\) argument 'errors' must be str, not bytes
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1474" {
  let source =
    #|argument for str\(\) given by name \('encoding'\) and position \(2\)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1475" {
  let source =
    #|My name is {0}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1476" {
  let source =
    #|My name is {0[name]}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1477" {
  let source =
    #|My name is {0} :-{{}}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1478" {
  let source =
    #|The year is {0.year}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1479" {
  let source =
    #|{!a} is not title
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1480" {
  let source =
    #|{!a} is not space.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1481" {
  let source =
    #|{!a} is alnum.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1482" {
  let source =
    #|{!a} is not decimal.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1483" {
  let source =
    #|{!a} is decimal.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1484" {
  let source =
    #|{!a} is not a digit.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1485" {
  let source =
    #|{!a} is a digit.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1486" {
  let source =
    #|{!a} is not numeric.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1487" {
  let source =
    #|{!a} is numeric.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1488" {
  let source =
    #|%a.%s() is False
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1489" {
  let source =
    #|Unittest for time.strftime
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1490" {
  let source =
    #|strftime does not support standard '%s' format (%s)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1491" {
  let source =
    #|Conflict for %s (%s): expected %s, but got %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1492" {
  let source =
    #|Error for nonstandard '%s' format (%s): %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1493" {
  let source =
    #|Does not appear to support '%s' format (%s)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1494" {
  let source =
    #|Conflict for nonstandard '%s' format (%s):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1495" {
  let source =
    #|correctly-rounded string->float conversions not available on this system
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1496" {
  let source =
    #|Long string with value 1.0 and exponent n
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1497" {
  let source =
    #|Long string with value 1.0 and exponent -n
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1498" {
  let source =
    #|Incorrectly rounded str->float conversion for {}: expected {}, got {}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1499" {
  let source =
    #|Tests for iterative unpacking (struct.Struct.iter_unpack).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1500" {
  let source =
    #|pack_into requires a buffer of at least 6 bytes for packing 1 bytes at offset 5 \(actual buffer size is 1\)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1501" {
  let source =
    #|unpack_from requires a buffer of at least 6 bytes for unpacking 1 bytes at offset 5 \(actual buffer size is 1\)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1502" {
  let source =
    #|\(actual buffer size is 10\)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1503" {
  let source =
    #|offset -11 out of range for 10-byte buffer
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1504" {
  let source =
    #|not enough data to unpack 4 bytes at offset -2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1505" {
  let source =
    #|encoded bool is not one byte: %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1506" {
  let source =
    #|Unit tests for zero-argument super() & related machinery.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1507" {
  let source =
    #|__class__ not set.*__classcell__ propagated
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1508" {
  let source =
    #|super\(type, obj\): obj \({} {}\) is not an instance or subtype of type \({}\).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1509" {
  let source =
    #|expected expression after 'else', but statement is given
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1510" {
  let source =
    #|expected expression before 'if', but statement is given
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1511" {
  let source =
    #|del (,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1512" {
  let source =
    #|del (1, 2)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1513" {
  let source =
    #|del *x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1514" {
  let source =
    #|del (*x)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1515" {
  let source =
    #|del (*x,)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1516" {
  let source =
    #|del [*x,]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1517" {
  let source =
    #|del f()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1518" {
  let source =
    #|del f(a, b)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1519" {
  let source =
    #|del o.f()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1520" {
  let source =
    #|del a[0]()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1521" {
  let source =
    #|del x, f()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1522" {
  let source =
    #|del f(), x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1523" {
  let source =
    #|del [a, b, ((c), (d,), e.f())]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1524" {
  let source =
    #|del (a if True else b)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1525" {
  let source =
    #|del +a
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1526" {
  let source =
    #|del a, +b
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1527" {
  let source =
    #|del a + b
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1528" {
  let source =
    #|del (a + b, c)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1529" {
  let source =
    #|del (c[0], a + b)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1530" {
  let source =
    #|del a.b.c + 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1531" {
  let source =
    #|del a.b.c[0] + 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1532" {
  let source =
    #|del (a, b, (c, d.e.f + 2))
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1533" {
  let source =
    #|del [a, b, (c, d.e.f[0] + 2)]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1534" {
  let source =
    #|del (a := 5)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1535" {
  let source =
    #|del a += b
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1536" {
  let source =
    #|unindent does not match .* level
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1537" {
  let source =
    #|foo(x,    y for y in range(3) for z in range(2) if z    , p)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1538" {
  let source =
    #|cannot have both 'except' and 'except\*' on the same 'try'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1539" {
  let source =
    #|): yield a
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1540" {
  let source =
    #|parenthesis '\)' does not match opening parenthesis '\['
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1541" {
  let source =
    #|compile() did not raise SyntaxError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1542" {
  let source =
    #|except Exception as e:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1543" {
  let source =
    #|Empty line after a line continuation character is valid.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1544" {
  let source =
    #|x = 1 if 1 else 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1545" {
  let source =
    #|SyntaxError is not a %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'SyntaxError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1546" {
  let source =
    #|SyntaxError did not contain %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1547" {
  let source =
    #|Parent class with utility methods for textwrap tests.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1548" {
  let source =
    #|File stdio.h is nice.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1549" {
  let source =
    #|This is a short line.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1550" {
  let source =
    #|this-is-a-useful-feature-for-reformatting-posts-from-tim-peters'ly
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1551" {
  let source =
    #|You can also do--this or even---this.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1552" {
  let source =
    #|Here's an -- em-dash and--here's another---and another!
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1553" {
  let source =
    #|and then--bam!--he was gone
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1554" {
  let source =
    #|You should use the -n option, or --dry-run in its long form.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1555" {
  let source =
    #|the -n option, or --dry-run or --dryrun
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1556" {
  let source =
    #|This is a    sentence with     much whitespace.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1557" {
  let source =
    #|This is a sentence with leading whitespace.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1558" {
  let source =
    #|This is a sentence with non-breakingspace.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1559" {
  let source =
    #|This is a sentence with non-breakingspace.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1560" {
  let source =
    #|assert that dedent() has no effect on 'text'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1561" {
  let source =
    #|I say, chaps!  Anyone for "tennis?"  Hmmph!
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1562" {
  let source =
    #|--this or even
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'this' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1563" {
  let source =
    #|this or even---
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1564" {
  let source =
    #|You can also do--this or even
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1565" {
  let source =
    #|You can also do--this or even---
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1566" {
  let source =
    #|You should use the -n option, or
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1567" {
  let source =
    #|--dry-run in its long form.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1568" {
  let source =
    #|You should use the -n option, or --dry-
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1569" {
  let source =
    #|run in its long form.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1570" {
  let source =
    #|You should use the -n option, or --dry-run
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1571" {
  let source =
    #|in its long form.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1572" {
  let source =
    #|first without any indentation, and then
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1573" {
  let source =
    #|with some (including a hanging indent).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1574" {
  let source =
    #|This is a paragraph that already has line breaks and tabs too.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1575" {
  let source =
    #|This is a paragraph that already has line breaks and [...]
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1576" {
  let source =
    #|This is a short paragraph.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1577" {
  let source =
    #|(1) This is a short line.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1578" {
  let source =
    #|this-is-a-useful-feature-for-
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1579" {
  let source =
    #|reformatting-posts-from-tim-peters'ly
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1580" {
  let source =
    #|this-is-a-useful-feature-for-reformatting-
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1581" {
  let source =
    #|posts-from-tim-peters'ly
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1582" {
  let source =
    #|this-|is-|a-|useful-|feature-|for-|reformatting-|posts-|from-|tim-|peters'ly
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1583" {
  let source =
    #|-n option, or --dry-
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1584" {
  let source =
    #|option, or --dry-run
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1585" {
  let source =
    #|with non-
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1586" {
  let source =
    #|expected str object, not
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1587" {
  let source =
    #|Tests for thread-local bytecode.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1588" {
  let source =
    #|only in free-threaded builds
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1589" {
  let source =
    #|No error message set or cleared.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1590" {
  let source =
    #|Incorrectly got value %r from class %r
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1591" {
  let source =
    #|Base class to test the C _PyTime_t API.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1592" {
  let source =
    #|disabled because of a bug in glibc. Issue #13309
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1593" {
  let source =
    #|strftime() does not support year 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1594" {
  let source =
    #|conversion specifier %r failed with '%s' input.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1595" {
  let source =
    #|Unit tests for socket timeout feature.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1596" {
  let source =
    #|Test case for socket.gettimeout() and socket.settimeout()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1597" {
  let source =
    #|TCP test case for socket.socket() timeout functions
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1598" {
  let source =
    #|UDP test case for socket.socket() timeout functions
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1599" {
  let source =
    #|We didn't receive a connection reset (RST) packet from {}:{} within {} seconds, so we're unable to test connect timeout against the corresponding {}:{} (which is configured to silently drop packets).
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1600" {
  let source =
    #|t'{num!z}'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1601" {
  let source =
    #|t'Hello, {name}'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1602" {
  let source =
    #|{abc def}
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1603" {
  let source =
    #|class X:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1604" {
  let source =
    #|async def f():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1605" {
  let source =
    #|class X: 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1606" {
  let source =
    #|def f(): 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1607" {
  let source =
    #|async def f(): 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1608" {
  let source =
    #|__annotate__\(\) must return a dict, not int
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1609" {
  let source =
    #|class C:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1610" {
  let source =
    #|class Cls:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1611" {
  let source =
    #|Tests for the internal type cache in CPython. 
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1612" {
  let source =
    #|meta-test for type_assign_specific_version_unsafe
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1613" {
  let source =
    #|Unit tests for __instancecheck__ and __subclasscheck__.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1614" {
  let source =
    #|Test compiler changes for unary ops (+, -, ~) introduced in Python 2.2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1615" {
  let source =
    #|SyntaxError: (unicode error) \N escapes not supported (can't load unicodedata module)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1616" {
  let source =
    #|%a should not be a linebreak
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1617" {
  let source =
    #|def unpack_400(x):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1618" {
  let source =
    #|Tests for ast.unparse.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1619" {
  let source =
    #|class foo:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1620" {
  let source =
    #|def foo():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1621" {
  let source =
    #|async def foo():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1622" {
  let source =
    #|Test roundtrip behaviour on all files in Lib and Lib/test.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1623" {
  let source =
    #|f" something { my_dict["key"] } something else "
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'my_dict' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1624" {
  let source =
    #|t'{(lambda x: x)}'
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1625" {
  let source =
    #|(lambda: int)()
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1626" {
  let source =
    #|def x(y):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1627" {
  let source =
    #|async def x():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1628" {
  let source =
    #|async def x(y):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1629" {
  let source =
    #|for x in y:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1630" {
  let source =
    #|async for x in y:
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1631" {
  let source =
    #|with x():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1632" {
  let source =
    #|async with x():
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1633" {
  let source =
    #|def f(a):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1634" {
  let source =
    #|def f(b=2):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1635" {
  let source =
    #|def f(a, b):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1636" {
  let source =
    #|def f(a, b=2):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1637" {
  let source =
    #|def f(a=5, b=2):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1638" {
  let source =
    #|def f(*, a=1, b=2):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1639" {
  let source =
    #|def f(*, a=1, b):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1640" {
  let source =
    #|def f(*, a, b=2):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1641" {
  let source =
    #|def f(a, b=None, *, c, **kwds):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1642" {
  let source =
    #|def f(a=2, *args, c=5, d, **kwds):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1643" {
  let source =
    #|def f(*args, **kwargs):
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1644" {
  let source =
    #|lambda x: x
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1645" {
  let source =
    #|x and (y and x)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1646" {
  let source =
    #|(x and y) and z
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1647" {
  let source =
    #|x >> y and x >> z
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1648" {
  let source =
    #|P * V if P and V else n * R * T
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'P' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1649" {
  let source =
    #|lambda P, V, n: P * V == n * R * T
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1650" {
  let source =
    #|not x == y
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1651" {
  let source =
    #|x == (not y)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1652" {
  let source =
    #|call((yield x))
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1653" {
  let source =
    #|lambda: something
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1654" {
  let source =
    #|lambda x: x * 2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1655" {
  let source =
    #|lambda x, y: x + y
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1656" {
  let source =
    #|lambda x, y, /, z, q, *, u: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1657" {
  let source =
    #|lambda x, *y, **z: None
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"ValueError: unsupported value\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1658" {
  let source =
    #|"\ " is an invalid escape sequence. Such sequences will not work in the future. Did you mean "\\ "? A raw string is also an option.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1659" {
  let source =
    #|Unit tests for code in urllib.response.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1660" {
  let source =
    #|Testcase to test the various utility functions in the urllib.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1661" {
  let source =
    #|urllib.parse.splittype() is deprecated as of 3.8, use urllib.parse.urlparse() instead
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1662" {
  let source =
    #|urllib.parse.splithost() is deprecated as of 3.8, use urllib.parse.urlparse() instead
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1663" {
  let source =
    #|urllib.parse.splituser() is deprecated as of 3.8, use urllib.parse.urlparse() instead
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1664" {
  let source =
    #|urllib.parse.splitpasswd() is deprecated as of 3.8, use urllib.parse.urlparse() instead
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1665" {
  let source =
    #|urllib.parse.splitport() is deprecated as of 3.8, use urllib.parse.urlparse() instead
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1666" {
  let source =
    #|urllib.parse.splitnport() is deprecated as of 3.8, use urllib.parse.urlparse() instead
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1667" {
  let source =
    #|urllib.parse.splitquery() is deprecated as of 3.8, use urllib.parse.urlparse() instead
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1668" {
  let source =
    #|urllib.parse.splittag() is deprecated as of 3.8, use urllib.parse.urlparse() instead
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1669" {
  let source =
    #|urllib.parse.splitattr() is deprecated as of 3.8, use urllib.parse.urlparse() instead
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1670" {
  let source =
    #|urllib.parse.splitvalue() is deprecated as of 3.8, use urllib.parse.parse_qsl() instead
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1671" {
  let source =
    #|urllib.parse.to_bytes() is deprecated as of 3.8
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1672" {
  let source =
    #|e[42] didn't raise RuntimeError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1673" {
  let source =
    #|f[42] didn't raise KeyError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1674" {
  let source =
    #|g[42] didn't raise KeyError
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1675" {
  let source =
    #|value is %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1676" {
  let source =
    #|Ensure GC collections happen in a different thread, at a high frequency.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1677" {
  let source =
    #|<ref>() should return original object if live
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1678" {
  let source =
    #|proxy for non-empty UserList should be true
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1679" {
  let source =
    #|callbacks were NULL, None in the C API
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1680" {
  let source =
    #|callbacks were None, NULL in the C API
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1681" {
  let source =
    #|weak reference objects not unlinked from referent when discarded.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1682" {
  let source =
    #|cloning of weak-valued dictionary did not work!
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1683" {
  let source =
    #|cloning of weak-keyed dictionary did not work!
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1684" {
  let source =
    #|items() did not touch all items
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1685" {
  let source =
    #|__iter__() did not touch all keys
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1686" {
  let source =
    #|iterkeys() did not touch all keys
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1687" {
  let source =
    #|itervalues() did not touch all values
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1688" {
  let source =
    #|Unit tests for the 'with/async with' statements specified in PEP 343/492.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1689" {
  let source =
    #|object does not support the context manager protocol (missed __exit__ method)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1690" {
  let source =
    #|object does not support the asynchronous context manager protocol (missed __aexit__ method)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1691" {
  let source =
    #|object does not support the context manager protocol (missed __enter__ method)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1692" {
  let source =
    #|object does not support the context manager protocol (missed __exit__ method) but it supports the asynchronous context manager protocol. Did you mean to use 'async with'?
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1693" {
  let source =
    #|object does not support the asynchronous context manager protocol (missed __aenter__ method)
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1694" {
  let source =
    #|object does not support the asynchronous context manager protocol (missed __aexit__ method) but it supports the context manager protocol. Did you mean to use 'with'?
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1695" {
  let source =
    #|not select, just in case someone tries something
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1696" {
  let source =
    #|Tests for the EmptyNodeList class.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1697" {
  let source =
    #|Tests for the NodeList class.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1698" {
  let source =
    #|This is only a regression test: Check that it doesn't crash.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1699" {
  let source =
    #|Test raising exception in initial next() call
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1700" {
  let source =
    #|Test raising exception in delegated next() call
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1701" {
  let source =
    #|Test exception in initial next() call
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1702" {
  let source =
    #|Test attempted yield-from loop
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1703" {
  let source =
    #|g1: about to yield from g2
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1704" {
  let source =
    #|g2: about to yield from g1
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1705" {
  let source =
    #|Should not have yielded: %s
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1706" {
  let source =
    #|Mixin class for testing checksum combination.
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1707" {
  let source =
    #|Error -5 while decompressing data: incomplete or truncated stream
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1708" {
  let source =
    #|(B) uct should be b'': not %d long
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/expr/1709" {
  let source =
    #|(A) uct should be b'': not %d long
  let result = Interpreter::new_spec().eval_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0001" {
  let source =
    #|x = [0, 1]
    #|i = 0
    #|i, x[i] = 1, 2         # i is updated, then x[i] is updated
    #|print(x)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"[0, 2]\\n\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0002" {
  let source =
    #|for i in range(10):
    #|    print(i)
    #|    i = 5             # this will not affect the for-loop
    #|                      # because i will be overwritten with the next
    #|                      # index in the range
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"0\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0003" {
  let source =
    #|flag = False
    #|match (100, 200):
    #|   case (100, 300):  # Mismatch: 200 != 300
    #|       print('Case 1')
    #|   case (100, 200) if flag:  # Successful match, but guard fails
    #|       print('Case 2')
    #|   case (100, y):  # Matches and binds y to 200
    #|       print(f'Case 3, y: {y}')
    #|   case _:  # Pattern not attempted
    #|       print('Case 4, I match anything!')
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"Case 3, y: 200\\n\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0004" {
  let source =
    #|a = ["a", "b", "c"]
    #|print(f"List a contains:\n{"\n".join(a)}")
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"List a contains:\\na\\nb\\nc\\n\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0005" {
  let source =
    #|i = 10
    #|def f():
    #|    print(i)
    #|i = 42
    #|f()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"42\\n\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0006" {
  let source =
    #|def gen():  # defines a generator function
    #|    yield 123
    #|
    #|async def agen(): # defines an asynchronous generator function
    #|    yield 123
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0007" {
  let source =
    #|type Point = tuple[float, float]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0008" {
  let source =
    #|def f():
    #|    try:
    #|        1/0
    #|    finally:
    #|        return 42
    #|f()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0009" {
  let source =
    #|def foo():
    #|    try:
    #|        return 'try'
    #|    finally:
    #|        return 'finally'
    #|foo()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0010" {
  let source =
    #|def whats_on_the_telly(penguin=None):
    #|    if penguin is None:
    #|        penguin = []
    #|    penguin.append("property of the zoo")
    #|    return penguin
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0011" {
  let source =
    #|async def func(param1, param2):
    #|    do_stuff()
    #|    await some_coroutine()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0012" {
  let source =
    #|def func[T](arg: T): ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0013" {
  let source =
    #|type ListOrSet[T] = list[T] | set[T]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0014" {
  let source =
    #|def __hash__(self):
    #|    return hash((self.name, self.nick, self.color))
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0015" {
  let source =
    #|month_names = ['Januari', 'Februari', 'Maart',      # These are the
    #|               'April',   'Mei',      'Juni',       # Dutch names
    #|               'Juli',    'Augustus', 'September',  # for the months
    #|               'Oktober', 'November', 'December']   # of the year
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0016" {
  let source =
    #|a = dict(x=2)
    #|f"abc {a["x"]} def"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0017" {
  let source =
    #|def foo():
    #|    f"Not a docstring"
    #|foo.__doc__ is None
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0018" {
  let source =
    #|pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0019" {
  let source =
    #|res = "str_value"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0020" {
  let source =
    #|res = ("str_value",)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0021" {
  let source =
    #|res = "str\0value!"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0022" {
  let source =
    #|a = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0023" {
  let source =
    #|def f(): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0024" {
  let source =
    #|try:
    #|    1/0
    #|except Exception as e:
    #|    exc = e
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0025" {
  let source =
    #|def func1():
    #|    return (0.0, (1, 2, "hello"))
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0026" {
  let source =
    #|def func2():
    #|    return (0.0, (1, 2, "hello"))
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0027" {
  let source =
    #|def x():
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0028" {
  let source =
    #|if 1:
    #| pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0029" {
  let source =
    #|if 1: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0030" {
  let source =
    #|def x():
    #|
    #| pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0031" {
  let source =
    #|if 9==3:
    #|   pass
    #|else:
    #|   pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0032" {
  let source =
    #|if 1:
    #| pass
    #| if 1:
    #|  pass
    #| else:
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0033" {
  let source =
    #|#a
    #|#b
    #|a = 3
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0034" {
  let source =
    #|#a
    #|
    #|
    #|a=3
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0035" {
  let source =
    #|a = 9+ \
    #|3
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0036" {
  let source =
    #|(lambda z: 
    #| z**3)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0037" {
  let source =
    #|9+ \
    #|3
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0038" {
  let source =
    #|if 1: a=1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0039" {
  let source =
    #|def f():
    #| try: pass
    #| finally: [x for x in (1,2)]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0040" {
  let source =
    #|def f():
    #| pass
    #|#foo
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0041" {
  let source =
    #|def f(x):
    #|    return x + 42
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0042" {
  let source =
    #|def f():
    #|    def h():
    #|        return 12
    #|    def g():
    #|        x = 1
    #|        y = 2
    #|        z = 3
    #|        u = 4
    #|        return 42
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0043" {
  let source =
    #|async def foo():
    #|    return
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0044" {
  let source =
    #|
    #|try:
    #|    raise Exception
    #|except Exception as exc:
    #|    TRACEBACK = exc.__traceback__
    #|    FRAME = TRACEBACK.tb_frame
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0045" {
  let source =
    #|if True:
    #|            try:
    #|                raise Exception
    #|            except Exception as exc:
    #|                TRACEBACK = exc.__traceback__
    #|                FRAME = TRACEBACK.tb_frame
    #|            
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0046" {
  let source =
    #|try:
    #|    raise Exception
    #|except Exception as exc:
    #|    TRACEBACK = exc.__traceback__
    #|    FRAME = TRACEBACK.tb_frame
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0047" {
  let source =
    #|if True:
    #|            try:
    #|                raise Exception
    #|            except Exception as exc:
    #|                TRACEBACK = exc.__traceback__
    #|                FRAME = TRACEBACK.tb_frame
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0048" {
  let source =
    #|def f(): pass
    #|f.__name__
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0049" {
  let source =
    #|'docstring'
    #|x: int = 5
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0050" {
  let source =
    #|x: tuple = 1, 2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0051" {
  let source =
    #|assert(False, "msg")
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0052" {
  let source =
    #|assert(False,)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0053" {
  let source =
    #|[(lambda x, y: x) (3, 4)]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0054" {
  let source =
    #|[[1, 2] [0]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0055" {
  let source =
    #|[[1, 2] [True]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0056" {
  let source =
    #|[[1, 2] [1:2]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0057" {
  let source =
    #|items = [(lambda i=i: i) for i in range(5)]
    #|y = [x() for x in items]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0058" {
  let source =
    #|items = [(lambda: i) for i in range(5)]
    #|y = [x() for x in items]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0059" {
  let source =
    #|__class__ = 2
    #|res = [__class__ for x in [1]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0060" {
  let source =
    #|items = [(lambda: i) for i in range(5)]
    #|i = 20
    #|y = [x() for x in items]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0061" {
  let source =
    #|def f(x):
    #|    return [lambda: x for x in range(x)], x
    #|fns, x = f(2)
    #|y = [fn() for fn in fns]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0062" {
  let source =
    #|items = [(lambda: y) for i in range(5)]
    #|y = 2
    #|z = [x() for x in items]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0063" {
  let source =
    #|def f():
    #|    return [lambda: x for x in (x, [1])[1]]
    #|x = ...
    #|y = [fn() for fn in f()]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0064" {
  let source =
    #|g = 2
    #|def f():
    #|    return g
    #|y = [g for x in [1]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0065" {
  let source =
    #|y = 10
    #|items = [(lambda: y) for y in range(5)]
    #|x = y
    #|y = 20
    #|out = [z() for z in items]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0066" {
  let source =
    #|global g
    #|fns = [lambda: g for g in [2]]
    #|items = [fn() for fn in fns]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0067" {
  let source =
    #|x = -1
    #|items = [(x:=y) for y in range(3)]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0068" {
  let source =
    #|lst = range(3)
    #|funcs = [lambda: x for x in lst]
    #|inc = [x + 1 for x in lst]
    #|[x for x in inc]
    #|x = funcs[0]()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0069" {
  let source =
    #|lst = range(3)
    #|x = -1
    #|funcs = [lambda: x for x in lst]
    #|items = [x + 1 for x in lst]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0070" {
  let source =
    #|x = [1]
    #|y = [x for x in x]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0071" {
  let source =
    #|x = 1
    #|def g():
    #|    [x for x in range(3)]
    #|    return x
    #|g()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0072" {
  let source =
    #|l = [2, 3]
    #|y = [[x ** 2 for x in range(x)] for x in l]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0073" {
  let source =
    #|l = [1, 2, 3]
    #|x = 3
    #|y = [x for [x ** x for x in range(x)][x - 1] in l]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0074" {
  let source =
    #|l = [(1, 2), (3, 4), (5, 6)]
    #|y = [x for (x, [x ** x for x in range(x)][x - 1]) in l]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0075" {
  let source =
    #|items = [([lambda: x for x in range(2)], lambda: x) for x in range(3)]
    #|out = [([fn() for fn in fns], fn()) for fns, fn in items]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0076" {
  let source =
    #|y = [__x for __x in [1]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0077" {
  let source =
    #|y = 1
    #|[x + y for x in range(2)]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0078" {
  let source =
    #|y = 2
    #|vals = [(x, y) for x in range(2)]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0079" {
  let source =
    #|items = [a for a in [1] if [a for _ in [0]]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0080" {
  let source =
    #|z = 1
    #|items = [a for a in [1] if [x for x in [1] if z]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0081" {
  let source =
    #|items = [_C for _C in [1] for [0, 1][[x for x in [1] if _C][0]] in [2]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0082" {
  let source =
    #|items = [(_C, [x for x in [1] if _C]) for _C in [0, 1]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0083" {
  let source =
    #|f = [(z, lambda y: [(x, y, z) for x in [3]]) for z in [1]]
    #|(z, func), = f
    #|out = func(2)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0084" {
  let source =
    #|(func, c), = [(a, b) for b in [1] for a in [lambda : a]]
    #|d = func()
    #|assert d is func
    #|# must use "a" in this scope
    #|e = a if False else None
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0085" {
  let source =
    #|a = [1 for a in [0]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0086" {
  let source =
    #|x = 2
    #|[x for x in [1]]
    #|y = [x for _ in [1]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0087" {
  let source =
    #|a = 10
    #|def spam():
    #|    global a
    #|    (a := 20)
    #|spam()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0088" {
  let source =
    #|x: int
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0089" {
  let source =
    #|match None:
    #|    case {}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0090" {
  let source =
    #|(-
    #| -
    #| -
    #| 1)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0091" {
  let source =
    #|(1
    #| +
    #| 2
    #| +
    #| 3)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0092" {
  let source =
    #|(1,
    #| 2,
    #| 3)[0]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0093" {
  let source =
    #|[1,
    #| 2,
    #| 3]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0094" {
  let source =
    #|{1,
    #| 2,
    #| 3}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0095" {
  let source =
    #|1 in [
    #|   1,
    #|   2,
    #|   3
    #|]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0096" {
  let source =
    #|1 in {
    #|   1,
    #|   2,
    #|   3
    #|}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0097" {
  let source =
    #|for _ in [1,
    #|          2,
    #|          3]:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0098" {
  let source =
    #|for _ in {1,
    #|          2,
    #|          3}:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0099" {
  let source =
    #|def f():
    #|    x = y = 2
    #|    if not x:
    #|        return 4
    #|    for i in range(55):
    #|        x + 6
    #|    L = 7
    #|    L = 8
    #|    L = 9
    #|    L = 10
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0100" {
  let source =
    #|def f():
    #|    x = y = 2
    #|    if not x:
    #|        return 4
    #|    for i in range(55):
    #|        x + 6
    #|    del x
    #|    L = 8
    #|    L = 9
    #|    L = 10
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0101" {
  let source =
    #|def f():
    #|    x = y = 2
    #|    if not x:
    #|        return 4
    #|    for i in range(55):
    #|        x + 6
    #|    del x, y
    #|    L = 8
    #|    L = 9
    #|    L = 10
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0102" {
  let source =
    #|def f():
    #|    x = 2
    #|    L = 3
    #|    L = 4
    #|    L = 5
    #|    if not L:
    #|        x + 7
    #|        y = 2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0103" {
  let source =
    #|def func_start():
    #|    modify_class()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0104" {
  let source =
    #|def func_start():
    #|    modify_class()
    #|    sys._stats_on()
    #|    modify_class()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0105" {
  let source =
    #|def func_test(thread_id):
    #|    if thread_id == 0:
    #|        modify_class()
    #|        stats_on()
    #|        modify_class()
    #|    else:
    #|        while not TURNED_ON:
    #|            pass
    #|        modify_class()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0106" {
  let source =
    #|def func_test(thread_id):
    #|    if thread_id == 0:
    #|        modify_class()
    #|        stats_off()
    #|        modify_class()
    #|    else:
    #|        while not TURNED_OFF:
    #|            pass
    #|        modify_class()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0107" {
  let source =
    #|def func_test(thread_id):
    #|    modify_class()
    #|    if thread_id == 0:
    #|        raise SystemExit
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0108" {
  let source =
    #|def func_test(thread_id):
    #|    if thread_id == 0:
    #|        stats_on()
    #|    else:
    #|        while not TURNED_ON:
    #|            pass
    #|        modify_class()
    #|        sys._stats_dump()
    #|        stats_off()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0109" {
  let source =
    #|ready = False
    #|def func_test(thread_id):
    #|    global ready
    #|    if thread_id == 0:
    #|        stats_on()
    #|        modify_class()
    #|        while not ready:
    #|            pass  # wait until other thread has called modify_class()
    #|        stats_clear()  # clears stats for all threads
    #|    else:
    #|        while not TURNED_ON:
    #|            pass
    #|        modify_class()
    #|        ready = True
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0110" {
  let source =
    #|if 1:
    #|            def f():
    #|                y = 1
    #|                def g():
    #|                    global y
    #|                    return y
    #|                def h():
    #|                    return y + 1
    #|                return g, h
    #|            y = 9
    #|            g, h = f()
    #|            result9 = g()
    #|            result2 = h()
    #|            
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0111" {
  let source =
    #|if 1:
    #|            def f():
    #|                y = 1
    #|                def g():
    #|                    global y
    #|                    return y
    #|                def h():
    #|                    return y + 1
    #|                return g, h
    #|            y = 9
    #|            g, h = f()
    #|            result9 = g()
    #|            result2 = h()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0112" {
  let source =
    #|\
    #|def fib(n):
    #|    \
    #|'''Print a Fibonacci series up to n.'''
    #|    \
    #|a, b = 0, 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0113" {
  let source =
    #|\
    #|def fib(n):
    #|    '''Print a Fibonacci series up to n.'''
    #|    a, b = 0, 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0114" {
  let source =
    #|def match(x):
    #|    return 1+1
    #|
    #|match(34)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0115" {
  let source =
    #|def case(x):
    #|    return 1+1
    #|
    #|case(34)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0116" {
  let source =
    #|def f():
    #|    try:
    #|        pass
    #|    finally:
    #|        return 42
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0117" {
  let source =
    #|def f():
    #|    try:
    #|        pass
    #|    finally:
    #|        try:
    #|            return 42
    #|        except:
    #|            pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0118" {
  let source =
    #|def f():
    #|    try:
    #|        pass
    #|    finally:
    #|        try:
    #|            pass
    #|        except:
    #|            return 42
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0119" {
  let source =
    #|def f[__classdict__](): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0120" {
  let source =
    #|def foo():
    #|    while 1:
    #|        return foo
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0121" {
  let source =
    #|type TA = int
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0122" {
  let source =
    #|type Alias = undefined
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0123" {
  let source =
    #|type TA1[A] = lambda A: A
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0124" {
  let source =
    #|def f(format):
    #|    def inner(x: format): pass
    #|    return inner
    #|res = f("closure var")
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0125" {
  let source =
    #|def f(x: format):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0126" {
  let source =
    #|def outer():
    #|    def f(x: format):
    #|        pass
    #|    if False:
    #|        class format: pass
    #|    return f
    #|f = outer()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0127" {
  let source =
    #|try:
    #|    if {cond}:
    #|        raise Exception
    #|    in_try: "try"
    #|except Exception:
    #|    in_except: "except"
    #|finally:
    #|    in_finally: "finally"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0128" {
  let source =
    #|try:
    #|    if {cond}:
    #|        raise Exception
    #|    in_try_star: "try"
    #|except* Exception:
    #|    in_except_star: "except"
    #|finally:
    #|    in_finally: "finally"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0129" {
  let source =
    #|unique_name_1 = unique_name_5 = [1]
    #|name_0 = 42
    #|unique_name_7: {name_0 for name_0 in unique_name_1}
    #|unique_name_2: {
    #|    0: (lambda: name_0 for unique_name_4 in unique_name_5)
    #|    for unique_name_6 in [1]
    #|    if name_0
    #|}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0130" {
  let source =
    #|if True:
    #|    x: int = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0131" {
  let source =
    #|while True:
    #|    x: int = 1
    #|    break
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0132" {
  let source =
    #|while False:
    #|    pass
    #|else:
    #|    x: int = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0133" {
  let source =
    #|for i in range(1):
    #|    x: int = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0134" {
  let source =
    #|for i in range(1):
    #|    pass
    #|else:
    #|    x: int = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0135" {
  let source =
    #|try:
    #|    x: int = 1
    #|except:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0136" {
  let source =
    #|try:
    #|    pass
    #|except:
    #|    pass
    #|else:
    #|    x: int = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0137" {
  let source =
    #|try:
    #|    pass
    #|except:
    #|    pass
    #|finally:
    #|    x: int = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0138" {
  let source =
    #|try:
    #|    1/0
    #|except:
    #|    x: int = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0139" {
  let source =
    #|try:
    #|    x: int = 1
    #|except* Exception:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0140" {
  let source =
    #|try:
    #|    pass
    #|except* Exception:
    #|    pass
    #|else:
    #|    x: int = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0141" {
  let source =
    #|try:
    #|    pass
    #|except* Exception:
    #|    pass
    #|finally:
    #|    x: int = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0142" {
  let source =
    #|try:
    #|    1/0
    #|except* Exception:
    #|    x: int = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0143" {
  let source =
    #|match 0:
    #|    case 0:
    #|        x: int = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0144" {
  let source =
    #|a: int
    #|def __annotate__(format):
    #|    return {"a": str}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0145" {
  let source =
    #|x: [y for y in range(10)]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0146" {
  let source =
    #|def f(x: int):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0147" {
  let source =
    #|(unique_name_0): 0
    #|unique_name_1: (
    #|    0
    #|    for (
    #|        0
    #|        for unique_name_2 in 0
    #|        for () in (0 for unique_name_3 in unique_name_4 for unique_name_5 in name_1)
    #|    ).name_3 in {0: 0 for name_1 in unique_name_8}
    #|    if name_1
    #|)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0148" {
  let source =
    #|unique_name_0: 0
    #|unique_name_1: {
    #|    0: 0
    #|    for unique_name_2 in [0 for name_0 in unique_name_4]
    #|    if {
    #|        0: 0
    #|        for unique_name_5 in 0
    #|        if name_0
    #|        if ((name_0 for unique_name_8 in unique_name_9) for [] in 0)
    #|    }
    #|}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0149" {
  let source =
    #|0[0]: {0 for name_0 in unique_name_1}
    #|unique_name_2: {
    #|    0: (lambda: name_0 for unique_name_4 in unique_name_5)
    #|    for unique_name_6 in ()
    #|    if name_0
    #|}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0150" {
  let source =
    #|def report_error():
    #|    pass
    #|try:
    #|    [0 for name_2 in unique_name_0 if (lambda: name_2)]
    #|except:
    #|    pass
    #|annotated_name: 0
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0151" {
  let source =
    #|def func(x: [y async for y in x]): ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0152" {
  let source =
    #|def func(x: {y async for y in x}): ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0153" {
  let source =
    #|def func(x: {y: y async for y in x}): ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0154" {
  let source =
    #|(x): [y async for y in x]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0155" {
  let source =
    #|(x): {y async for y in x}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0156" {
  let source =
    #|(x): {y: y async for y in x}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0157" {
  let source =
    #|def foo():
    #|    # type: () -> int
    #|    pass
    #|
    #|def bar():  # type: () -> None
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0158" {
  let source =
    #|async def foo():
    #|    # type: () -> int
    #|    return await bar()
    #|
    #|async def bar():  # type: () -> int
    #|    return await bar()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0159" {
  let source =
    #|async def foo(xs):
    #|    [x async for x in xs]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0160" {
  let source =
    #|a = 42
    #|f"{a}"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0161" {
  let source =
    #|def foo():  # type: () -> int
    #|    # type: () -> str
    #|    return ''
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0162" {
  let source =
    #|def foo():
    #|    # type: () -> t
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0163" {
  let source =
    #|for a in []:  # type: int
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0164" {
  let source =
    #|def foo():
    #|    pass  # type: ignore
    #|
    #|def bar():
    #|    x = 1  # type: ignore
    #|
    #|def baz():
    #|    pass  # type: ignore[excuse]
    #|    pass  # type: ignore=excuse
    #|    pass  # type: ignore [excuse]
    #|    x = 1  # type: ignore whatever
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0165" {
  let source =
    #|try:  # type: int
    #|  pass
    #|finally:
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0166" {
  let source =
    #|try:
    #|  pass
    #|finally:  # type: int
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0167" {
  let source =
    #|def f():
    #|    for x in range(10):
    #|        break
    #|    else:
    #|        y = 2
    #|    z = 3
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0168" {
  let source =
    #|def g():
    #|    while True:
    #|        break
    #|    else:
    #|        y = 2
    #|    z = 3
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0169" {
  let source =
    #|def f():
    #|    x = 1
    #|    def g():
    #|        nonlocal x
    #|        x = 2
    #|        y = 7
    #|        def h():
    #|            nonlocal x, y
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0170" {
  let source =
    #|f"""{'''
    #|'''}"""
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0171" {
  let source =
    #|def f(a): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0172" {
  let source =
    #|def f(b = 2): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0173" {
  let source =
    #|def f(a, b): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0174" {
  let source =
    #|def f(a, b = 2): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0175" {
  let source =
    #|def f(a = 5, b = 2): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0176" {
  let source =
    #|def f(*, a = 1, b = 2): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0177" {
  let source =
    #|def f(*, a = 1, b): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0178" {
  let source =
    #|def f(*, a, b = 2): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0179" {
  let source =
    #|def f(a, b = None, *, c, **kwds): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0180" {
  let source =
    #|def f(a=2, *args, c=5, d, **kwds): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0181" {
  let source =
    #|def f(*args, **kwargs): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0182" {
  let source =
    #|def f(a : int): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0183" {
  let source =
    #|def f(a: int = 5): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0184" {
  let source =
    #|def f(*args: [int]): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0185" {
  let source =
    #|def f(**kwargs: dict): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0186" {
  let source =
    #|def f() -> None: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0187" {
  let source =
    #|a = 5 # type: int and more
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0188" {
  let source =
    #|def x(): # type: () -> None
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0189" {
  let source =
    #|def x(y): # type: (int) -> None and more
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0190" {
  let source =
    #|async def x(): # type: () -> None
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0191" {
  let source =
    #|async def x(y): # type: (int) -> None and more
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0192" {
  let source =
    #|a = 5 # type: ignore and more
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0193" {
  let source =
    #|def x(): # type: ignore
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0194" {
  let source =
    #|def x(y): # type: ignore and more
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0195" {
  let source =
    #|async def x(): # type: ignore
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0196" {
  let source =
    #|async def x(y): # type: ignore and more
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0197" {
  let source =
    #|def x():
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0198" {
  let source =
    #|def x(y):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0199" {
  let source =
    #|async def x():
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0200" {
  let source =
    #|async def x(y):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0201" {
  let source =
    #|def f():
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0202" {
  let source =
    #|def f(a):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0203" {
  let source =
    #|def f(b=2):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0204" {
  let source =
    #|def f(a, b):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0205" {
  let source =
    #|def f(a, b=2):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0206" {
  let source =
    #|def f(a=5, b=2):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0207" {
  let source =
    #|def f(*, a=1, b=2):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0208" {
  let source =
    #|def f(*, a=1, b):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0209" {
  let source =
    #|def f(*, a, b=2):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0210" {
  let source =
    #|def f(a, b=None, *, c, **kwds):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0211" {
  let source =
    #|def f(a=2, *args, c=5, d, **kwds):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0212" {
  let source =
    #|def f(*args, **kwargs):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0213" {
  let source =
    #|1 + 1
    #|"""false"""
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0214" {
  let source =
    #|four = lambda: 2 + 2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0215" {
  let source =
    #|square = lambda n: n ** 2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0216" {
  let source =
    #|add = lambda x, y: x + y
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0217" {
  let source =
    #|def f[T]():
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0218" {
  let source =
    #|def f[T: int]():
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0219" {
  let source =
    #|async def f():
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0220" {
  let source =
    #|async def f[T]():
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0221" {
  let source =
    #|i = 1
    #|j = 2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0222" {
  let source =
    #|# coding: Latin-1
    #|u = ""
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"ok\", \"None\", \"\", \"\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0223" {
  let source =
    #|def echo(value=None):
    #|    print("Execution starts when 'next()' is called for the first time.")
    #|    try:
    #|        while True:
    #|            try:
    #|                value = (yield value)
    #|            except Exception as e:
    #|                value = e
    #|    finally:
    #|        print("Don't forget to clean up when 'close()' is called.")
    #|generator = echo(1)
    #|print(next(generator))
    #|print(next(generator))
    #|print(generator.send(2))
    #|generator.throw(TypeError, "spam")
    #|generator.close()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'next' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0224" {
  let source =
    #|def f(a, b):
    #|    print(a, b)
    #|f(b=1, *(2,))
    #|f(a=1, *(2,))
    #|f(1, *(2,))
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"TypeError: f() got multiple values for argument 'a'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0225" {
  let source =
    #|if matching := pattern.search(data):
    #|    do_something(matching)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'pattern' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0226" {
  let source =
    #|while chunk := file.read(9000):
    #|    process(chunk)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'file' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0227" {
  let source =
    #|expr1, expr2, expr3, expr4
    #|(expr1, expr2, expr3, expr4)
    #|{expr1: expr2, expr3: expr4}
    #|expr1 + expr2 * (expr3 - expr4)
    #|expr1(expr2, expr3, *expr4, **expr5)
    #|expr3, expr4 = expr1, expr2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'expr1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0228" {
  let source =
    #|class Cls:
    #|    x = 3             # class variable
    #|inst = Cls()
    #|inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0229" {
  let source =
    #|if __debug__:
    #|    if not expression: raise AssertionError
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'expression' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0230" {
  let source =
    #|if __debug__:
    #|    if not expression1: raise AssertionError(expression2)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'expression1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0231" {
  let source =
    #|def f(arg): pass    # a function that does nothing (yet)
    #|
    #|class C: pass       # a class with no methods (yet)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0232" {
  let source =
    #|raise Exception("foo occurred").with_traceback(tracebackobj)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'tracebackobj' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0233" {
  let source =
    #|try:
    #|    print(1 / 0)
    #|except Exception as exc:
    #|    raise RuntimeError("Something bad happened") from exc
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'RuntimeError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0234" {
  let source =
    #|try:
    #|    print(1 / 0)
    #|except:
    #|    raise RuntimeError("Something bad happened")
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'RuntimeError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0235" {
  let source =
    #|try:
    #|    print(1 / 0)
    #|except:
    #|    raise RuntimeError("Something bad happened") from None
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'RuntimeError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0236" {
  let source =
    #|import foo                 # foo imported and bound locally
    #|import foo.bar.baz         # foo, foo.bar, and foo.bar.baz imported, foo bound locally
    #|import foo.bar.baz as fbb  # foo, foo.bar, and foo.bar.baz imported, foo.bar.baz bound as fbb
    #|from foo.bar import baz    # foo, foo.bar, and foo.bar.baz imported, foo.bar.baz bound as baz
    #|from foo import attr       # foo imported and foo.attr bound as attr
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module foo is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0237" {
  let source =
    #|print(sys.exception())
    #|try:
    #|    raise TypeError
    #|except:
    #|    print(repr(sys.exception()))
    #|    try:
    #|         raise ValueError
    #|    except:
    #|        print(repr(sys.exception()))
    #|    print(repr(sys.exception()))
    #|print(sys.exception())
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'sys' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0238" {
  let source =
    #|try:
    #|    raise ExceptionGroup("eg",
    #|        [ValueError(1), TypeError(2), OSError(3), OSError(4)])
    #|except* TypeError as e:
    #|    print(f'caught {type(e)} with nested {e.exceptions}')
    #|except* OSError as e:
    #|    print(f'caught {type(e)} with nested {e.exceptions}')
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'TypeError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0239" {
  let source =
    #|try:
    #|    raise BlockingIOError
    #|except* BlockingIOError as e:
    #|    print(repr(e))
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'BlockingIOError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0240" {
  let source =
    #|with EXPRESSION as TARGET:
    #|    SUITE
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'EXPRESSION' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0241" {
  let source =
    #|manager = (EXPRESSION)
    #|enter = type(manager).__enter__
    #|exit = type(manager).__exit__
    #|value = enter(manager)
    #|hit_except = False
    #|
    #|try:
    #|    TARGET = value
    #|    SUITE
    #|except:
    #|    hit_except = True
    #|    if not exit(manager, *sys.exc_info()):
    #|        raise
    #|finally:
    #|    if not hit_except:
    #|        exit(manager, None, None, None)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'EXPRESSION' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0242" {
  let source =
    #|with A() as a, B() as b:
    #|    SUITE
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'A' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0243" {
  let source =
    #|with A() as a:
    #|    with B() as b:
    #|        SUITE
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'A' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0244" {
  let source =
    #|with (
    #|    A() as a,
    #|    B() as b,
    #|):
    #|    SUITE
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'A' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0245" {
  let source =
    #|@f1(arg)
    #|@f2
    #|def func(): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'f1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0246" {
  let source =
    #|def func(): pass
    #|func = f1(arg)(f2(func))
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'f1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0247" {
  let source =
    #|class Foo:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0248" {
  let source =
    #|class Foo(object):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0249" {
  let source =
    #|@f1(arg)
    #|@f2
    #|class Foo: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'f1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0250" {
  let source =
    #|class Foo: pass
    #|Foo = f1(arg)(f2(Foo))
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0251" {
  let source =
    #|async for TARGET in ITER:
    #|    SUITE
    #|else:
    #|    SUITE2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0252" {
  let source =
    #|iter = (ITER)
    #|iter = type(iter).__aiter__(iter)
    #|running = True
    #|
    #|while running:
    #|    try:
    #|        TARGET = await type(iter).__anext__(iter)
    #|    except StopAsyncIteration:
    #|        running = False
    #|    else:
    #|        SUITE
    #|else:
    #|    SUITE2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 7:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0253" {
  let source =
    #|async with EXPRESSION as TARGET:
    #|    SUITE
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0254" {
  let source =
    #|manager = (EXPRESSION)
    #|aenter = type(manager).__aenter__
    #|aexit = type(manager).__aexit__
    #|value = await aenter(manager)
    #|hit_except = False
    #|
    #|try:
    #|    TARGET = value
    #|    SUITE
    #|except:
    #|    hit_except = True
    #|    if not await aexit(manager, *sys.exc_info()):
    #|        raise
    #|finally:
    #|    if not hit_except:
    #|        await aexit(manager, None, None, None)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0255" {
  let source =
    #|def max[T](args: list[T]) -> T:
    #|    ...
    #|
    #|async def amax[T](args: list[T]) -> T:
    #|    ...
    #|
    #|class Bag[T]:
    #|    def __iter__(self) -> Iterator[T]:
    #|        ...
    #|
    #|    def add(self, arg: T) -> None:
    #|        ...
    #|
    #|type ListOrSet[T] = list[T] | set[T]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module typing is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0256" {
  let source =
    #|@decorator
    #|def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):
    #|    ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'decorator' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0257" {
  let source =
    #|class Bag[T]: ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module typing is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0258" {
  let source =
    #|@decorator
    #|class Bag(Base[T], arg=T): ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'decorator' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0259" {
  let source =
    #|import typing
    #|typing.__name__, typing.__spec__.name
    #|typing.__spec__.name = 'spelling'
    #|typing.__name__, typing.__spec__.name
    #|typing.__name__ = 'keyboard_smashing'
    #|typing.__name__, typing.__spec__.name
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module typing is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0260" {
  let source =
    #|class A: pass
    #|class B(A): pass
    #|A.__subclasses__()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0261" {
  let source =
    #|import sys
    #|from types import ModuleType
    #|
    #|class VerboseModule(ModuleType):
    #|    def __repr__(self):
    #|        return f'Verbose {self.__name__}'
    #|
    #|    def __setattr__(self, attr, value):
    #|        print(f'Setting {attr}...')
    #|        super().__setattr__(attr, value)
    #|
    #|sys.modules[__name__].__class__ = VerboseModule
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module sys is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0262" {
  let source =
    #|class Philosopher:
    #|    def __init_subclass__(cls, /, default_name, **kwargs):
    #|        super().__init_subclass__(**kwargs)
    #|        cls.default_name = default_name
    #|
    #|class AustralianPhilosopher(Philosopher, default_name="Bruce"):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0263" {
  let source =
    #|class A:
    #|    x = C()  # Automatically calls: x.__set_name__(A, 'x')
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0264" {
  let source =
    #|class A:
    #|   pass
    #|
    #|c = C()
    #|A.x = c                  # The hook is not called
    #|c.__set_name__(A, 'x')   # Manually invoke the hook
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0265" {
  let source =
    #|class Meta(type):
    #|    pass
    #|
    #|class MyClass(metaclass=Meta):
    #|    pass
    #|
    #|class MySubclass(MyClass):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'type' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0266" {
  let source =
    #|from inspect import isclass
    #|
    #|def subscribe(obj, x):
    #|    """Return the result of the expression 'obj[x]'"""
    #|
    #|    class_of_obj = type(obj)
    #|
    #|    # If the class of obj defines __getitem__,
    #|    # call class_of_obj.__getitem__(obj, x)
    #|    if hasattr(class_of_obj, '__getitem__'):
    #|        return class_of_obj.__getitem__(obj, x)
    #|
    #|    # Else, if obj is a class and defines __class_getitem__,
    #|    # call obj.__class_getitem__(x)
    #|    elif isclass(obj) and hasattr(obj, '__class_getitem__'):
    #|        return obj.__class_getitem__(x)
    #|
    #|    # Else, raise an exception
    #|    else:
    #|        raise TypeError(
    #|            f"'{class_of_obj.__name__}' object is not subscriptable"
    #|        )
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module inspect is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0267" {
  let source =
    #|from enum import Enum
    #|class Menu(Enum):
    #|    """A breakfast menu"""
    #|    SPAM = 'spam'
    #|    BACON = 'bacon'
    #|# Enum classes have a custom metaclass:
    #|type(Menu)
    #|# EnumMeta defines __getitem__,
    #|# so __class_getitem__ is not called,
    #|# and the result is not a GenericAlias object:
    #|Menu['SPAM']
    #|type(Menu['SPAM'])
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module enum is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0268" {
  let source =
    #|a[1:2] = b
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'b' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0269" {
  let source =
    #|a[slice(1, 2, None)] = b
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'b' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0270" {
  let source =
    #|class C:
    #|    pass
    #|c = C()
    #|c.__len__ = lambda: 5
    #|len(c)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0271" {
  let source =
    #|1 .__hash__() == hash(1)
    #|int.__hash__() == hash(int)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'hash' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0272" {
  let source =
    #|type(1).__hash__(1) == hash(1)
    #|type(int).__hash__(int) == hash(int)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'type' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0273" {
  let source =
    #|class Meta(type):
    #|    def __getattribute__(*args):
    #|        print("Metaclass getattribute invoked")
    #|        return type.__getattribute__(*args)
    #|class C(object, metaclass=Meta):
    #|    def __len__(self):
    #|        return 10
    #|    def __getattribute__(*args):
    #|        print("Class getattribute invoked")
    #|        return object.__getattribute__(*args)
    #|c = C()
    #|c.__len__()                 # Explicit lookup via instance
    #|type(c).__len__(c)          # Explicit lookup via type
    #|len(c)                      # Implicit lookup
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'type' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0274" {
  let source =
    #|class Reader:
    #|    async def readline(self):
    #|        ...
    #|
    #|    def __aiter__(self):
    #|        return self
    #|
    #|    async def __anext__(self):
    #|        val = await self.readline()
    #|        if val == b'':
    #|            raise StopAsyncIteration
    #|        return val
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0275" {
  let source =
    #|class AsyncContextManager:
    #|    async def __aenter__(self):
    #|        await log('entering context')
    #|
    #|    async def __aexit__(self, exc_type, exc, tb):
    #|        await log('exiting context')
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0276" {
  let source =
    #|name = "Fred"
    #|f"He said his name is {name!r}."
    #|f"He said his name is {repr(name)}."  # repr() is equivalent to !r
    #|width = 10
    #|precision = 4
    #|value = decimal.Decimal("12.34567")
    #|f"result: {value:{width}.{precision}}"  # nested fields
    #|today = datetime(year=2017, month=1, day=27)
    #|f"{today:%B %d, %Y}"  # using date format specifier
    #|f"{today=:%B %d, %Y}" # using date format specifier and debugging
    #|number = 1024
    #|f"{number:#0x}"  # using integer format specifier
    #|foo = "bar"
    #|f"{ foo = }" # preserves whitespace
    #|line = "The mill's closed"
    #|f"{line = }"
    #|f"{line = :20}"
    #|f"{line = !r:20}"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'repr' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0277" {
  let source =
    #|class A:
    #|    a = 42
    #|    b = list(a + i for i in range(10))
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0278" {
  let source =
    #|class A:
    #|    type Alias = Nested
    #|    class Nested: pass
    #|
    #|print(A.Alias.__value__)  # 
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0279" {
  let source =
    #|type Alias = 1/0
    #|Alias.__value__
    #|def func[T: 1/0](): pass
    #|T = func.__type_params__[0]
    #|T.__bound__
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ZeroDivisionError: division by zero\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0280" {
  let source =
    #|from typing import Literal
    #|
    #|type SimpleExpr = int | Parenthesized
    #|type Parenthesized = tuple[Literal["("], Expr, Literal[")"]]
    #|type Expr = SimpleExpr | tuple[SimpleExpr, Literal["+", "-"], Expr]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module typing is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0281" {
  let source =
    #|- main / interp / other
    #|- run in: current thread / new thread / other thread / different threads
    #|- end / opposite
    #|- force / no force
    #|- used / not used  (associated / not associated)
    #|- empty / emptied / never emptied / partly emptied
    #|- closed / not closed
    #|- released / not released
    #|- creator (interp) / other
    #|- associated interpreter not running
    #|- associated interpreter destroyed
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0282" {
  let source =
    #|use
    #|pre-release
    #|release
    #|after
    #|check
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'use' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0283" {
  let source =
    #|release in:         main, interp1
    #|creator:            same, other (incl. interp2)
    #|
    #|use:                None,send,recv,send/recv in None,same,other(incl. interp2),same+other(incl. interp2),all
    #|pre-release:        None,send,recv,both in None,same,other(incl. interp2),same+other(incl. interp2),all
    #|pre-release forced: None,send,recv,both in None,same,other(incl. interp2),same+other(incl. interp2),all
    #|
    #|release:            same
    #|release forced:     same
    #|
    #|use after:          None,send,recv,send/recv in None,same,other(incl. interp2),same+other(incl. interp2),all
    #|release after:      None,send,recv,send/recv in None,same,other(incl. interp2),same+other(incl. interp2),all
    #|check released:     send/recv for same/other(incl. interp2)
    #|check closed:       send/recv for same/other(incl. interp2)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0284" {
  let source =
    #|- main / interp / other
    #|- run in: current thread / new thread / other thread / different threads
    #|- end / opposite
    #|- force / no force
    #|- used / not used  (associated / not associated)
    #|- empty / emptied / never emptied / partly emptied
    #|- closed / not closed
    #|- released / not released
    #|- creator (interp) / other
    #|- associated interpreter not running
    #|- associated interpreter destroyed
    #|
    #|- close after unbound
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0285" {
  let source =
    #|use
    #|pre-close
    #|close
    #|after
    #|check
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'use' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0286" {
  let source =
    #|close in:         main, interp1
    #|creator:          same, other, extra
    #|
    #|use:              None,send,recv,send/recv in None,same,other,same+other,all
    #|pre-close:        None,send,recv in None,same,other,same+other,all
    #|pre-close forced: None,send,recv in None,same,other,same+other,all
    #|
    #|close:            same
    #|close forced:     same
    #|
    #|use after:        None,send,recv,send/recv in None,same,other,extra,same+other,all
    #|close after:      None,send,recv,send/recv in None,same,other,extra,same+other,all
    #|check closed:     send/recv for same/other(incl. interp2)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0287" {
  let source =
    #|import _interpchannels as _channels
    #|cid = _channels.create(3)
    #|print(cid)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module _interpchannels is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0288" {
  let source =
    #|import _interpchannels as _channels
    #|print(cid.end)
    #|_channels.send(cid, b'spam', blocking=False)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module _interpchannels is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0289" {
  let source =
    #|import _interpchannels as _channels
    #|print(chan.id.end)
    #|_channels.send(chan.id, b'spam', blocking=False)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module _interpchannels is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0290" {
  let source =
    #|import _interpchannels as _channels
    #|cid = _channels.create(REPLACE)
    #|orig = b'spam'
    #|_channels.send(cid, orig, blocking=False)
    #|obj, _ = _channels.recv(cid)
    #|assert obj is not orig
    #|assert obj == orig
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module _interpchannels is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0291" {
  let source =
    #|import _interpchannels as channels
    #|import test.test__interpchannels as helpers
    #|ChannelState = helpers.ChannelState
    #|try:
    #|    cid
    #|except NameError:
    #|    cid = _channels._channel_id(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 7:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0292" {
  let source =
    #|with helpers.expect_channel_closed():
    #|    _channels.recv(cid)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'helpers' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0293" {
  let source =
    #|with helpers.expect_channel_closed():
    #|    _channels.send(cid, b'spam', blocking=False)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'helpers' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0294" {
  let source =
    #|with helpers.expect_channel_closed():
    #|    _channels.close(cid)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'helpers' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0295" {
  let source =
    #|with helpers.expect_channel_closed():
    #|    _channels.close(cid, force=True)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'helpers' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0296" {
  let source =
    #|import _interpchannels as _channels
    #|_channels.recv(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0297" {
  let source =
    #|import _interpchannels as _channels
    #|_channels.send(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0298" {
  let source =
    #|import _interpchannels as _channels
    #|_channels.release(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0299" {
  let source =
    #|import _interpchannels as _channels
    #|_channels.close(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0300" {
  let source =
    #|import _interpchannels as _channels
    #|obj, _ = _channels.recv(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0301" {
  let source =
    #|)
    #|            _channels.release(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0302" {
  let source =
    #|)
    #|            print(repr(obj))
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0303" {
  let source =
    #|import _interpchannels as _channels
    #|obj = _channels.send(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0304" {
  let source =
    #|, b'spam', blocking=False)
    #|            _channels.release(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0305" {
  let source =
    #|import _interpreters
    #|cid = _xxsubchannels.create()
    #|# We purposefully send back an int to avoid tying the
    #|# channel to the other interpreter.
    #|_xxsubchannels.send(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0306" {
  let source =
    #|, int(cid), blocking=False)
    #|                del _interpreters
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0307" {
  let source =
    #|,
    #|                    hideclosed=
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0308" {
  let source =
    #|,
    #|                    )
    #|                _channels.send(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0309" {
  let source =
    #|, result.pending.to_bytes(1, 'little'), blocking=False)
    #|                _channels.send(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0310" {
  let source =
    #|import time
    #|import _interpchannels as _channels
    #|while True:
    #|    try:
    #|        obj, _ = _channels.recv(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0311" {
  let source =
    #|)
    #|                        break
    #|                    except _channels.ChannelEmptyError:
    #|                        time.sleep(0.1)
    #|                assert(obj == b'spam')
    #|                _channels.send(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0312" {
  let source =
    #| world
    #|Here for a while...
    #|Goodbye
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0313" {
  let source =
    #|Pure-Python implementation of anext() for testing purposes.
    #|
    #|    Closely matches the builtin anext() C implementation.
    #|    Can be used to compare the built-in implementation of the inner
    #|    coroutines machinery to C-implementation of __anext__() and send()
    #|    or throw() on the returned generator.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0314" {
  let source =
    #|async def foo():
    #|            await abc
    #|            yield from 123
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0315" {
  let source =
    #|async def foo():
    #|            yield from 123
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0316" {
  let source =
    #|async def foo():
    #|            await abc
    #|            yield
    #|            return 123
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0317" {
  let source =
    #|async def foo():
    #|            yield
    #|            return 123
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0318" {
  let source =
    #|async def foo():
    #|            if 0:
    #|                yield
    #|            return 12
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0319" {
  let source =
    #|These tests are meant to exercise that requests to create objects bigger
    #|than what the address space allows are properly met with an OverflowError
    #|(rather than crash weirdly).
    #|
    #|Primarily, this means 32-bit builds with at least 2 GiB of available memory.
    #|You need to pass the -M option to regrtest (e.g. "-M 2.1G") for tests to
    #|be enabled.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0320" {
  let source =
    #|Bigmem tests - tests for the 32-bit boundary in containers.
    #|
    #|These tests try to exercise the 32-bit boundary that is sometimes, if
    #|rarely, exceeded in practice, but almost never tested.  They are really only
    #|meaningful on 64-bit builds on machines with a *lot* of memory, but the
    #|tests are always run, usually with very low memory limits to make sure the
    #|tests themselves don't suffer from bitrot.  To run them for real, pass a
    #|high memory limit to regrtest, with the -M option.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 7:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0321" {
  let source =
    #|Check that immortality is "sticky", so that
    #|           once an object is immortal it remains so.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0322" {
  let source =
    #|Return the sequence of operations that results from applying
    #|    the operation `op` to instances of the given classes.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0323" {
  let source =
    #|Constructor: Rat([num[, den]]).
    #|
    #|        The arguments must be ints, and default to (0, 1).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0324" {
  let source =
    #|Test calling using various C calling conventions (METH_*) from Python
    #|
    #|    Subclasses test several kinds of functions (module-level, methods,
    #|    class methods static methods) using these attributes:
    #|      obj: the object that contains tested functions (as attributes)
    #|      expected_self: expected "self" argument to the C function
    #|
    #|    The base class tests module-level functions.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0325" {
  let source =
    #| Python character mapping codec test
    #|
    #|This uses the test codec in testcodec.py and thus also tests the
    #|encodings package lookup scheme.
    #|
    #|Written by Marc-Andre Lemburg (mal@lemburg.com).
    #|
    #|(c) Copyright 2000 Guido van Rossum.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0326" {
  let source =
    #|@trackCall
    #|def __hash__(self, *args):
    #|    return hash(id(self))
    #|
    #|@trackCall
    #|def __str__(self, *args):
    #|    return "AllTests"
    #|
    #|@trackCall
    #|def __repr__(self, *args):
    #|    return "AllTests"
    #|
    #|@trackCall
    #|def __int__(self, *args):
    #|    return 1
    #|
    #|@trackCall
    #|def __index__(self, *args):
    #|    return 1
    #|
    #|@trackCall
    #|def __float__(self, *args):
    #|    return 1.0
    #|
    #|@trackCall
    #|def __eq__(self, *args):
    #|    return True
    #|
    #|@trackCall
    #|def __ne__(self, *args):
    #|    return False
    #|
    #|@trackCall
    #|def __lt__(self, *args):
    #|    return False
    #|
    #|@trackCall
    #|def __le__(self, *args):
    #|    return True
    #|
    #|@trackCall
    #|def __gt__(self, *args):
    #|    return False
    #|
    #|@trackCall
    #|def __ge__(self, *args):
    #|    return True
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'trackCall' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0327" {
  let source =
    #|@trackCall
    #|def __%s__(self, *args):
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0328" {
  let source =
    #|Verifies that the type cache doesn't provide a value which  is
    #|        inconsistent from the dict.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0329" {
  let source =
    #|if 1:
    #|            import test.support
    #|            import _testcapi
    #|
    #|            class A:
    #|                def __init__(self):
    #|                    self.a = 1
    #|                    self.b = 2
    #|            a = A()
    #|            d = a.__dict__
    #|            with test.support.catch_unraisable_exception() as ex:
    #|                _testcapi.set_nomemory(0, 1)
    #|                del a
    #|                assert ex.unraisable.exc_type is MemoryError
    #|            try:
    #|                d["a"]
    #|            except KeyError:
    #|                pass
    #|            else:
    #|                assert False, "KeyError not raised"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module test.support is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0330" {
  let source =
    #|Expected call list:
    #|  %s
    #|does not match actual call list
    #|  %s
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0331" {
  let source =
    #|Fail if the two floating-point numbers are not almost equal.
    #|
    #|        Determine whether floating-point values a and b are equal to within
    #|        a (small) rounding error.  The default values for rel_err and
    #|        abs_err are chosen to be suitable for platforms where a float is
    #|        represented by an IEEE 754 double.  They allow an error of between
    #|        9 and 19 ulps.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0332" {
  let source =
    #|Wrapped version of rect that accepts a complex number instead of
    #|            two float arguments.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0333" {
  let source =
    #|Wrapped version of polar that returns a complex number instead of
    #|            two floats.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0334" {
  let source =
    #|{}: {}(complex({!r}, {!r}))
    #|Expected: complex({!r}, {!r})
    #|Received: complex({!r}, {!r})
    #|Received value insufficiently close to expected value.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0335" {
  let source =
    #|        try:
    #|            1/0
    #|        except Exception as e:
    #|            exc = e
    #|        
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0336" {
  let source =
    #|res = a in {"str_value"}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0337" {
  let source =
    #|
    #|            def func1():
    #|                return (0.0, (1, 2, "hello"))
    #|        
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0338" {
  let source =
    #|
    #|            def func2():
    #|                return (0.0, (1, 2, "hello"))
    #|        
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0339" {
  let source =
    #|GH-109052
    #|
    #|       Make sure the instrumentation doesn't affect the code equality
    #|       The validity of this test relies on the fact that "x is x" and
    #|       "x in x" have only one different instruction and the instructions
    #|       have the same argument.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0340" {
  let source =
    #|def f():
    #|    pass
    #|
    #|positions = f.__code__.co_positions()
    #|for line, end_line, column, end_column in positions:
    #|    assert line == end_line
    #|    assert column is None
    #|    assert end_column is None
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"AssertionError: \"]"
  assert_run(result, expected)
}

///|
test "generated/program/0341" {
  let source =
    #|def has_docstring(x, y):
    #|    """This is a first-line doc string"""
    #|    """This is a second-line doc string"""
    #|    a = x + y
    #|    b = x - y
    #|    return a, b
    #|
    #|
    #|def no_docstring(x):
    #|    def g(y):
    #|        return x + y
    #|    return g
    #|
    #|
    #|async def async_func():
    #|    """asynf function doc string"""
    #|    pass
    #|
    #|
    #|for func in [has_docstring, no_docstring(4), async_func]:
    #|    assert(func.__doc__ is None)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"AssertionError: \"]"
  assert_run(result, expected)
}

///|
test "generated/program/0342" {
  let source =
    #|raise ValueError('BOOM!')
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'ValueError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0343" {
  let source =
    #|raise ValueError('') from AttributeError
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'ValueError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0344" {
  let source =
    #|AttributeError
    #|
    #|The above exception was the direct cause of the following exception:
    #|
    #|Traceback (most recent call last):
    #|  File "<console>", line 1, in <module>
    #|ValueError
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0345" {
  let source =
    #|try: ham
    #|except: eggs
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'eggs' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0346" {
  let source =
    #|Traceback (most recent call last):
    #|  File "<console>", line 1, in <module>
    #|NameError: name 'ham' is not defined
    #|
    #|During handling of the above exception, another exception occurred:
    #|
    #|Traceback (most recent call last):
    #|  File "<console>", line 2, in <module>
    #|NameError: name 'eggs' is not defined
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0347" {
  let source =
    #|This sentence is in ASCII.
    #|The next sentence is in GB.Bye.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0348" {
  let source =
    #|Test cases for codeop.py
    #|Nick Mathewson
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0349" {
  let source =
    #|#a
    #|#b
    #|a**3
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0350" {
  let source =
    #|@a.b.c
    #|def f():
    #| pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0351" {
  let source =
    #|print([1,
    #|2,
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0352" {
  let source =
    #|print({1:1,
    #|2:3,
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0353" {
  let source =
    #|print((1,
    #|2,
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0354" {
  let source =
    #|if 9==3:
    #|   pass
    #|else:
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0355" {
  let source =
    #|if 1:
    #| pass
    #| if 1:
    #|  pass
    #| else:
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0356" {
  let source =
    #|if True:
    #| if True:
    #|  if True:   
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0357" {
  let source =
    #|if a:
    #| pass
    #|elif b:
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0358" {
  let source =
    #|if a:
    #| pass
    #|elif b:
    #| pass
    #|else:
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0359" {
  let source =
    #|while a:
    #| pass
    #|else:
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0360" {
  let source =
    #|for a in b:
    #| pass
    #|else:
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0361" {
  let source =
    #|try:
    #| pass
    #|except:
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0362" {
  let source =
    #|try:
    #| pass
    #|finally:
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0363" {
  let source =
    #|try:
    #| pass
    #|except:
    #| pass
    #|finally:
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0364" {
  let source =
    #|def x():
    #|
    #|pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0365" {
  let source =
    #| if 1: pass
    #|
    #|pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0366" {
  let source =
    #|return 2.3
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0367" {
  let source =
    #|def foo(x,x):
    #|   pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0368" {
  let source =
    #|copy: %s
    #|words: %s
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0369" {
  let source =
    #|Test equality and ordering comparisons for built-in types and
    #|    user-defined classes that implement relevant combinations of rich
    #|    comparison methods.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0370" {
  let source =
    #|Base class for classes with rich comparison methods.
    #|
    #|        The "x" attribute should be set to an underlying value to compare.
    #|
    #|        Derived classes have a "meth" tuple attribute listing names of
    #|        comparison methods implemented. See assert_total_order().
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0371" {
  let source =
    #|Create objects of type `class_` and return them in a list.
    #|
    #|        `values` is a list of values that determines the value of data
    #|        attribute `x` of each object.
    #|
    #|        Objects in the returned list are sorted by their identity.  They
    #|        assigned values in `values` list order.  By assign decreasing
    #|        values to objects with increasing identities, testcases can assert
    #|        that order comparison is performed by value and not by identity.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0372" {
  let source =
    #|Assert equality result and that ordering is not implemented.
    #|
    #|        a, b: Instances to be tested (of same or different type).
    #|        equal: Boolean indicating the expected equality comparison results.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0373" {
  let source =
    #|Test total ordering comparison of two instances.
    #|
    #|        a, b: Instances to be tested (of same or different type).
    #|
    #|        comp: -1, 0, or 1 indicates that the expected order comparison
    #|           result for operations that are supported by the classes is
    #|           a <, ==, or > b.
    #|
    #|        a_meth, b_meth: Either None, indicating that all rich comparison
    #|           methods are available, aa for builtins, or the tuple (subset)
    #|           of "eq", "ne", "lt", "le", "gt", and "ge" that are available
    #|           for the corresponding instance (of a user-defined class).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0374" {
  let source =
    #|for x in l:
    #|	print(x)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'l' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0375" {
  let source =
    #|Make sure that __complex__() calls fail if anything other than a
    #|            complex is returned
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0376" {
  let source =
    #|Behaves strangely when compared
    #|
    #|            This class is designed to make sure that the contains code
    #|            works when the list is modified during the check.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0377" {
  let source =
    #|Is not a container
    #|
    #|            This class is a perfectly good iterable (as tested by
    #|            list(bc)), as well as inheriting from a perfectly good
    #|            container, but __contains__ = None prevents the usual
    #|            fallback to iteration in the container protocol. That
    #|            is, normally, 0 in bc would fall back to the equivalent
    #|            of any(x==0 for x in bc), but here it's blocked from
    #|            doing so.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 8:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0378" {
  let source =
    #|raise RuntimeErrorSubclass(42)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'RuntimeErrorSubclass' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0379" {
  let source =
    #|return _run_async_fn(self.__aexit__, *exc_details)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0380" {
  let source =
    #|async = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0381" {
  let source =
    #|import asyncio
    #|async def f(): pass
    #|async def t(): asyncio.gather(f())
    #|asyncio.run(t())
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module asyncio is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0382" {
  let source =
    #|import sys
    #|async def f(): pass
    #|sys.coro = f()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module sys is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0383" {
  let source =
    #|import sys
    #|async def f(): pass
    #|sys.corocycle = [f()]
    #|sys.corocycle.append(sys.corocycle)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module sys is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0384" {
  let source =
    #|def foo():
    #|                await something()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0385" {
  let source =
    #|async def foo():
    #|                yield from []
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0386" {
  let source =
    #|async def foo():
    #|                await await fut
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0387" {
  let source =
    #|async def foo(a=await something()):
    #|                pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0388" {
  let source =
    #|async def foo(a:await something()):
    #|                pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0389" {
  let source =
    #|async def foo():
    #|                def bar():
    #|                 [i async for i in els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0390" {
  let source =
    #|async def foo():
    #|                def bar():
    #|                 [await i for i in els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0391" {
  let source =
    #|async def foo():
    #|                def bar():
    #|                 [i for i in els
    #|                    async for b in els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0392" {
  let source =
    #|async def foo():
    #|                def bar():
    #|                 [i for i in els
    #|                    for c in b
    #|                    async for b in els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0393" {
  let source =
    #|async def foo():
    #|                def bar():
    #|                 [i for i in els
    #|                    async for b in els
    #|                    for c in b]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0394" {
  let source =
    #|async def foo():
    #|                def bar():
    #|                 [[async for i in b] for b in els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0395" {
  let source =
    #|async def foo():
    #|                def bar():
    #|                 [i for i in els
    #|                    for b in await els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0396" {
  let source =
    #|async def foo():
    #|                def bar():
    #|                 [i for i in els
    #|                    for b in els
    #|                        if await b]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0397" {
  let source =
    #|async def foo():
    #|                def bar():
    #|                 [i for i in await els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0398" {
  let source =
    #|async def foo():
    #|                def bar():
    #|                 [i for i in els if await i]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0399" {
  let source =
    #|def bar():
    #|                 [i async for i in els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0400" {
  let source =
    #|def bar():
    #|                 {i: i async for i in els}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0401" {
  let source =
    #|def bar():
    #|                 {i async for i in els}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0402" {
  let source =
    #|def bar():
    #|                 [await i for i in els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0403" {
  let source =
    #|def bar():
    #|                 [i for i in els
    #|                    async for b in els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0404" {
  let source =
    #|def bar():
    #|                 [i for i in els
    #|                    for c in b
    #|                    async for b in els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0405" {
  let source =
    #|def bar():
    #|                 [i for i in els
    #|                    async for b in els
    #|                    for c in b]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0406" {
  let source =
    #|def bar():
    #|                 [i for i in els
    #|                    for b in await els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0407" {
  let source =
    #|def bar():
    #|                 [i for i in els
    #|                    for b in els
    #|                        if await b]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0408" {
  let source =
    #|def bar():
    #|                 [i for i in await els]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0409" {
  let source =
    #|def bar():
    #|                 [i for i in els if await i]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0410" {
  let source =
    #|def bar():
    #|                 [[i async for i in a] for a in elts]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0411" {
  let source =
    #|async def foo():
    #|                await
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0412" {
  let source =
    #|async def foo():
    #|                   def bar(): pass
    #|                   await = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0413" {
  let source =
    #|async def foo():
    #|
    #|                   def bar(): pass
    #|                   await = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0414" {
  let source =
    #|async def foo():
    #|                   def bar(): pass
    #|                   if 1:
    #|                       await = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0415" {
  let source =
    #|def foo():
    #|                   async def bar(): pass
    #|                   if 1:
    #|                       await a
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0416" {
  let source =
    #|def foo():
    #|                   async def bar(): pass
    #|                   await a
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0417" {
  let source =
    #|def foo():
    #|                   def baz(): pass
    #|                   async def bar(): pass
    #|                   await a
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0418" {
  let source =
    #|def foo():
    #|                   def baz(): pass
    #|                   # 456
    #|                   async def bar(): pass
    #|                   # 123
    #|                   await a
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 6:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0419" {
  let source =
    #|async def foo():
    #|                   def baz(): pass
    #|                   # 456
    #|                   async def bar(): pass
    #|                   # 123
    #|                   await = 2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 6:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0420" {
  let source =
    #|def foo():
    #|
    #|                   def baz(): pass
    #|
    #|                   async def bar(): pass
    #|
    #|                   await a
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 7:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0421" {
  let source =
    #|async def foo():
    #|
    #|                   def baz(): pass
    #|
    #|                   async def bar(): pass
    #|
    #|                   await = 2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 7:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0422" {
  let source =
    #|async def foo():
    #|                   def async(): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0423" {
  let source =
    #|async def foo():
    #|                   def await(): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0424" {
  let source =
    #|async def foo():
    #|                   def bar():
    #|                       await
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0425" {
  let source =
    #|async def foo():
    #|                   return lambda async: await
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0426" {
  let source =
    #|async def foo():
    #|                   return lambda a: await
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0427" {
  let source =
    #|async def foo(a=await b):
    #|                   pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0428" {
  let source =
    #|async def foo(a:await b):
    #|                   pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0429" {
  let source =
    #|def baz():
    #|                   async def foo(a=await b):
    #|                       pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0430" {
  let source =
    #|async def foo(async):
    #|                   pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0431" {
  let source =
    #|async def foo():
    #|                   def bar():
    #|                        def baz():
    #|                            async = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0432" {
  let source =
    #|async def foo():
    #|                   def bar():
    #|                        def baz():
    #|                            pass
    #|                        async = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0433" {
  let source =
    #|def foo():
    #|                   async def bar():
    #|
    #|                        async def baz():
    #|                            pass
    #|
    #|                        def baz():
    #|                            42
    #|
    #|                        async = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 10:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0434" {
  let source =
    #|async def foo():
    #|                   def bar():
    #|                        def baz():
    #|                            pass
    #|await foo()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0435" {
  let source =
    #|def foo():
    #|                   def bar():
    #|                        async def baz():
    #|                            pass
    #|await foo()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0436" {
  let source =
    #|async def foo(await):
    #|                   pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0437" {
  let source =
    #|def foo():
    #|
    #|                   async def bar(): pass
    #|
    #|                   await a
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0438" {
  let source =
    #|def foo():
    #|                   async def bar():
    #|                        pass
    #|await a
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0439" {
  let source =
    #|def foo():
    #|                   async for i in arange(2):
    #|                       pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0440" {
  let source =
    #|def foo():
    #|                   async with resource:
    #|                       pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0441" {
  let source =
    #|async with resource:
    #|                   pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0442" {
  let source =
    #|async for i in arange(2):
    #|                   pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0443" {
  let source =
    #|def foo():
    #|                await = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0444" {
  let source =
    #|class Bar:
    #|                def async(): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0445" {
  let source =
    #|class Bar:
    #|                async = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0446" {
  let source =
    #|class async:
    #|                pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0447" {
  let source =
    #|class await:
    #|                pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0448" {
  let source =
    #|def async():
    #|                pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0449" {
  let source =
    #|def foo(*, await=1):
    #|                passasync = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0450" {
  let source =
    #|def foo(await):
    #|                async def foo(): pass
    #|                async def foo():
    #|                    pass
    #|                return await + 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0451" {
  let source =
    #|def foo(await):
    #|                async def foo(): pass
    #|                async def foo(): pass
    #|                return await + 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0452" {
  let source =
    #|def foo(await):
    #|
    #|                async def foo(): pass
    #|
    #|                async def foo(): pass
    #|
    #|                return await + 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0453" {
  let source =
    #|def foo(await):
    #|                """spam"""
    #|                async def foo():                     pass
    #|                # 123
    #|                async def foo(): pass
    #|                # 456
    #|                return await + 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0454" {
  let source =
    #|def foo(await):
    #|                def foo(): pass
    #|                def foo(): pass
    #|                async def bar(): return await_
    #|                await_ = await
    #|                try:
    #|                    bar().send(None)
    #|                except StopIteration as ex:
    #|                    return ex.args[0] + 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0455" {
  let source =
    #|return corofn()  # comment in a1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0456" {
  let source =
    #|return a1()  # comment in a2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0457" {
  let source =
    #|Return a new copy of the test._crossinterp_definitions module.
    #|
    #|    The module's __name__ matches the "module" arg, which is either
    #|    a str or a module.
    #|
    #|    If the "module" arg is a module then the just-loaded defs are also
    #|    copied into that module.
    #|
    #|    Note that the new module is not added to sys.modules.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0458" {
  let source =
    #|raise Exception("spam")
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"Exception: spam\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0459" {
  let source =
    #|if True:
    #|            do_something()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'do_something' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0460" {
  let source =
    #|if True:
    #|            def spam(x):
    #|                return x
    #|            class Spam:
    #|                def eggs(self):
    #|                    return 42
    #|            x = Spam().eggs()
    #|            raise ValueError(spam(x))
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0461" {
  let source =
    #|if True:
    #|            def spam():
    #|                # no body
    #|            spam()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0462" {
  let source =
    #|Test the underlying C csv parser in ways that are not appropriate
    #|from the high level interface. Further tests of this nature are done
    #|in TestDialectRegistry.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0463" {
  let source =
    #|Harry's, Arlington Heights, IL, 2/1/03, Kimi Hayes
    #|Shark City, Glendale Heights, IL, 12/28/02, Prezence
    #|Tommy's Place, Blue Island, IL, 12/28/02, Blue Sunday/White Crow
    #|Stonecutters Seafood and Chop House, Lemont, IL, 12/19/02, Week Back
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0464" {
  let source =
    #|'Harry''s':'Arlington Heights':'IL':'2/1/03':'Kimi Hayes'
    #|'Shark City':'Glendale Heights':'IL':'12/28/02':'Prezence'
    #|'Tommy''s Place':'Blue Island':'IL':'12/28/02':'Blue Sunday/White Crow'
    #|'Stonecutters ''Seafood'' and Chop House':'Lemont':'IL':'12/19/02':'Week Back'
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0465" {
  let source =
    #|05/05/03?05/05/03?05/05/03?05/05/03?05/05/03?05/05/03
    #|05/05/03?05/05/03?05/05/03?05/05/03?05/05/03?05/05/03
    #|05/05/03?05/05/03?05/05/03?05/05/03?05/05/03?05/05/03
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0466" {
  let source =
    #|2147483648;43.0e12;17;abc;def
    #|147483648;43.0e2;17;abc;def
    #|47483648;43.0;170;abc;def
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0467" {
  let source =
    #|Harry's+ Arlington Heights+ IL+ 2/1/03+ Kimi Hayes
    #|Shark City+ Glendale Heights+ IL+ 12/28/02+ Prezence
    #|Tommy's Place+ Blue Island+ IL+ 12/28/02+ Blue Sunday/White Crow
    #|Stonecutters Seafood and Chop House+ Lemont+ IL+ 12/19/02+ Week Back
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0468" {
  let source =
    #|'Harry''s'+ Arlington Heights'+ 'IL'+ '2/1/03'+ 'Kimi Hayes'
    #|'Shark City'+ Glendale Heights'+' IL'+ '12/28/02'+ 'Prezence'
    #|'Tommy''s Place'+ Blue Island'+ 'IL'+ '12/28/02'+ 'Blue Sunday/White Crow'
    #|'Stonecutters ''Seafood'' and Chop House'+ 'Lemont'+ 'IL'+ '12/19/02'+ 'Week Back'
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0469" {
  let source =
    #|1,2,3,"""I see,""
    #|said the blind man","as he picked up his
    #|hammer and saw"
    #|9,8,7,6
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0470" {
  let source =
    #|abc,def
    #|ghijkl,mno
    #|ghi,jkl
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0471" {
  let source =
    #|abc,def
    #|ghijkl,mnop
    #|ghi,jkl
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0472" {
  let source =
    #|"time","forces"
    #|                        1,1.5
    #|                        0.5,5+0j
    #|                        0,0
    #|                        1+1j,6
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0473" {
  let source =
    #|"time","forces"
    #|                        0,0
    #|                        1,2
    #|                        a,b
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0474" {
  let source =
    #|a,b:c
    #|d,e
    #|f,g:c
    #|h,i
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0475" {
  let source =
    #|a,b
    #|c:d
    #|e,f
    #|g:h
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0476" {
  let source =
    #|a:b
    #|c,d
    #|e:f
    #|g,h
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'c' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0477" {
  let source =
    #|"a
    #|b","1"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0478" {
  let source =
    #|1,2,"a
    #|bc",3,4
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0479" {
  let source =
    #|f1,f2,f3
    #|1,abc,f
    #|2,5,xyz
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'f1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0480" {
  let source =
    #|a,b
    #|c,d
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0481" {
  let source =
    #|a,
    #|,d
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0482" {
  let source =
    #|"a
    #|b", 7
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0483" {
  let source =
    #|f1,f2,f3
    #|1,2,abc
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'f1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0484" {
  let source =
    #|f1,f2
    #|1,2,abc,4,5,6
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'f1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0485" {
  let source =
    #|1,2,abc,4,5,6
    #|1,2,abc
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'abc' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0486" {
  let source =
    #|"I see,"
    #|said the blind man
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0487" {
  let source =
    #|FirstName,LastName
    #|Eric,Idle
    #|Graham,Chapman,Over1,Over2
    #|
    #|Under1
    #|John,Cleese
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'FirstName' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0488" {
  let source =
    #|"
    #|","
    #|"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0489" {
  let source =
    #|Decorator factory that returns a decorator that replaces the
    #|            passed-in function with one that returns the value of 'num'
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0490" {
  let source =
    #|@%s
    #|def f(): pass
    #|assert f() is None
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0491" {
  let source =
    #|Regressions for some bugs revealed through
    #|mcsl.mro() customization (typeobject.c: mro_internal()) and
    #|cls.__bases__ assignment (typeobject.c: type_set_bases()).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0492" {
  let source =
    #|type_set_bases must check for an inheritance cycle not only through
    #|MRO of the type, which may be not yet updated in case of reentrance,
    #|but also through tp_base chain, which is assigned before diving into
    #|inner calls to mro().
    #|
    #|Otherwise, the following snippet can loop forever:
    #|    do {
    #|        // ...
    #|        type = type->tp_base;
    #|    } while (type != NULL);
    #|
    #|Functions that rely on tp_base (like solid_base and PyType_IsSubtype)
    #|would not be happy in that case, causing a stack overflow.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0493" {
  let source =
    #|type_set_bases must check for reentrancy upon finishing its job
    #|by updating tp_subclasses of old/new bases of the type.
    #|Otherwise, an implicit inheritance cycle through tp_subclasses
    #|can break functions that recurse on elements of that field
    #|(like recurse_down_subclasses and mro_hierarchy) eventually
    #|leading to a stack overflow.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0494" {
  let source =
    #|The same as test_tp_subclasses_cycle_in_update_slots, but tests
    #|a code path executed on error (goto bail).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0495" {
  let source =
    #|Extending an uninitialized type with type->tp_mro == NULL must
    #|throw a reasonable TypeError exception, instead of failing
    #|with PyErr_BadInternalCall.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0496" {
  let source =
    #|Attribute lookup on a super object must be aware that
    #|its target type can be uninitialized (type->tp_mro == NULL).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0497" {
  let source =
    #|gh-92112: A custom mro() returning a result conflicting with
    #|__bases__ and deleting itself caused a double free.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0498" {
  let source =
    #|def number_attrs(Z):
    #|    return [ 
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0499" {
  let source =
    #|Subclass of str that computes __eq__ case-insensitively.
    #|
    #|            Also computes a hash code of the string in canonical form.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0500" {
  let source =
    #|class MyKey(object):
    #|    def __hash__(self):
    #|        return hash('mykey')
    #|
    #|    def __eq__(self, other):
    #|        X.__bases__ = (Base2,)
    #|
    #|class Base(object):
    #|    mykey = 'from Base'
    #|    mykey2 = 'from Base'
    #|
    #|class Base2(object):
    #|    mykey = 'from Base2'
    #|    mykey2 = 'from Base2'
    #|
    #|X = type('X', (Base,), {MyKey(): 5})
    #|
    #|bases_before = ",".join([c.__name__ for c in X.__bases__])
    #|print(f"before={bases_before}")
    #|
    #|# mykey is initially read from Base, however, the lookup will be perfomed
    #|# again if specialization fails. The second lookup will use the new
    #|# mro set by __eq__.
    #|print(X.mykey)
    #|
    #|bases_after = ",".join([c.__name__ for c in X.__bases__])
    #|print(f"after={bases_after}")
    #|
    #|# mykey2 is read from Base2 because MyKey.__eq__ has set __bases_
    #|print(f"mykey2={X.mykey2}")
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0501" {
  let source =
    #|The __slots__ declaration takes a list of instance variables, and reserves
    #|space for exactly these in the instance. When __slots__ is used, other
    #|instance variables cannot be assigned to:
    #|
    #|    >>> a = defaultdict2(default=0.0)
    #|    >>> a[1]
    #|    0.0
    #|    >>> a.default = -1
    #|    >>> a[1]
    #|    -1
    #|    >>> a.x1 = 1
    #|    Traceback (most recent call last):
    #|      File "<stdin>", line 1, in ?
    #|    AttributeError: 'defaultdict2' object has no attribute 'x1' and no __dict__ for setting new attributes
    #|    >>>
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0502" {
  let source =
    #|Method resolution order
    #|
    #|This example is implicit in the writeup.
    #|
    #|>>> class A:    # implicit new-style class
    #|...     def save(self):
    #|...         print("called A.save()")
    #|>>> class B(A):
    #|...     pass
    #|>>> class C(A):
    #|...     def save(self):
    #|...         print("called C.save()")
    #|>>> class D(B, C):
    #|...     pass
    #|
    #|>>> D().save()
    #|called C.save()
    #|
    #|>>> class A(object):  # explicit new-style class
    #|...     def save(self):
    #|...         print("called A.save()")
    #|>>> class B(A):
    #|...     pass
    #|>>> class C(A):
    #|...     def save(self):
    #|...         print("called C.save()")
    #|>>> class D(B, C):
    #|...     pass
    #|
    #|>>> D().save()
    #|called C.save()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0503" {
  let source =
    #|Cooperative methods and "super"
    #|
    #|>>> print(D().m()) # "DCBA"
    #|DCBA
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0504" {
  let source =
    #|Backwards incompatibilities
    #|
    #|>>> class A:
    #|...     def foo(self):
    #|...         print("called A.foo()")
    #|
    #|>>> class B(A):
    #|...     pass
    #|
    #|>>> class C(A):
    #|...     def foo(self):
    #|...         B.foo(self)
    #|
    #|>>> C().foo()
    #|called A.foo()
    #|
    #|>>> class C(A):
    #|...     def foo(self):
    #|...         A.foo(self)
    #|>>> C().foo()
    #|called A.foo()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0505" {
  let source =
    #|split table must keep correct insertion
    #|        order when attributes are adding using setdefault()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0506" {
  let source =
    #|{x: y for y, x in ((1, 2), (3, 4))} = 5
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0507" {
  let source =
    #|{x: y for y, x in ((1, 2), (3, 4))} += 5
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0508" {
  let source =
    #|Test that lambda functionality stays the same.  The output produced
    #|        currently is, I suspect invalid because of the unencoded brackets in the
    #|        HTML, "<lambda>".
    #|
    #|        The subtraction lambda method is tested.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0509" {
  let source =
    #|Test that the server correctly automatically wraps references to
    #|        PEPS and RFCs with links, and that it linkifies text starting with
    #|        http or ftp protocol prefixes.
    #|
    #|        The documentation for the "add" method contains the test material.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0510" {
  let source =
    #|Test the presence of three consecutive system.* methods.
    #|
    #|        This also tests their use of parameter type recognition and the
    #|        systems related to that process.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0511" {
  let source =
    #|Test that selfdot values are made strong automatically in the
    #|        documentation.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0512" {
  let source =
    #|x = foo()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'foo' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0513" {
  let source =
    #|Perform TestCase-specific configuration on a function before testing.
    #|
    #|        By default, this does nothing. Example usage: spinning a function so
    #|        that a JIT will optimize it. Subclasses should override this as needed.
    #|
    #|        Args:
    #|            func: function to configure.
    #|            *args: any arguments that should be passed to func, if calling it.
    #|
    #|        Returns:
    #|            Nothing. Work will be performed on func in-place.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0514" {
  let source =
    #|Test the errno module
    #|   Roger E. Masse
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0515" {
  let source =
    #|try: pass
    #|except ValueError: pass
    #|except* TypeError: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0516" {
  let source =
    #|try: pass
    #|except* ValueError: pass
    #|except TypeError: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0517" {
  let source =
    #|try: pass
    #|except ValueError as e: pass
    #|except* TypeError: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0518" {
  let source =
    #|try: pass
    #|except* ValueError as e: pass
    #|except TypeError: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0519" {
  let source =
    #|try: pass
    #|except ValueError: pass
    #|except* TypeError as e: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0520" {
  let source =
    #|try: pass
    #|except* ValueError: pass
    #|except TypeError as e: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0521" {
  let source =
    #|try: pass
    #|except ValueError: pass
    #|except*: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0522" {
  let source =
    #|try: pass
    #|except* ValueError: pass
    #|except: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0523" {
  let source =
    #|try:
    #|    raise ValueError
    #|except* Exception as e:
    #|    break
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0524" {
  let source =
    #|for i in range(5):
    #|    try:
    #|        pass
    #|    except* Exception as e:
    #|        if i == 2:
    #|            break
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 6:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0525" {
  let source =
    #|for i in range(5):
    #|    try:
    #|        pass
    #|    except* Exception as e:
    #|        if i == 2:
    #|            break
    #|    finally:
    #|        pass
    #|    return 0
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 6:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0526" {
  let source =
    #|for i in range(5):
    #|    try:
    #|        raise ValueError
    #|    except* Exception as e:
    #|        continue
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0527" {
  let source =
    #|for i in range(5):
    #|    try:
    #|        pass
    #|    except* Exception as e:
    #|        if i == 2:
    #|            continue
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 6:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0528" {
  let source =
    #|for i in range(5):
    #|    try:
    #|        pass
    #|    except* Exception as e:
    #|        if i == 2:
    #|            continue
    #|    finally:
    #|        pass
    #|    return 0
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 6:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0529" {
  let source =
    #|def f():
    #|    try:
    #|        raise ValueError
    #|    except* Exception as e:
    #|        return 42
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0530" {
  let source =
    #|def f():
    #|    try:
    #|        pass
    #|    except* Exception as e:
    #|        return 42
    #|    finally:
    #|        finished = True
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0531" {
  let source =
    #|Assert that the exception matches the template
    #|
    #|           A template describes the shape of exc. If exc is a
    #|           leaf exception (i.e., not an exception group) then
    #|           template is an exception instance that has the
    #|           expected type and args value of exc. If exc is an
    #|           exception group, then template is a list of the
    #|           templates of its nested exceptions.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0532" {
  let source =
    #|The base class for all the objects under test, equipped with various
    #|testing features.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0533" {
  let source =
    #|Test finalization of an object having a single cyclic reference to
    #|itself.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0534" {
  let source =
    #|Test finalization of a cyclic chain.  These tests are similar in
    #|spirit to the self-cycle tests above, but the collectable object
    #|graph isn't trivial anymore.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0535" {
  let source =
    #|PEP 442 finalizer.  Record that this was called, check the
    #|object is in a sane state, and invoke a side effect.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0536" {
  let source =
    #|from __future__ import barry_as_FLUFL
    #|2 {0} 3
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0537" {
  let source =
    #|A separate thread isn't needed to make this code crash, but it does
    #|make crashes more consistent, since it means sneaky_frame_object is
    #|backed by freed memory after the thread completes!
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0538" {
  let source =
    #|import gc
    #|
    #|gc.set_threshold(1,1,1)
    #|class GCHello:
    #|    def __del__(self):
    #|        print("Destroyed from gc")
    #|
    #|def gen():
    #|    yield
    #|
    #|fd = open(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 11:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0539" {
  let source =
    #|)
    #|            l = [fd, GCHello()]
    #|            l.append(l)
    #|            del fd
    #|            del l
    #|            gen()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0540" {
  let source =
    #|Stash a reference to the entire stack for walking later.
    #|
    #|It may look crazy, but you'd be surprised how common this is
    #|when using a test runner (like pytest). The typical recipe is:
    #|ResourceWarning + -Werror + a custom sys.unraisablehook.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0541" {
  let source =
    #|def func3(s): pass
    #|func4 = type(func3)(func3.__code__, {})
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'type' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0542" {
  let source =
    #|Create a reference cycle with multiple __del__ methods.
    #|
    #|    An object in a reference cycle will never have zero references,
    #|    and so must be garbage collected.  If one or more objects in the
    #|    cycle have __del__ methods, the gc refuses to guess an order,
    #|    and leaves the cycle uncollected.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0543" {
  let source =
    #|if 1:
    #|        import _datetime
    #|        class C:
    #|            def __del__(self):
    #|                print('__del__ called')
    #|                _datetime.timedelta(days=1)  # crash?
    #|
    #|        l = [C()]
    #|        l.append(l)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module _datetime is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0544" {
  let source =
    #|if 1:
    #|            import gc
    #|            import _testcapi
    #|            @_testcapi.with_tp_del
    #|            class X:
    #|                def __init__(self, name):
    #|                    self.name = name
    #|                def __repr__(self):
    #|                    return "<X %%r>" %% self.name
    #|                def __tp_del__(self):
    #|                    pass
    #|
    #|            x = X('first')
    #|            x.x = x
    #|            x.y = X('second')
    #|            del x
    #|            gc.set_debug(%s)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 9:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0545" {
  let source =
    #|if 1:
    #|            class C:
    #|                def __del__(self):
    #|                    print('__del__ called')
    #|            l = [C()]
    #|            l.append(l)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0546" {
  let source =
    #|if 1:
    #|            import gc
    #|            gc.set_debug(%s)
    #|            gc.collect()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0547" {
  let source =
    #|if 1:
    #|            class ClassWithDel:
    #|                def __del__(self):
    #|                    print('__del__ called')
    #|            a = ClassWithDel()
    #|            a.link = a
    #|            raise SystemExit(0)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0548" {
  let source =
    #|class BaseNode:
    #|    def __del__(self):
    #|        BaseNode.next = BaseNode.next.next
    #|        fail = BaseNode.next.next
    #|
    #|class Node(BaseNode):
    #|    pass
    #|
    #|BaseNode.next = Node()
    #|BaseNode.next.next = Node()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0549" {
  let source =
    #|Create a sufficiently nested container object so that the
    #|            trashcan mechanism is invoked when deallocating it.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0550" {
  let source =
    #|if 1:
    #|                class C:
    #|                    def __del__(self):
    #|                        print('__del__ called')
    #|                l = [C()]
    #|                l.append(l)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0551" {
  let source =
    #|import gc
    #|import unittest
    #|
    #|
    #|class Test(unittest.TestCase):
    #|    def test_something(self):
    #|        gc.freeze()
    #|        gc.collect()
    #|        gc.unfreeze()
    #|
    #|
    #|if __name__ == "__main__":
    #|    unittest.main()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module gc is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0552" {
  let source =
    #|from test.support import gc_collect, SuppressCrashReport
    #|
    #|a = [1, 2, 3]
    #|b = [a, a]
    #|a.append(b)
    #|
    #|# Avoid coredump when Py_FatalError() calls abort()
    #|SuppressCrashReport().__enter__()
    #|
    #|# Simulate the refcount of "a" being too low (compared to the
    #|# references held on it by live data), but keeping it above zero
    #|# (to avoid deallocating it):
    #|import ctypes
    #|ctypes.pythonapi.Py_DecRef(ctypes.py_object(a))
    #|del a
    #|del b
    #|
    #|# The garbage collector should now have a fatal error
    #|# when it reaches the broken object
    #|gc_collect()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module test.support is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0553" {
  let source =
    #|import ast
    #|import codecs
    #|from test import support
    #|
    #|# Small AST tree to keep their AST types alive
    #|tree = ast.parse("def f(x, y): return 2*x-y")
    #|
    #|# Store the tree somewhere to survive until the last GC collection
    #|support.late_deletion(tree)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module ast is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0554" {
  let source =
    #|import asyncio
    #|from contextvars import ContextVar
    #|
    #|context_loop = ContextVar("context_loop", default=None)
    #|loop = asyncio.new_event_loop()
    #|context_loop.set(loop)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module asyncio is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0555" {
  let source =
    #|if 1:
    #|                import sys
    #|                sys.path.insert(0, %r)
    #|                import gctest
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0556" {
  let source =
    #|
    #|            def gen():
    #|                try:
    #|                    yield
    #|                except:
    #|                    resurrected.append(g)
    #|
    #|            g = gen()
    #|            next(g)
    #|        
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0557" {
  let source =
    #|snapshot, live_locals = next(g())
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'next' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0558" {
  let source =
    #|Generators are weakly referencable:
    #|
    #|>>> import weakref
    #|>>> def gen():
    #|...     yield 'foo!'
    #|...
    #|>>> wr = weakref.ref(gen)
    #|>>> wr() is gen
    #|True
    #|>>> p = weakref.proxy(gen)
    #|
    #|Generator-iterators are weakly referencable as well:
    #|
    #|>>> gi = gen()
    #|>>> wr = weakref.ref(gi)
    #|>>> wr() is gi
    #|True
    #|>>> p = weakref.proxy(gi)
    #|>>> list(p)
    #|['foo!']
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0559" {
  let source =
    #|def gen():
    #|    try:
    #|        yield
    #|    except:
    #|        resurrected.append(g)
    #|
    #|g = gen()
    #|next(g)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'next' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0560" {
  let source =
    #|Examples from the Library Reference:  Doc/lib/libgetopt.tex
    #|
    #|An example using only Unix style options:
    #|
    #|
    #|>>> import getopt
    #|>>> args = '-a -b -cfoo -d bar a1 a2'.split()
    #|>>> args
    #|['-a', '-b', '-cfoo', '-d', 'bar', 'a1', 'a2']
    #|>>> optlist, args = getopt.getopt(args, 'abc:d:')
    #|>>> optlist
    #|[('-a', ''), ('-b', ''), ('-c', 'foo'), ('-d', 'bar')]
    #|>>> args
    #|['a1', 'a2']
    #|
    #|Using long option names is equally easy:
    #|
    #|
    #|>>> s = '--condition=foo --testing --output-file abc.def -x a1 a2'
    #|>>> args = s.split()
    #|>>> args
    #|['--condition=foo', '--testing', '--output-file', 'abc.def', '-x', 'a1', 'a2']
    #|>>> optlist, args = getopt.getopt(args, 'x', [
    #|...     'condition=', 'output-file=', 'testing'])
    #|>>> optlist
    #|[('--condition', 'foo'), ('--testing', ''), ('--output-file', 'abc.def'), ('-x', '')]
    #|>>> args
    #|['a1', 'a2']
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0561" {
  let source =
    #|Test a venv layout on Windows.
    #|
    #|        This layout is discovered by the presence of %__PYVENV_LAUNCHER__%,
    #|        specifying the original launcher executable. site.py is responsible
    #|        for updating prefix and exec_prefix.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0562" {
  let source =
    #|Test registry lookup on Windows.
    #|
    #|        On Windows there are registry entries that are intended for other
    #|        applications to register search paths.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0563" {
  let source =
    #|Test an in-build-tree layout on POSIX.
    #|
    #|        This layout is discovered from the presence of pybuilddir.txt, which
    #|        contains the relative path from the executable's directory to the
    #|        platstdlib path.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0564" {
  let source =
    #|Test framework layout on macOS
    #|
    #|       This layout is primarily detected using a compile-time option
    #|       (WITH_NEXT_FRAMEWORK).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0565" {
  let source =
    #|Test framework layout on macOS with alternate framework name
    #|
    #|       ``--with-framework-name=DebugPython``
    #|
    #|       This layout is primarily detected using a compile-time option
    #|       (WITH_NEXT_FRAMEWORK).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0566" {
  let source =
    #|Test a venv layout on macOS using a framework build
    #|
    #|        ``--with-framework-name=DebugPython``
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0567" {
  let source =
    #|Test a venv layout on macOS.
    #|
    #|        This layout is discovered when 'executable' and 'real_executable' match,
    #|        but $__PYVENV_LAUNCHER__ has been set to the original process.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0568" {
  let source =
    #|Test an in-build-tree layout via symlink on macOS.
    #|
    #|        This layout is discovered from the presence of pybuilddir.txt, which
    #|        contains the relative path from the executable's directory to the
    #|        platstdlib path.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0569" {
  let source =
    #|{}.{} -{!r}
    #|{} +{!r}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0570" {
  let source =
    #|This module includes tests for syntax errors that occur when a name
    #|declared as `global` is used in ways that violate the language
    #|specification, such as after assignment, usage, or annotation. The tests
    #|verify that syntax errors are correctly raised for improper `global`
    #|statements following variable use or assignment within functions.
    #|Additionally, it tests various name-binding scenarios for global
    #|variables to ensure correct behavior.
    #|
    #|See `test_scope.py` for additional related behavioral tests covering
    #|variable scoping and usage in different contexts.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0571" {
  let source =
    #|def fn(name_param):
    #|    global name_param
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0572" {
  let source =
    #|def fn():
    #|    name_assign = 1
    #|    global name_assign
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0573" {
  let source =
    #|def fn():
    #|    print(name_use)
    #|    global name_use
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0574" {
  let source =
    #|def fn():
    #|    name_annot: int
    #|    global name_annot
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0575" {
  let source =
    #|x: Tuple[int, ...] = a,*b,c
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0576" {
  let source =
    #|del a, (b[0].c, (d.e, f.g[1:2])), [h.i.j], ()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0577" {
  let source =
    #|assert x, "msg"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0578" {
  let source =
    #|assert False, "msg"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"AssertionError: msg\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0579" {
  let source =
    #|assert x, "msg" 
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0580" {
  let source =
    #|assert(x, "msg")
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0581" {
  let source =
    #|try:
    #|    pass
    #|except Exception as a.b:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0582" {
  let source =
    #|try:
    #|    pass
    #|except Exception as a[b]:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0583" {
  let source =
    #|try:
    #|    pass
    #|except* Exception as a.b:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0584" {
  let source =
    #|try:
    #|    pass
    #|except* Exception as a[b]:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0585" {
  let source =
    #|try:
    #|    pass
    #|except*:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0586" {
  let source =
    #|x is None
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0587" {
  let source =
    #|x is False
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0588" {
  let source =
    #|x is True
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0589" {
  let source =
    #|x is ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0590" {
  let source =
    #|None is x
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0591" {
  let source =
    #|False is x
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0592" {
  let source =
    #|True is x
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0593" {
  let source =
    #|... is x
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0594" {
  let source =
    #|[[1, 2] [i]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'i' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0595" {
  let source =
    #|[{(1, 2): 3} [i, j]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'i' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0596" {
  let source =
    #|Test suite for HMAC.
    #|
    #|Python provides three different implementations of HMAC:
    #|
    #|- OpenSSL HMAC using OpenSSL hash functions.
    #|- HACL* HMAC using HACL* hash functions.
    #|- Generic Python HMAC using user-defined hash functions.
    #|
    #|The generic Python HMAC implementation is able to use OpenSSL
    #|callables or names, HACL* named hash functions or arbitrary
    #|objects implementing PEP 247 interface.
    #|
    #|In the two first cases, Python HMAC wraps a C HMAC object (either OpenSSL
    #|or HACL*-based). As a last resort, HMAC is re-implemented in pure Python.
    #|It is however interesting to test the pure Python implementation against
    #|the OpenSSL and HACL* hash functions.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0597" {
  let source =
    #|Pure Python implementation of HMAC.
    #|
    #|    The underlying hash functions may be OpenSSL-based or HACL* based,
    #|    depending on whether OpenSSL is present or not.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0598" {
  let source =
    #|Mixin delegating to <module>.HMAC() and <module>.HMAC(...).digest().
    #|
    #|    Both the C implementation and the Python implementation of HMAC should
    #|    expose a HMAC class with the same functionalities.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0599" {
  let source =
    #|Python implementation of HMAC using hmac.HMAC().
    #|
    #|    The underlying hash functions are OpenSSL-based but
    #|    _init_old() is used instead of _init_openssl_hmac().
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0600" {
  let source =
    #|Python implementation of HMAC using hmac.HMAC().
    #|
    #|    The underlying hash functions are HACL*-based but
    #|    _init_old() is used instead of _init_builtin_hmac().
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0601" {
  let source =
    #|Python implementation of HMAC using hmac.new().
    #|
    #|    The underlying hash functions are OpenSSL-based but
    #|    _init_old() is used instead of _init_openssl_hmac().
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0602" {
  let source =
    #|Python implementation of HMAC using hmac.new().
    #|
    #|    The underlying hash functions are HACL-based but
    #|    _init_old() is used instead of _init_openssl_hmac().
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0603" {
  let source =
    #|OpenSSL implementation of HMAC.
    #|
    #|    The underlying hash functions are also OpenSSL-based.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0604" {
  let source =
    #|Built-in HACL* implementation of HMAC.
    #|
    #|    The underlying hash functions are also HACL*-based.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0605" {
  let source =
    #|Test the hmac.new() and hmac.digest() functions.
    #|
    #|    Note that "self.hmac" is imported by blocking "_hashlib" and "_hmac".
    #|    For testing functions in "hmac", extend PyMiscellaneousTests instead.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0606" {
  let source =
    #|Sanity checks for HMAC objects and their object interface.
    #|
    #|    The tests here use a common digestname and do not check all supported
    #|    hash functions.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0607" {
  let source =
    #|HMAC-BLAKE2 is not standardized as BLAKE2 is a keyed hash function.
    #|
    #|    In particular, there is no official test vectors for HMAC-BLAKE2.
    #|    However, we can test that the HACL* interface is correctly used by
    #|    checking against the pure Python implementation output.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0608" {
  let source =
    #|Create a new HMAC object.
    #|
    #|        Implementations should accept arbitrary 'digestmod' as this
    #|        method can be used to test which exceptions are being raised.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0609" {
  let source =
    #|Compute a HMAC digest.
    #|
    #|        Implementations should accept arbitrary 'digestmod' as this
    #|        method can be used to test which exceptions are being raised.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0610" {
  let source =
    #|Alternative implementation of hmac_new().
    #|
    #|        This is typically useful when one needs to test against an HMAC
    #|        implementation which only recognizes underlying hash functions
    #|        by their name (all HMAC implementations must at least recognize
    #|        hash functions by their names but some may use aliases such as
    #|        `hashlib.sha1` instead of "sha1").
    #|
    #|        Unlike hmac_new(), this method may assert the type of 'hashname'
    #|        as it should only be used in tests that are expected to create
    #|        a HMAC object.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0611" {
  let source =
    #|Alternative implementation of hmac_digest().
    #|
    #|        Unlike hmac_digest(), this method may assert the type of 'hashname'
    #|        as it should only be used in tests that are expected to compute a
    #|        HMAC digest.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0612" {
  let source =
    #|Check that HMAC(key, msg) == digest.
    #|
    #|        The 'hashfunc' and 'hashname' are used as 'digestmod' values,
    #|        thereby allowing to test the underlying dispatching mechanism.
    #|
    #|        Note that 'hashfunc' may be a string, a callable, or a PEP-257
    #|        module. Note that not all HMAC implementations may recognize the
    #|        same set of types for 'hashfunc', but they should always accept
    #|        a hash function by its name.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0613" {
  let source =
    #|Check that HMAC(key, msg) == digest.
    #|
    #|        This test uses the `hmac_new()` method to create HMAC objects.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0614" {
  let source =
    #|Check that HMAC(key, msg) == digest.
    #|
    #|        This test uses the `hmac_new_by_name()` method to create HMAC objects.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0615" {
  let source =
    #|Check that HMAC(key, msg) == digest.
    #|
    #|        This also tests that using an empty/None initial message and
    #|        then calling `h.update(msg)` produces the same result, namely
    #|        that HMAC(key, msg) is equivalent to HMAC(key).update(msg).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0616" {
  let source =
    #|Check and return a HMAC digest computed by hmac_digest_func().
    #|
    #|        This HMAC digest is computed by:
    #|
    #|            hmac_digest_func(key, msg, **hmac_digest_kwds)
    #|
    #|        This is typically useful for checking one-shot HMAC functions.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0617" {
  let source =
    #|Generate cases for missing digestmod tests.
    #|
    #|        Only the Python implementation should consider "falsey" 'digestmod'
    #|        values as being equivalent to a missing one.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0618" {
  let source =
    #|Check that hmac.digest() falls back to pure Python.
    #|
    #|        The *hmac* argument implements the HMAC module interface.
    #|        The *size* argument is a large key size or message size that would
    #|        trigger an OverflowError in the C implementation(s) of hmac.digest().
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0619" {
  let source =
    #|<foo:bar   
    #|   one="1"	two=2   >
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0620" {
  let source =
    #|<!-- not a comment --> &not-an-entity-ref;
    #|                  <a href="" /> </p><p> <span></span></style>
    #|                  '</script' + '>'
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0621" {
  let source =
    #|<br></label</p><br></div end tmAd-leaderBoard><br></<h4><br></li class="unit"><br></li
    #|						</ul><br></><br>
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0622" {
  let source =
    #|<!ELEMENT br EMPTY><! not really a comment ><! not a comment either --><! -- close enough --><!><!<-- this was an empty comment><!!! another bogus comment !!!><![with square brackets]!><![
    #|multiline
    #|bogusness
    #|]!><![more brackets]-[and a hyphen]!><![cdata[should be uppercase]]><![CDATA [whitespaces are not ignored]]><![CDATA]]>
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 unmatched ']'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0623" {
  let source =
    #|<!DOCTYPE html PUBLIC 'foo'>
    #|<HTML>&entity;&#32;
    #|<!--comment1a
    #|-></foo><bar>&lt;<?pi?></foo<bar
    #|comment1b-->
    #|<Img sRc='Bar' isMAP>sample
    #|text
    #|&#x201C;
    #|<!--comment2a-- --comment2b-->
    #|</Html>
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0624" {
  let source =
    #|foo = <
    #|/script> 
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0625" {
  let source =
    #|<!-- //
    #|var foo = 3.14;
    #|// -->
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0626" {
  let source =
    #|<html <html>te>>xt&a<<bc</a></html>
    #|<img src="URL><//img></html</html>
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0627" {
  let source =
    #|if (a < b && a > b) {
    #|    printf("[<marquee>How?</marquee>]");
    #|}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0628" {
  let source =
    #|<a b='xxx
    #|	xxx' c="yyy	
    #|yyy" d='	xyz
    #|'>
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0629" {
  let source =
    #|<a b=	x c=
    #|y>
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0630" {
  let source =
    #|[
    #|multiline
    #|bogusness
    #|]!
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0631" {
  let source =
    #|comment1a
    #|-></foo><bar>&lt;<?pi?></foo<bar
    #|comment1b
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0632" {
  let source =
    #|<script type="text/javascript">
    #|<!-- begin hiding
    #|document.cookie = "Customer=\"WILE_E_COYOTE\"; Path=/acme; Version=1";
    #|// end hiding -->
    #|</script>
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0633" {
  let source =
    #|<script type="text/javascript">
    #|<!-- begin hiding
    #|document.cookie = "Customer=\"WILE_E_COYOTE\"; Path=/acme";
    #|// end hiding -->
    #|</script>
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0634" {
  let source =
    #|Set-Cookie: eggs=scrambled; Path=bar; Secure
    #|Set-Cookie: foo=foo
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0635" {
  let source =
    #|Set-Cookie: chips=ahoy
    #|Set-Cookie: vienna=finger
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0636" {
  let source =
    #|<script type="text/javascript">
    #|<!-- begin hiding
    #|document.cookie = "%s=%s; Path=/foo";
    #|// end hiding -->
    #|</script>
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0637" {
  let source =
    #|E=mc2; L="Loves"; fudge=
    #|;
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0638" {
  let source =
    #|if 1:
    #|        # Subinterpreters maintain and enforce their own limit
    #|        import sys
    #|        sys.set_int_max_str_digits(2323)
    #|        try:
    #|            int('3'*3333)
    #|        except ValueError:
    #|            pass
    #|        else:
    #|            raise AssertionError('Expected a int max str digits ValueError.')
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module sys is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0639" {
  let source =
    #|Test correct treatment of hex/oct constants.
    #|
    #|This is complex because of changes due to PEP 237.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0640" {
  let source =
    #|Ensure exception does not display a context by default
    #|
    #|Wraps unittest.TestCase.assertRaisesRegex
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0641" {
  let source =
    #|a
    #| - b
    #| - fooled you! - c
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0642" {
  let source =
    #|import typing, copyreg, itertools; copyreg.buggy_tee = itertools.tee(())
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module typing is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0643" {
  let source =
    #|def f(p, *):
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0644" {
  let source =
    #|def f(p1, *, p1=100):
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0645" {
  let source =
    #|def f(p1, *k1, k1=100):
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0646" {
  let source =
    #|def f(p1, *, k1, k1=100):
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0647" {
  let source =
    #|def f(p1, *, **k1):
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0648" {
  let source =
    #|def f(p1, *, k1, **k1):
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0649" {
  let source =
    #|def f(p1, *, None, **k1):
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0650" {
  let source =
    #|def f(p, *, (k1, k2), **kw):
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0651" {
  let source =
    #|def f(%s):
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0652" {
  let source =
    #|def f(*, %s):
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0653" {
  let source =
    #|import _testcapi, sys
    #|# Prime the freelist
    #|l = [None]
    #|del l
    #|_testcapi.set_nomemory(0)
    #|l = [None]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module _testcapi is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0654" {
  let source =
    #|import _testinternalcapi
    #|
    #|l = []
    #|def lappend(l, x, y):
    #|    l.append((x, y))
    #|for x in range(_testinternalcapi.SPECIALIZATION_THRESHOLD):
    #|    lappend(l, None, None)
    #|try:
    #|    lappend(list, None, None)
    #|except TypeError:
    #|    pass
    #|else:
    #|    raise AssertionError
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module _testinternalcapi is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0655" {
  let source =
    #|res = [super for x in [1]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'super' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0656" {
  let source =
    #|res = [__class__ for x in [1]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__class__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0657" {
  let source =
    #|__class__ = 2
    #|class C:
    #|    res = [__class__ for x in [1]]
    #|res = C.res
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"SystemError: compiler_lookup_arg(name='__class__') with reftype=1 failed in <module>; freevars of code C: ('__class__',)\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0658" {
  let source =
    #|[super for _ in [1]]
    #|[__class__ for _ in [1]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'super' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0659" {
  let source =
    #|def inner():
    #|    return g
    #|[g for g in range(5)]
    #|x = inner()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'g' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0660" {
  let source =
    #|global g
    #|x = g
    #|g = 2
    #|items = [g for g in [1]]
    #|y = g
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'g' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0661" {
  let source =
    #|global g
    #|x = g
    #|g = 2
    #|items = [g for x in [1]]
    #|y = g
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'g' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0662" {
  let source =
    #|import sys
    #|[i for i in range(2)]
    #|i = 20
    #|sys._getframe().f_locals
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module sys is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0663" {
  let source =
    #|[x for x in [1]]
    #|x
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0664" {
  let source =
    #|a = 1
    #|def f():
    #|    func, = [(lambda: b) for b in [a]]
    #|    return b, func()
    #|x = f()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'b' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0665" {
  let source =
    #|a = 1
    #|def f():
    #|    (func, inner_b), = [[lambda: b for b in c] + [b] for c in [[a]]]
    #|    return b, inner_b, func()
    #|x = f()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'b' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0666" {
  let source =
    #|class C:
    #|    y = 2
    #|    vals = [(x, y) for x in range(2)]
    #|vals = C.vals
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0667" {
  let source =
    #|y = 1
    #|class C:
    #|    y = 2
    #|    vals = [(x, y) for x in range(2)]
    #|vals = C.vals
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0668" {
  let source =
    #|y = 1
    #|class C:
    #|    global y
    #|    y = 2
    #|    # Ensure the listcomp uses the global, not the value in the
    #|    # class namespace
    #|    locals()['y'] = 3
    #|    vals = [(x, y) for x in range(2)]
    #|vals = C.vals
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0669" {
  let source =
    #|y = 1
    #|class C:
    #|    nonlocal y
    #|    y = 2
    #|    # Ensure the listcomp uses the global, not the value in the
    #|    # class namespace
    #|    locals()['y'] = 3
    #|    vals = [(x, y) for x in range(2)]
    #|vals = C.vals
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0670" {
  let source =
    #|def b():
    #|    [a for b in [1] for _ in []]
    #|    return b, locals()
    #|r, s = b()
    #|x = r is b
    #|y = list(s.keys())
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'locals' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0671" {
  let source =
    #|l = [1, 2]
    #|y = 0
    #|items = [locals()["x"] for x in l]
    #|items2 = [vars()["x"] for x in l]
    #|items3 = [("x" in dir()) for x in l]
    #|items4 = [eval("x") for x in l]
    #|# x is available, and does not overwrite y
    #|[exec("y = x") for x in l]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'locals' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0672" {
  let source =
    #|value = ["ab"]
    #|result = snapshot = None
    #|try:
    #|    result = [{func}(value) for value in value]
    #|except ValueError:
    #|    snapshot = value
    #|    raise
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'ValueError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0673" {
  let source =
    #|value = ["ab"]
    #|result = snapshot = None
    #|try:
    #|    result = [{func}(value) for value in value]
    #|finally:
    #|    snapshot = value
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'func' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0674" {
  let source =
    #|value = [1, None]
    #|try:
    #|    [v for v in value].sort()
    #|except TypeError:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'TypeError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0675" {
  let source =
    #|val = "a" in [sys._getframe().f_locals for a in [0]][0]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'sys' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0676" {
  let source =
    #|val = [sys._getframe().f_locals["a"] for a in [0]][0]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'sys' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0677" {
  let source =
    #|x = 3
    #|[x for x in (1, 2)]
    #|dir()
    #|y = [x]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'dir' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0678" {
  let source =
    #|[x for x in [1]]
    #|y = [x for _ in [1]]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0679" {
  let source =
    #|in (range(300),)]
    #|           dir()
    #|           y = [
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ']'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0680" {
  let source =
    #|class _C:
    #|    {code}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0681" {
  let source =
    #|def _f():
    #|    {code}
    #|    return locals()
    #|_out = _f()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'code' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0682" {
  let source =
    #|Verify that the result of a/b is correctly rounded, by
    #|        comparing it with a pure Python implementation of correctly
    #|        rounded division.  b should be nonzero.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0683" {
  let source =
    #|Product of integers in range(start, stop, 2), computed recursively.
    #|    start and stop should both be odd, with start <= stop.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0684" {
  let source =
    #|Generators are documented as raising a StopIteration
    #|           when they terminate.
    #|           However, we don't do that if we can avoid it, for speed.
    #|           sys.monitoring handles that by injecting a STOP_ITERATION
    #|           event when we would otherwise have skip the RAISE event.
    #|           This test checks that both paths record an equivalent event.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0685" {
  let source =
    #|class A:
    #|    def method(self, x):
    #|        return x
    #|
    #|class B(A):
    #|    def method(self, x):
    #|        return super(
    #|        ).method(
    #|            x
    #|        )
    #|
    #|b = B()
    #|def f():
    #|    return b.method(1)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0686" {
  let source =
    #|class A:
    #|    def method(self, x):
    #|        return x
    #|
    #|class B(A):
    #|    def method(self, x):
    #|        return super(
    #|            x,
    #|            self,
    #|        ).method(
    #|            x
    #|        )
    #|
    #|b = B()
    #|def f():
    #|    try:
    #|        return b.method(1)
    #|    except TypeError:
    #|        pass
    #|    else:
    #|        assert False, "should have raised TypeError"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0687" {
  let source =
    #|class A:
    #|    x = 1
    #|
    #|class B(A):
    #|    def method(self):
    #|        return super(
    #|        ).x
    #|
    #|b = B()
    #|def f():
    #|    return b.method()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0688" {
  let source =
    #|class C:
    #|    def method(self):
    #|        return {cls}().__repr__{call}
    #|c = C()
    #|def f():
    #|    return c.method()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0689" {
  let source =
    #|class Foo():
    #|            [(42, 1 + ((( j := i )))) for i in range(5)]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0690" {
  let source =
    #|class Foo:
    #|            def bar(self):
    #|                [[(__x:=2) for _ in range(2)] for __x in range(2)]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0691" {
  let source =
    #|Where all variables are positive integers, and a is at least as large
    #|as the n'th root of x, this algorithm returns the floor of the n'th
    #|root of x (and roughly doubling the number of accurate bits per
    #|iteration):
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0692" {
  let source =
    #|def spam():
    #|    (a := 5)
    #|print(a)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0693" {
  let source =
    #|Create an object that uses deferred reference counting.
    #|
    #|    Only objects that use deferred refence counting may be stored in inline
    #|    caches in free-threaded builds. This constructs a new class named Foo,
    #|    which uses deferred reference counting.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0694" {
  let source =
    #|Create a dictionary an object with a this table:
    #|            index | key | value
    #|            ----- | --- | -----
    #|              0   | 'b' | 'value'
    #|              1   | 'b' | NULL
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0695" {
  let source =
    #|Builtin dict preserves insertion order.
    #|
    #|    Reuse some of tests in OrderedDict selectively.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0696" {
  let source =
    #|dict resizes after a certain number of insertion operations,
    #|whether or not there were deletions that freed up slots in the
    #|hash table.  During fast node lookup, OrderedDict must correctly
    #|respond to all resizes, even if the current "size" is the same
    #|as the old one.  We verify that here by forcing a dict resize
    #|on a sparse odict and then perform an operation that should
    #|trigger an odict resize (e.g. popitem).  One key aspect here is
    #|that we will keep the size of the odict the same at each popitem
    #|call.  This verifies that we handled the dict resize properly.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0697" {
  let source =
    #|copy: %s
    #|od: %s
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0698" {
  let source =
    #|import sys; sys.exit(2 if "%s" %s %s else 3)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module sys is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0699" {
  let source =
    #|# From inside environment using this Python, with pyperf installed:
    #|sudo $(which pyperf) system tune &&          $(which python) -m test.test_patma --rigorous;     sudo $(which pyperf) system reset
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0700" {
  let source =
    #|match ...:
    #|    case "a" | a:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0701" {
  let source =
    #|match ...:
    #|    case [a, [b] | [c] | [d]]:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0702" {
  let source =
    #|match ...:
    #|    case Class(a=_, a=_):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0703" {
  let source =
    #|match ...:
    #|    case 0+0:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0704" {
  let source =
    #|match ...:
    #|    case {0+0: _}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0705" {
  let source =
    #|match ...:
    #|    case {**rest, "key": value}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0706" {
  let source =
    #|match ...:
    #|    case {"first": first, **rest, "last": last}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0707" {
  let source =
    #|match ...:
    #|    case {**_}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0708" {
  let source =
    #|match ...:
    #|    case 42 as _:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0709" {
  let source =
    #|match ...:
    #|    case (*x):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0710" {
  let source =
    #|match ...:
    #|    case {f"": _}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0711" {
  let source =
    #|match ...:
    #|    case a, a:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0712" {
  let source =
    #|match ...:
    #|    case {"k": a, "l": a}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0713" {
  let source =
    #|match ...:
    #|    case MyClass(x, x):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0714" {
  let source =
    #|match ...:
    #|    case MyClass(x=x, y=x):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0715" {
  let source =
    #|match ...:
    #|    case MyClass(x, y=x):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0716" {
  let source =
    #|match ...:
    #|    case a as a:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0717" {
  let source =
    #|match ...:
    #|    case a as a + 1:  # NAME and expression with no ()
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0718" {
  let source =
    #|match ...:
    #|    case *a, b, *c, d, *e:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0719" {
  let source =
    #|match ...:
    #|    case a, *b, c, *d, e:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0720" {
  let source =
    #|match ...:
    #|    case a | "a":
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0721" {
  let source =
    #|match 42:
    #|    case x:
    #|        pass
    #|    case y:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0722" {
  let source =
    #|match ...:
    #|    case x | [_ as x] if x:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0723" {
  let source =
    #|match ...:
    #|    case x:
    #|        pass
    #|    case [x] if x:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0724" {
  let source =
    #|match ...:
    #|    case x:
    #|        pass
    #|    case _:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0725" {
  let source =
    #|match ...:
    #|    case f"":
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0726" {
  let source =
    #|match ...:
    #|    case f"{x}":
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0727" {
  let source =
    #|match ...:
    #|    case 0j+0:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0728" {
  let source =
    #|match ...:
    #|    case 0j+0j:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0729" {
  let source =
    #|match ...:
    #|    case {0j+0: _}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0730" {
  let source =
    #|match ...:
    #|    case {0j+0j: _}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0731" {
  let source =
    #|match ...:
    #|    case 0 + 0j + 0:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0732" {
  let source =
    #|match ...:
    #|    case _ | _:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0733" {
  let source =
    #|match ...:
    #|    case (_ as x) | [x]:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0734" {
  let source =
    #|match ...:
    #|    case _ | _ if condition():
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0735" {
  let source =
    #|match ...:
    #|    case _:
    #|        pass
    #|    case None:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0736" {
  let source =
    #|match ...:
    #|    case (None | _) | _:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0737" {
  let source =
    #|match ...:
    #|    case _ | (True | False):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0738" {
  let source =
    #|match ...:
    #|    case {"a": _, "a": _}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0739" {
  let source =
    #|match ...:
    #|    case {0: _, False: _}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0740" {
  let source =
    #|match ...:
    #|    case {0: _, 0.0: _}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0741" {
  let source =
    #|match ...:
    #|    case {0: _, -0: _}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0742" {
  let source =
    #|match ...:
    #|    case {0: _, 0j: _}:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0743" {
  let source =
    #|match ...:
    #|    case 0 
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0744" {
  let source =
    #|0j:
    #|                       pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0745" {
  let source =
    #|match ...:
    #|    case 0j 
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0746" {
  let source =
    #|0:
    #|                       pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0747" {
  let source =
    #|match ...:
    #|    case -0j 
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0748" {
  let source =
    #|-0:
    #|                       pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0749" {
  let source =
    #|def f(x):
    #|    match x:
    #|        case 
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0750" {
  let source =
    #|:
    #|                    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0751" {
  let source =
    #|for _ in [1,
    #|          2,
    #|          x]:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0752" {
  let source =
    #|Unit tests for the PickleBuffer object.
    #|
    #|Pickling tests themselves are in pickletester.py.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0753" {
  let source =
    #|def f(a, /, a): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0754" {
  let source =
    #|def f(a, /, *, a): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0755" {
  let source =
    #|async def f(a, /, a): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0756" {
  let source =
    #|async def f(a, /, *, a): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0757" {
  let source =
    #|def f(%s, /):
    #|  pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0758" {
  let source =
    #|Test that correct hint is produced analogous to Python3 syntax,
    #|    if print statement is executed as in Python 2.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0759" {
  let source =
    #|if 1:
    #|            print "Hello World"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0760" {
  let source =
    #|Property tries to provide the best docstring it finds for its instances.
    #|If a user-provided docstring is available, it is preserved on copies.
    #|If no docstring is available during property creation, the property
    #|will utilize the docstring from the getter if available.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0761" {
  let source =
    #|Test cases for pyclbr.py
    #|Nick Mathewson
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0762" {
  let source =
    #|A context manager that temporarily sets the `__spec__` attribute
    #|of the `__main__` module if it's missing.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0763" {
  let source =
    #|succeed iff pyclbr.readmodule_ex(modulename) corresponds
    #|           to the actual module object, module.  Any identifiers in
    #|           ignore are ignored.   If no module is provided, the appropriate
    #|           module is loaded with __import__.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0764" {
  let source =
    #|def f0():
    #|    def f1(a,b,c):
    #|        def f2(a=1, b=2, c=3): pass
    #|        return f1(a,b,d)
    #|    class c1: pass
    #|class C0:
    #|    "Test class."
    #|    def F1():
    #|        "Method."
    #|        return 'return'
    #|    class C1():
    #|        class C2:
    #|            "Class nested within nested class."
    #|            def F3(): return 1+1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0765" {
  let source =
    #|Return equality of tree pairs.
    #|
    #|            Each parent,children pair define a tree.  The parents are
    #|            assumed equal.  Comparing the children dictionaries as such
    #|            does not work due to comparison by identity and double
    #|            linkage.  We separate comparing string and number attributes
    #|            from comparing the children of input children.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0766" {
  let source =
    #|l1=%r
    #|l2=%r
    #|ignore=%r
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0767" {
  let source =
    #|Tests for pystats functionality (requires --enable-pystats build
    #|    option).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0768" {
  let source =
    #|Test Branching
    #|        Test expressions using the OR ('|') operator.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0769" {
  let source =
    #|Test that $ does not include \n
    #|        $ matches the end of string, and just before the terminating \n
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0770" {
  let source =
    #|Test Possessive Quantifiers
    #|        Test quantifiers of the form @+ for some repetition operator @,
    #|        e.g. x{3,5}+ meaning match from 3 to 5 greadily and proceed
    #|        without creating a stack frame for rolling the stack back and
    #|        trying 1 or more fewer matches.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0771" {
  let source =
    #|Test Atomic Grouping
    #|        Test non-capturing groups of the form (?>...), which does
    #|        not maintain any stack point created within the group once the
    #|        group is finished being evaluated.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0772" {
  let source =
    #|a(function() {
    #|            ///////////////////////////////////////////////////////////////////
    #|        });
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0773" {
  let source =
    #|SUBPATTERN 1 0 0
    #|  LITERAL 46
    #|BRANCH
    #|  IN
    #|    LITERAL 99
    #|    LITERAL 104
    #|OR
    #|  LITERAL 112
    #|  LITERAL 121
    #|GROUPREF_EXISTS 1
    #|  AT AT_END
    #|ELSE
    #|  LITERAL 58
    #|  LITERAL 32
    #|
    #| 0. INFO 8 0b1 2 5 (to 9)
    #|      prefix_skip 0
    #|      prefix [0x2e] ('.')
    #|      overlap [0]
    #| 9: MARK 0
    #|11. LITERAL 0x2e ('.')
    #|13. MARK 1
    #|15. BRANCH 10 (to 26)
    #|17.   IN 6 (to 24)
    #|19.     LITERAL 0x63 ('c')
    #|21.     LITERAL 0x68 ('h')
    #|23.     FAILURE
    #|24:   JUMP 9 (to 34)
    #|26: branch 7 (to 33)
    #|27.   LITERAL 0x70 ('p')
    #|29.   LITERAL 0x79 ('y')
    #|31.   JUMP 2 (to 34)
    #|33: FAILURE
    #|34: GROUPREF_EXISTS 0 6 (to 41)
    #|37. AT END
    #|39. JUMP 5 (to 45)
    #|41: LITERAL 0x3a (':')
    #|43. LITERAL 0x20 (' ')
    #|45: SUCCESS
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0774" {
  let source =
    #|ATOMIC_GROUP
    #|  LITERAL 97
    #|  MAX_REPEAT 0 1
    #|    LITERAL 98
    #|
    #| 0. INFO 4 0b0 1 2 (to 5)
    #| 5: ATOMIC_GROUP 11 (to 17)
    #| 7.   LITERAL 0x61 ('a')
    #| 9.   REPEAT_ONE 6 0 1 (to 16)
    #|13.     LITERAL 0x62 ('b')
    #|15.     SUCCESS
    #|16:   SUCCESS
    #|17: SUCCESS
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0775" {
  let source =
    #|POSSESSIVE_REPEAT 0 1
    #|  LITERAL 97
    #|
    #| 0. INFO 4 0b0 0 1 (to 5)
    #| 5: POSSESSIVE_REPEAT_ONE 6 0 1 (to 12)
    #| 9.   LITERAL 0x61 ('a')
    #|11.   SUCCESS
    #|12: SUCCESS
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0776" {
  let source =
    #|POSSESSIVE_REPEAT 0 1
    #|  LITERAL 97
    #|  LITERAL 98
    #|
    #| 0. INFO 4 0b0 0 2 (to 5)
    #| 5: POSSESSIVE_REPEAT 7 0 1 (to 13)
    #| 9.   LITERAL 0x61 ('a')
    #|11.   LITERAL 0x62 ('b')
    #|13: SUCCESS
    #|14. SUCCESS
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0777" {
  let source =
    #|(?x)#x
    #|a
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0778" {
  let source =
    #|#x
    #|(?x)#y
    #|a
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0779" {
  let source =
    #|(?x)#x
    #|(?x)#y
    #|a
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0780" {
  let source =
    #|#x
    #|a(?x:#y
    #|b)#z
    #|c
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0781" {
  let source =
    #|#x
    #|a(?-x:#y
    #|b)#z
    #|c
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0782" {
  let source =
    #|(?x)#x
    #|a(?-x:#y
    #|b)#z
    #|c
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0783" {
  let source =
    #|(?x)#x
    #|a|#y
    #|b
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0784" {
  let source =
    #|(
    #|    abc
    #|)
    #|)
    #|(
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0785" {
  let source =
    #|if 1:
    #|            global_x = 1
    #|            def f():
    #|                global_x += 1
    #|            try:
    #|                f()
    #|            except UnboundLocalError:
    #|                pass
    #|            else:
    #|                fail('scope of global_x not correctly determined')
    #|            
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'UnboundLocalError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0786" {
  let source =
    #|if 1:
    #|            # I
    #|            x = 7
    #|            def f():
    #|                x = 1
    #|                def g():
    #|                    global x
    #|                    def i():
    #|                        def h():
    #|                            return x
    #|                        return h()
    #|                    return i()
    #|                return g()
    #|            self.assertEqual(f(), 7)
    #|            self.assertEqual(x, 7)
    #|
    #|            # II
    #|            x = 7
    #|            def f():
    #|                x = 1
    #|                def g():
    #|                    x = 2
    #|                    def i():
    #|                        def h():
    #|                            return x
    #|                        return h()
    #|                    return i()
    #|                return g()
    #|            self.assertEqual(f(), 2)
    #|            self.assertEqual(x, 7)
    #|
    #|            # III
    #|            x = 7
    #|            def f():
    #|                x = 1
    #|                def g():
    #|                    global x
    #|                    x = 2
    #|                    def i():
    #|                        def h():
    #|                            return x
    #|                        return h()
    #|                    return i()
    #|                return g()
    #|            self.assertEqual(f(), 2)
    #|            self.assertEqual(x, 2)
    #|
    #|            # IV
    #|            x = 7
    #|            def f():
    #|                x = 3
    #|                def g():
    #|                    global x
    #|                    x = 2
    #|                    def i():
    #|                        def h():
    #|                            return x
    #|                        return h()
    #|                    return i()
    #|                return g()
    #|            self.assertEqual(f(), 2)
    #|            self.assertEqual(x, 2)
    #|
    #|            # XXX what about global statements in class blocks?
    #|            # do they affect methods?
    #|
    #|            x = 12
    #|            class Global:
    #|                global x
    #|                x = 13
    #|                def set(self, val):
    #|                    x = val
    #|                def get(self):
    #|                    return x
    #|
    #|            g = Global()
    #|            self.assertEqual(g.get(), 13)
    #|            g.set(15)
    #|            self.assertEqual(g.get(), 13)
    #|            
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'self' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0787" {
  let source =
    #|if 1:
    #|            def test(x):
    #|                class Foo:
    #|                    global x
    #|                    def __call__(self, y):
    #|                        return x + y
    #|                return Foo()
    #|
    #|            x = 0
    #|            self.assertEqual(test(6)(2), 8)
    #|            x = -1
    #|            self.assertEqual(test(3)(2), 5)
    #|
    #|            looked_up_by_load_name = False
    #|            class X:
    #|                # Implicit globals inside classes are be looked up by LOAD_NAME, not
    #|                # LOAD_GLOBAL.
    #|                locals()['looked_up_by_load_name'] = True
    #|                passed = looked_up_by_load_name
    #|
    #|            self.assertTrue(X.passed)
    #|            
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'self' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0788" {
  let source =
    #|if 1:
    #|            def unoptimized_clash1(strip):
    #|                def f(s):
    #|                    from sys import *
    #|                    return getrefcount(s) # ambiguity: free or local
    #|                return f
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0789" {
  let source =
    #|if 1:
    #|            def unoptimized_clash2():
    #|                from sys import *
    #|                def f(s):
    #|                    return getrefcount(s) # ambiguity: global or local
    #|                return f
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0790" {
  let source =
    #|if 1:
    #|            def unoptimized_clash2():
    #|                from sys import *
    #|                def g():
    #|                    def f(s):
    #|                        return getrefcount(s) # ambiguity: global or local
    #|                    return f
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0791" {
  let source =
    #|if 1:
    #|            def f():
    #|                def g():
    #|                    from sys import *
    #|                    return getrefcount # global or local?
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0792" {
  let source =
    #|if 1:
    #|            global_x = 1
    #|            def f():
    #|                global_x += 1
    #|            try:
    #|                f()
    #|            except UnboundLocalError:
    #|                pass
    #|            else:
    #|                fail('scope of global_x not correctly determined')
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'UnboundLocalError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0793" {
  let source =
    #|if 1:
    #|            def test(x):
    #|                class Foo:
    #|                    global x
    #|                    def __call__(self, y):
    #|                        return x + y
    #|                return Foo()
    #|
    #|            x = 0
    #|            self.assertEqual(test(6)(2), 8)
    #|            x = -1
    #|            self.assertEqual(test(3)(2), 5)
    #|
    #|            looked_up_by_load_name = False
    #|            class X:
    #|                # Implicit globals inside classes are be looked up by LOAD_NAME, not
    #|                # LOAD_GLOBAL.
    #|                locals()['looked_up_by_load_name'] = True
    #|                passed = looked_up_by_load_name
    #|
    #|            self.assertTrue(X.passed)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'self' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0794" {
  let source =
    #|Test the secrets module.
    #|
    #|As most of the functions in secrets are thin wrappers around functions
    #|defined elsewhere, we don't need to test them exhaustively.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0795" {
  let source =
    #|import time
    #|for i in range(10):
    #|    print("testing...", flush=True)
    #|    time.sleep(0.050)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module time is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0796" {
  let source =
    #|Graph, the vertices of which are edges of G,
    #|    with two vertices being adjacent iff the corresponding
    #|    edges share a vertex.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0797" {
  let source =
    #|Helper function to convert a slice argument to an integer, and raise
    #|TypeError with a suitable message on failure.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0798" {
  let source =
    #|Test suite for statistics module, including helper NumericTestCase and
    #|approx_equal function.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0799" {
  let source =
    #|Return True if a and b are both the same kind of NAN.
    #|
    #|    >>> _nan_equal(Decimal('NAN'), Decimal('NAN'))
    #|    True
    #|    >>> _nan_equal(Decimal('sNAN'), Decimal('sNAN'))
    #|    True
    #|    >>> _nan_equal(Decimal('NAN'), Decimal('sNAN'))
    #|    False
    #|    >>> _nan_equal(Decimal(42), Decimal('NAN'))
    #|    False
    #|
    #|    >>> _nan_equal(float('NAN'), float('NAN'))
    #|    True
    #|    >>> _nan_equal(float('NAN'), 0.5)
    #|    False
    #|
    #|    >>> _nan_equal(float('NAN'), Decimal('NAN'))
    #|    False
    #|
    #|    NAN payloads are not compared.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0800" {
  let source =
    #|Return the absolute and relative errors between two numbers.
    #|
    #|    >>> _calc_errors(100, 75)
    #|    (25, 0.25)
    #|    >>> _calc_errors(100, 100)
    #|    (0, 0.0)
    #|
    #|    Returns the (absolute error, relative error) between the two arguments.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0801" {
  let source =
    #|Unit test class for numeric work.
    #|
    #|    This subclasses TestCase. In addition to the standard method
    #|    ``TestCase.assertAlmostEqual``,  ``assertApproxEqual`` is provided.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0802" {
  let source =
    #|Mixin class for type-conserving functions.
    #|
    #|    This mixin class holds test(s) for functions which conserve the type of
    #|    individual data points. E.g. the mean of a list of Fractions should itself
    #|    be a Fraction.
    #|
    #|    Not all tests to do with types need go in this class. Only those that
    #|    rely on the function returning the same type as its input data.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0803" {
  let source =
    #|%r != %r
    #|values differ by more than tol=%r and rel=%r
    #|-> absolute error = %r
    #|-> relative error = %r
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0804" {
  let source =
    #| Test script for the Unicode implementation.
    #|
    #|Written by Marc-Andre Lemburg (mal@lemburg.com).
    #|
    #|(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0805" {
  let source =
    #|Try to get a fresh clone of the specified text:
    #|new object with a reference count of 1.
    #|
    #|This is a best-effort: latin1 single letters and the empty
    #|string ('') are singletons and cannot be cloned.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0806" {
  let source =
    #|Check that an invalid UTF-8 sequence raises a UnicodeDecodeError when
    #|'strict' is used, returns res when 'replace' is used, and that doesn't
    #|return anything when 'ignore' is used.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0807" {
  let source =
    #|Test that an 'invalid start byte' error is raised when the first byte
    #|is not in the ASCII range or is not a valid start byte of a 2-, 3-, or
    #|4-bytes sequence. The invalid start byte is replaced with a single
    #|U+FFFD when errors='replace'.
    #|E.g. <80> is a continuation byte and can appear only after a start byte.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0808" {
  let source =
    #|Test that an 'unexpected end of data' error is raised when the string
    #|ends after a start byte of a 2-, 3-, or 4-bytes sequence without having
    #|enough continuation bytes.  The incomplete sequence is replaced with a
    #|single U+FFFD when errors='replace'.
    #|E.g. in the sequence <F3 80 80>, F3 is the start byte of a 4-bytes
    #|sequence, but it's followed by only 2 valid continuation bytes and the
    #|last continuation bytes is missing.
    #|Note: the continuation bytes must be all valid, if one of them is
    #|invalid another error will be raised.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 6:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0809" {
  let source =
    #|Test that an 'invalid continuation byte' error is raised when the
    #|continuation byte of a 2-bytes sequence is invalid.  The start byte
    #|is replaced by a single U+FFFD and the second byte is handled
    #|separately when errors='replace'.
    #|E.g. in the sequence <C2 41>, C2 is the start byte of a 2-bytes
    #|sequence, but 41 is not a valid continuation byte because it's the
    #|ASCII letter 'A'.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 6:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0810" {
  let source =
    #|Test that an 'invalid continuation byte' error is raised when the
    #|continuation byte(s) of a 4-bytes sequence are invalid.  When
    #|errors='replace',the start byte and all the following valid
    #|continuation bytes are replaced with a single U+FFFD, and all the bytes
    #|starting from the first invalid continuation bytes (included) are
    #|handled separately.
    #|E.g. in the sequence <E1 80 41>, E1 is the start byte of a 3-bytes
    #|sequence, 80 is a valid continuation byte, but 41 is not a valid cb
    #|because it's the ASCII letter 'A'.
    #|Note: when the start byte is E0 or ED, the valid ranges for the first
    #|continuation byte are limited to A0..BF and 80..9F respectively.
    #|However, when the start byte is ED, Python 2 considers all the bytes
    #|in range 80..BF valid.  This is fixed in Python 3.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 9:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0811" {
  let source =
    #|import sys
    #|encodings = 
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0812" {
  let source =
    #|for data in (b'', b'short string'):
    #|    try:
    #|        str(data, encoding=
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0813" {
  let source =
    #|)
    #|                except LookupError:
    #|                    pass
    #|                else:
    #|                    sys.exit(21)
    #|
    #|                try:
    #|                    str(data, errors=
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0814" {
  let source =
    #|)
    #|                except LookupError:
    #|                    pass
    #|                else:
    #|                    sys.exit(22)
    #|
    #|                for encoding in encodings:
    #|                    try:
    #|                        str(data, encoding, errors=
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0815" {
  let source =
    #|)
    #|                    except LookupError:
    #|                        pass
    #|                    else:
    #|                        sys.exit(22)
    #|
    #|            for data in ('', 'short string'):
    #|                try:
    #|                    data.encode(encoding=
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0816" {
  let source =
    #|)
    #|                except LookupError:
    #|                    pass
    #|                else:
    #|                    sys.exit(23)
    #|
    #|                try:
    #|                    data.encode(errors=
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0817" {
  let source =
    #|)
    #|                except LookupError:
    #|                    pass
    #|                else:
    #|                    sys.exit(24)
    #|
    #|                for encoding in encodings:
    #|                    try:
    #|                        data.encode(encoding, errors=
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0818" {
  let source =
    #|)
    #|                    except LookupError:
    #|                        pass
    #|                    else:
    #|                        sys.exit(24)
    #|
    #|            sys.exit(10)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 unmatched ')'\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0819" {
  let source =
    #|Escape text to deal with possible locale values that have regex
    #|syntax while allowing regex syntax used for comparison.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0820" {
  let source =
    #|A limitation of the MS C runtime library is that it crashes if
    #|    a date before 1900 is passed with a format string containing "%y"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0821" {
  let source =
    #|Convert a finite decimal string to a hex string representing an
    #|    IEEE 754 binary64 float.  Return 'inf' or '-inf' on overflow.
    #|    This function makes no use of floating-point arithmetic at any
    #|    stage.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0822" {
  let source =
    #|# A numeric string consists of:
    #|(?P<sign>[-+])?          # an optional sign, followed by
    #|(?=\d|\.\d)              # a number with at least one digit
    #|(?P<int>\d*)             # having a (possibly empty) integer part
    #|(?:\.(?P<frac>\d*))?     # followed by an optional fractional part
    #|(?:E(?P<exp>[-+]?\d+))?  # and an optional exponent
    #|\z
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0823" {
  let source =
    #|Compare the result of Python's builtin correctly rounded
    #|        string->float conversion (using float) to a pure Python
    #|        correctly rounded string->float implementation.  Fail if the
    #|        two methods give different results.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0824" {
  let source =
    #|if 1:
    #|            import struct
    #|
    #|            class C:
    #|                def __init__(self):
    #|                    self.pack = struct.pack
    #|                def __del__(self):
    #|                    self.pack('I', -42)
    #|
    #|            struct.x = C()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module struct is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0825" {
  let source =
    #|class X:
    #|                __class__
    #|                def f():
    #|                    __class__
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0826" {
  let source =
    #|Note: this test isn't actually testing anything on its own.
    #|       It requires a sys audithook to be set to crash on older Python.
    #|       This should be the case anyways as our test suite sets
    #|       an audit hook.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0827" {
  let source =
    #|class super:
    #|    msg = "truly super"
    #|
    #|class C:
    #|    def method(self):
    #|        return super().msg
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0828" {
  let source =
    #|Check that compiling code raises SyntaxWarning with errtext.
    #|
    #|        errtest is a regular expression that must be present in the
    #|        text of the warning raised.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0829" {
  let source =
    #|Check that compiling code raises SyntaxError with errtext.
    #|
    #|        errtest is a regular expression that must be present in the
    #|        text of the exception raised.  If subclass is specified it
    #|        is the expected subclass of SyntaxError (e.g. IndentationError).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0830" {
  let source =
    #|if 1:
    #|            def error(a):
    #|                global a  # SyntaxError
    #|            def error2():
    #|                b = 1
    #|                global b  # SyntaxError
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0831" {
  let source =
    #|if 1:
    #|            def error(a):
    #|                nonlocal a  # SyntaxError
    #|            def error2():
    #|                b = 1
    #|                global b  # SyntaxError
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0832" {
  let source =
    #|if 1:
    #|        raise AssertionError() from None
    #|        print(1,,2)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0833" {
  let source =
    #|\
    #|if x:
    #|    y = 1
    #|  \
    #|  foo = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0834" {
  let source =
    #|def func1():
    #|    if a != b:
    #|        raise ValueError
    #|
    #|def func2():
    #|    try
    #|        return 1
    #|    finally:
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 6:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0835" {
  let source =
    #|func(
    #|    a=["unclosed], # Need a quote in this comment: "
    #|    b=2,
    #|)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0836" {
  let source =
    #|while 1:
    #| while 2:
    #|  while 3:
    #|   while 4:
    #|    while 5:
    #|     while 6:
    #|      while 8:
    #|       while 9:
    #|        while 10:
    #|         while 11:
    #|          while 12:
    #|           while 13:
    #|            while 14:
    #|             while 15:
    #|              while 16:
    #|               while 17:
    #|                while 18:
    #|                 while 19:
    #|                  while 20:
    #|                   while 21:
    #|                    while 22:
    #|                     while 23:
    #|                      break
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 21:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0837" {
  let source =
    #|if 0: yield
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0838" {
  let source =
    #|if 0: yield
    #|else:  x=1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0839" {
  let source =
    #|if 1: pass
    #|else: yield
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0840" {
  let source =
    #|while 0: yield
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0841" {
  let source =
    #|while 0: yield
    #|else:  x=1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0842" {
  let source =
    #|class C:
    #|  if 0: yield
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0843" {
  let source =
    #|class C:
    #|  if 1: pass
    #|  else: yield
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0844" {
  let source =
    #|class C:
    #|  while 0: yield
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0845" {
  let source =
    #|class C:
    #|  while 0: yield
    #|  else:  x = 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0846" {
  let source =
    #|if 0: return
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0847" {
  let source =
    #|if 0: return
    #|else:  x=1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0848" {
  let source =
    #|if 1: pass
    #|else: return
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0849" {
  let source =
    #|while 0: return
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0850" {
  let source =
    #|class C:
    #|  if 0: return
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0851" {
  let source =
    #|class C:
    #|  while 0: return
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0852" {
  let source =
    #|class C:
    #|  while 0: return
    #|  else:  x=1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0853" {
  let source =
    #|class C:
    #|  if 0: return
    #|  else: x= 1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0854" {
  let source =
    #|class C:
    #|  if 1: pass
    #|  else: return
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0855" {
  let source =
    #|if 0: break
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0856" {
  let source =
    #|if 0: break
    #|else:  x=1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0857" {
  let source =
    #|if 1: pass
    #|else: break
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0858" {
  let source =
    #|class C:
    #|  if 0: break
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0859" {
  let source =
    #|class C:
    #|  if 1: pass
    #|  else: break
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0860" {
  let source =
    #|with object() as obj:
    #| break
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0861" {
  let source =
    #|if 0: continue
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0862" {
  let source =
    #|if 0: continue
    #|else:  x=1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0863" {
  let source =
    #|if 1: pass
    #|else: continue
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0864" {
  let source =
    #|class C:
    #|  if 0: continue
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0865" {
  let source =
    #|class C:
    #|  if 1: pass
    #|  else: continue
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0866" {
  let source =
    #|with object() as obj:
    #|    continue
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0867" {
  let source =
    #|foo()
    #| bar()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0868" {
  let source =
    #|if 1:
    #|foo()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0869" {
  let source =
    #|if 1:
    #|  foo()
    #| bar()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0870" {
  let source =
    #|1,\#
    #|2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0871" {
  let source =
    #|fgdfgf
    #|1,\#
    #|2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0872" {
  let source =
    #|match y:
    #| case e(e=v,v,
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0873" {
  let source =
    #|call(
    #|a=1,
    #|a=1
    #|)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0874" {
  let source =
    #|print(
    #|    "line1"
    #|    "line2"
    #|    "line3"
    #|    x=1
    #|)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0875" {
  let source =
    #|raise Exception('a')
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"Exception: a\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0876" {
  let source =
    #|from ast import *
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module ast is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0877" {
  let source =
    #|class A[__classdict__]: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module typing is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0878" {
  let source =
    #|def bug():
    #|    with (
    #|    a
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0879" {
  let source =
    #|try:
    #|    pass
    #|except ValueError as obj.attr:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0880" {
  let source =
    #|match 1:
    #|    case x as obj.attr:
    #|        ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0881" {
  let source =
    #|for abc in range(10):
    #|    try:
    #|        pass
    #|    finally:
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 4:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0882" {
  let source =
    #|for abc in range(10):
    #|    try:
    #|        pass
    #|    finally:
    #|        try:
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 5:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0883" {
  let source =
    #|except:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0884" {
  let source =
    #|for abc in range(10):
    #|    try:
    #|        pass
    #|    finally:
    #|        try:
    #|            pass
    #|        except:
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 7:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0885" {
  let source =
    #|class A:
    #|    class B[
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0886" {
  let source =
    #|async def bug():
    #|    async with (
    #|    a
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0887" {
  let source =
    #| 1, 2, 3
    #|b=3
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0888" {
  let source =
    #|Expected events:
    #|%s
    #|Received events:
    #|%s
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0889" {
  let source =
    #|import syslog
    #|caught_error = False
    #|try:
    #|    syslog.syslog('foo')
    #|except RuntimeError:
    #|    caught_error = True
    #|assert(caught_error)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module syslog is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0890" {
  let source =
    #|import syslog
    #|caught_error = False
    #|try:
    #|    syslog.openlog()
    #|except RuntimeError:
    #|    caught_error = True
    #|
    #|assert(caught_error)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module syslog is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0891" {
  let source =
    #|import syslog
    #|caught_error = False
    #|try:
    #|    syslog.closelog()
    #|except RuntimeError:
    #|    caught_error = True
    #|
    #|assert(caught_error)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module syslog is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0892" {
  let source =
    #|import syslog
    #|syslog.syslog('foo')
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module syslog is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0893" {
  let source =
    #|This is a paragraph that already has
    #|line breaks.  But some of its lines are much longer than the others,
    #|so it needs to be wrapped.
    #|Some lines are 	tabbed too.
    #|What a mess!
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0894" {
  let source =
    #|Well, Doctor?
    #|What do you think?
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0895" {
  let source =
    #|I say, chaps! Anyone for "tennis?"
    #|Hmmph!
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0896" {
  let source =
    #|And she said, "Go to hell!"
    #|Can you believe that?
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0897" {
  let source =
    #|This is a
    #|short paragraph.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0898" {
  let source =
    #|Python 1.0.0 was released on 1994-01-26.  Python 1.0.1 was
    #|released on 1994-02-15.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0899" {
  let source =
    #|Did you say "supercalifragilisticexpialidocious?"
    #|How *do* you spell that odd word, anyways?
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0900" {
  let source =
    #|This paragraph will be filled, first without any indentation,
    #|and then with some (including a hanging indent).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0901" {
  let source =
    #|This paragraph will be filled, first
    #|without any indentation, and then with
    #|some (including a hanging indent).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0902" {
  let source =
    #|* This paragraph will be filled, first
    #|  without any indentation, and then
    #|  with some (including a hanging
    #|  indent).
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0903" {
  let source =
    #|Hello there.
    #|How are you?
    #|Oh good, I'm glad.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 3:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0904" {
  let source =
    #|Hello there.
    #|
    #|Boo!
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0905" {
  let source =
    #|Hello there.
    #|  This is indented.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0906" {
  let source =
    #|Hello there.
    #|
    #|  Boo!
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0907" {
  let source =
    #|Hello there.
    #|How are ya?
    #|Oh good.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0908" {
  let source =
    #|Hello there.
    #|
    #|How are ya?
    #|Oh good.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0909" {
  let source =
    #| 	hello there
    #|  	how are you?
    #|	I'm fine, thanks
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0910" {
  let source =
    #|Hi.
    #|This is a test.
    #|Testing.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0911" {
  let source =
    #|Hi.
    #|This is a test.
    #|
    #|Testing.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0912" {
  let source =
    #|This is a  paragraph that  already has
    #|line breaks and 	 tabs too.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0913" {
  let source =
    #|expected:
    #|%s
    #|but got:
    #|%s
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0914" {
  let source =
    #|expected %r
    #|but got  %r
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 2:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0915" {
  let source =
    #|import dis
    #|import queue
    #|import threading
    #|
    #|from _testinternalcapi import get_tlbc
    #|
    #|def all_opnames(bc):
    #|    return {i.opname for i in dis._get_instructions_bytes(bc)}
    #|
    #|def f(a, b, q=None):
    #|    if q is not None:
    #|        q.put(get_tlbc(f))
    #|    return a + b
    #|
    #|for _ in range(100):
    #|    # specialize
    #|    f(1, 2)
    #|
    #|q = queue.Queue()
    #|t = threading.Thread(target=f, args=('a', 'b', q))
    #|t.start()
    #|t.join()
    #|
    #|assert "BINARY_OP_ADD_INT" in all_opnames(get_tlbc(f))
    #|assert "BINARY_OP_ADD_INT" not in all_opnames(q.get())
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module dis is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0916" {
  let source =
    #|import dis
    #|import queue
    #|import threading
    #|
    #|from _testinternalcapi import get_tlbc
    #|
    #|def all_opnames(bc):
    #|    return {i.opname for i in dis._get_instructions_bytes(bc)}
    #|
    #|def f(a, b):
    #|    return a + b
    #|
    #|def g(a, b, q=None):
    #|    for _ in range(100):
    #|        f(a, b)
    #|    if q is not None:
    #|        q.put(get_tlbc(f))
    #|
    #|# specialize in main thread
    #|g(1, 2)
    #|
    #|# specialize in other thread
    #|q = queue.Queue()
    #|t = threading.Thread(target=g, args=('a', 'b', q))
    #|t.start()
    #|t.join()
    #|
    #|assert "BINARY_OP_ADD_INT" in all_opnames(get_tlbc(f))
    #|t_opnames = all_opnames(q.get())
    #|assert "BINARY_OP_ADD_INT" not in t_opnames
    #|assert "BINARY_OP_ADD_UNICODE" in t_opnames
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module dis is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0917" {
  let source =
    #|import queue
    #|import threading
    #|
    #|from _testinternalcapi import get_tlbc_id
    #|
    #|def f(a, b, q=None):
    #|    if q is not None:
    #|        q.put(get_tlbc_id(f))
    #|    return a + b
    #|
    #|q = queue.Queue()
    #|tlbc_ids = []
    #|for _ in range(3):
    #|    t = threading.Thread(target=f, args=('a', 'b', q))
    #|    t.start()
    #|    t.join()
    #|    tlbc_ids.append(q.get())
    #|
    #|assert tlbc_ids[0] == tlbc_ids[1]
    #|assert tlbc_ids[1] == tlbc_ids[2]
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module queue is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0918" {
  let source =
    #|import queue
    #|import threading
    #|
    #|from _testinternalcapi import get_tlbc_id
    #|
    #|def f(a, b, q=None):
    #|    if q is not None:
    #|        q.put(get_tlbc_id(f))
    #|    return a + b
    #|
    #|q = queue.Queue()
    #|threads = []
    #|for _ in range(3):
    #|    t = threading.Thread(target=f, args=('a', 'b', q))
    #|    t.start()
    #|    threads.append(t)
    #|
    #|tlbc_ids = []
    #|for t in threads:
    #|    t.join()
    #|    tlbc_ids.append(q.get())
    #|
    #|main_tlbc_id = get_tlbc_id(f)
    #|assert main_tlbc_id is not None
    #|assert tlbc_ids[0] == main_tlbc_id
    #|assert tlbc_ids[1] == main_tlbc_id
    #|assert tlbc_ids[2] == main_tlbc_id
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module queue is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0919" {
  let source =
    #|import dis
    #|import queue
    #|import threading
    #|
    #|from _testinternalcapi import get_tlbc
    #|
    #|def all_opnames(f):
    #|    bc = get_tlbc(f)
    #|    return {i.opname for i in dis._get_instructions_bytes(bc)}
    #|
    #|def f(a, b):
    #|    return a + b
    #|
    #|for _ in range(100):
    #|    f(1, 2)
    #|
    #|assert "BINARY_OP_ADD_INT" not in all_opnames(f)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module dis is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0920" {
  let source =
    #|import queue
    #|import threading
    #|
    #|from _testinternalcapi import get_tlbc_id
    #|
    #|def g():
    #|    try:
    #|        yield
    #|    except:
    #|        yield get_tlbc_id(g)
    #|
    #|def f(q):
    #|    gen = g()
    #|    next(gen)
    #|    q.put(gen.throw(ValueError))
    #|
    #|q = queue.Queue()
    #|t = threading.Thread(target=f, args=(q,))
    #|t.start()
    #|t.join()
    #|
    #|gen = g()
    #|next(gen)
    #|main_id = gen.throw(ValueError)
    #|assert main_id != q.get()
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module queue is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0921" {
  let source =
    #|Resolve an (host, port) to an address.
    #|
    #|    We must perform name resolution before timeout tests, otherwise it will be
    #|    performed by connect().
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0922" {
  let source =
    #|Test the specified socket method.
    #|
    #|The method is run at most `count` times and must raise a TimeoutError
    #|within `timeout` + self.fuzz seconds.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0923" {
  let source =
    #|ttk::style layout name {
    #|null
    #|}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0924" {
  let source =
    #|%sa -other {1 2 3} -children {
    #|%sb -children {
    #|%sc -something {1 2} -children {
    #|%sd -nice opt
    #|%s}
    #|%s}
    #|%s}
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0925" {
  let source =
    #|class A: type Alias = undefined
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0926" {
  let source =
    #|class Outer[A]:
    #|    type TA1[A] = None
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module typing is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0927" {
  let source =
    #|class Outer[A]:
    #|    def inner[B](self):
    #|        type TA1[C] = TA1[A, B] | int
    #|        return TA1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module typing is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0928" {
  let source =
    #|from __future__ import annotations
    #|
    #|def f(x: int) -> int: pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module __future__ is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0929" {
  let source =
    #|class format: pass
    #|
    #|def f(x: format): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0930" {
  let source =
    #|class Outer:
    #|    class format: pass
    #|
    #|    def meth(self, x: format): ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0931" {
  let source =
    #|class Swallower:
    #|    def __enter__(self):
    #|        pass
    #|
    #|    def __exit__(self, *args):
    #|        return True
    #|
    #|with Swallower():
    #|    if {cond}:
    #|        about_to_raise: int
    #|        raise Exception
    #|    in_with: "with"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0932" {
  let source =
    #|if {cond}:
    #|    in_if: "if"
    #|else:
    #|    in_if: "else"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'cond' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0933" {
  let source =
    #|if not len:
    #|    in_if: "if"
    #|elif {cond}:
    #|    in_elif: "elif"
    #|else:
    #|    in_else: "else"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'cond' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0934" {
  let source =
    #|while {cond}:
    #|    in_while: "while"
    #|    break
    #|else:
    #|    in_else: "else"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'cond' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0935" {
  let source =
    #|for _ in ([1] if {cond} else []):
    #|    in_for: "for"
    #|else:
    #|    in_else: "else"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'cond' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0936" {
  let source =
    #|match {cond}:
    #|    case True:
    #|        x: "true"
    #|    case False:
    #|        x: "false"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'cond' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0937" {
  let source =
    #|if {cond}:
    #|    x: "foo"
    #|    if {cond}:
    #|        x: "bar"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'cond' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0938" {
  let source =
    #|if {cond}:
    #|    outer_before: "outer_before"
    #|    if len:
    #|        inner_if: "inner_if"
    #|    else:
    #|        inner_else: "inner_else"
    #|    outer_after: "outer_after"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'cond' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0939" {
  let source =
    #|if len:
    #|    outer_before: "outer_before"
    #|    if {cond}:
    #|        inner_if: "inner_if"
    #|    else:
    #|        inner_else: "inner_else"
    #|    outer_after: "outer_after"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'cond' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0940" {
  let source =
    #|before: "before"
    #|if {cond}:
    #|    a = "x"
    #|    a[0]: int
    #|else:
    #|    a = object()
    #|    a.b: str
    #|after: "after"
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'cond' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0941" {
  let source =
    #|class X: (y): int
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0942" {
  let source =
    #|class X: int.b: int
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0943" {
  let source =
    #|class X: int[str]: int
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0944" {
  let source =
    #|class f:
    #|    x: int
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0945" {
  let source =
    #|class Generic:
    #|    pass
    #|try:
    #|    [0 for name_2 in unique_name_0 if (0 for unique_name_1 in unique_name_2 for unique_name_3 in name_2)]
    #|except:
    #|    pass
    #|annotated_name: 0
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0946" {
  let source =
    #|class Generic:
    #|    pass
    #|annotated_name: 0
    #|try:
    #|    [0 for name_2 in [[0]] for unique_name_1 in unique_name_2 if (lambda: name_2)]
    #|except:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0947" {
  let source =
    #|def func(x: (yield)): ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0948" {
  let source =
    #|def func(x: (yield from x)): ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0949" {
  let source =
    #|def func(x: (y := 3)): ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0950" {
  let source =
    #|def func(x: (await 42)): ...
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0951" {
  let source =
    #|(x): (yield)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0952" {
  let source =
    #|(x): (yield from x)
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0953" {
  let source =
    #|tp_version_tag should be unique assuming no overflow, even after
    #|        clearing type cache.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0954" {
  let source =
    #|async = 12
    #|await = 13
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0955" {
  let source =
    #|with context() as a:  # type: int
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'context' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0956" {
  let source =
    #|with (a as b):  # type: int
    #|    pass
    #|
    #|with (a, b):  # type: int
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'a' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0957" {
  let source =
    #|Tests for inappropriately-placed type comments.
    #|
    #|        These should be silently ignored with type comments off,
    #|        but raise SyntaxError with type comments on.
    #|
    #|        This is not meant to be exhaustive.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0958" {
  let source =
    #| Test script for the Unicode implementation.
    #|
    #|Written by Bill Tutt.
    #|Modified for Python 2.0 by Fredrik Lundh (fredrik@pythonware.com)
    #|
    #|(c) Copyright CNRI, All Rights Reserved. NO WARRANTY.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 expected indented block\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0959" {
  let source =
    #|Tests for the unicodedata module.
    #|
    #|   Written by Marc-Andre Lemburg (mal@lemburg.com).
    #|
    #|   (c) Copyright CNRI, All Rights Reserved. NO WARRANTY.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0960" {
  let source =
    #|import sys;sys.modules['unicodedata'] = None;eval("'\\N{SOFT HYPHEN}'")
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module sys is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0961" {
  let source =
    #|= x
    #|           return y
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0962" {
  let source =
    #|from . import fred
    #|from .. import barney
    #|from .australia import shrimp as prawns
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"ImportError: module  is not allowed\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0963" {
  let source =
    #|try:
    #|    1 / 0
    #|except ZeroDivisionError as e:
    #|    raise ArithmeticError from e
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'ZeroDivisionError' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0964" {
  let source =
    #|if cond1:
    #|    suite1
    #|elif cond2:
    #|    suite2
    #|else:
    #|    suite3
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'cond1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0965" {
  let source =
    #|if cond1:
    #|    suite1
    #|elif cond2:
    #|    suite2
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'cond1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0966" {
  let source =
    #|try:
    #|    suite1
    #|except ex1:
    #|    suite2
    #|except ex2:
    #|    suite3
    #|else:
    #|    suite4
    #|finally:
    #|    suite5
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'suite5' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0967" {
  let source =
    #|try:
    #|    suite1
    #|except* ex1:
    #|    suite2
    #|except* ex2:
    #|    suite3
    #|else:
    #|    suite4
    #|finally:
    #|    suite5
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'suite5' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0968" {
  let source =
    #|with f():
    #|    suite1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'f' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0969" {
  let source =
    #|with f() as x:
    #|    suite1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'f' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0970" {
  let source =
    #|with f() as x, g() as y:
    #|    suite1
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'f' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0971" {
  let source =
    #|Read and return the contents of a Python source file (as a
    #|    string), taking into account the file encoding.
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0972" {
  let source =
    #|f"""{g('''
    #|''')}"""
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'g' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0973" {
  let source =
    #|del x, y, z
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0974" {
  let source =
    #|class A(metaclass=type, *[], **{}): pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'type' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0975" {
  let source =
    #|for x in y: # type: int
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'y' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0976" {
  let source =
    #|async for x in y: # type: int
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0977" {
  let source =
    #|with x(): # type: int
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0978" {
  let source =
    #|async with x(): # type: int
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0979" {
  let source =
    #|for x in y: # type: ignore
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'y' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0980" {
  let source =
    #|async for x in y: # type: ignore
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0981" {
  let source =
    #|with x(): # type: ignore
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0982" {
  let source =
    #|async with x(): # type: ignore
    #|	pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0983" {
  let source =
    #|i = 1; 'expr'; raise Exception
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"Exception: \"]"
  assert_run(result, expected)
}

///|
test "generated/program/0984" {
  let source =
    #|if i:
    #| 'expr'
    #|else:
    #| raise Exception
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'i' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0985" {
  let source =
    #|if i:
    #|    'expr'
    #|else:
    #|    raise Exception
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'i' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0986" {
  let source =
    #|@decorator1
    #|@decorator2
    #|def func():
    #| 'docstring'
    #| i = 1; 'expr'; raise Exception
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'decorator1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0987" {
  let source =
    #|@decorator1
    #|@decorator2
    #|def func():
    #|    """docstring"""
    #|    i = 1
    #|    'expr'
    #|    raise Exception
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'decorator1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0988" {
  let source =
    #|@decorator1
    #|@decorator2
    #|class cls:
    #| 'docstring'
    #| i = 1; 'expr'; raise Exception
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'decorator1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0989" {
  let source =
    #|@decorator1
    #|@decorator2
    #|class cls:
    #|    """docstring"""
    #|    i = 1
    #|    'expr'
    #|    raise Exception
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'decorator1' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0990" {
  let source =
    #|for x in y:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'y' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0991" {
  let source =
    #|async for x in y:
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0992" {
  let source =
    #|with x():
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name 'x' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0993" {
  let source =
    #|async with x():
    #|    pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"line 1:1 invalid syntax\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0994" {
  let source =
    #|class cls:
    #|
    #|    def f(self):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0995" {
  let source =
    #|class cls:
    #|
    #|    def f(self, a):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0996" {
  let source =
    #|class cls:
    #|
    #|    def f(self, b=2):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0997" {
  let source =
    #|class cls:
    #|
    #|    def f(self, a, b):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0998" {
  let source =
    #|class cls:
    #|
    #|    def f(self, a, b=2):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/0999" {
  let source =
    #|class cls:
    #|
    #|    def f(self, a=5, b=2):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

///|
test "generated/program/1000" {
  let source =
    #|class cls:
    #|
    #|    def f(self, *, a=1, b=2):
    #|        pass
  let result = Interpreter::new_spec().exec_source(source)
  let expected = "[\"err\", \"NameError: name '__name__' is not defined\"]"
  assert_run(result, expected)
}

